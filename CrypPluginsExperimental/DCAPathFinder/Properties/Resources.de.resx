<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BtnSkipChapter" xml:space="preserve">
    <value>Kapitel überspringen</value>
  </data>
  <data name="ChoiceOfAlgorithm" xml:space="preserve">
    <value>Wahl des Algorithmus</value>
  </data>
  <data name="ChoiceOfAlgorithmToolTop" xml:space="preserve">
    <value>An dieser Stelle kann einer der in der Liste enthaltenen Algorithmen ausgewählt werden. Dieser kann mittels differenzieller Kryptoanalyse untersucht werden.</value>
  </data>
  <data name="Cipher1" xml:space="preserve">
    <value>Chiffre 1: 16 Bit Blockgröße, 2 Rundenschlüssel, der Schlüssel ist 32 Bit groß</value>
  </data>
  <data name="Cipher2" xml:space="preserve">
    <value>Chiffre 2: 16 Bit Blockgröße, 4 Rundenschlüssel, der Schlüssel ist 64 Bit groß</value>
  </data>
  <data name="Cipher3" xml:space="preserve">
    <value>Chiffre 3: 16 Bit Blockgröße, 6 Rundenschlüssel, der Schlüssel ist 96 Bit groß</value>
  </data>
  <data name="Cipher4" xml:space="preserve">
    <value>Chiffre 4: 4 Bit Blockgröße , 4 Rundenschlüssel, der Schlüssel ist 16 Bit groß</value>
  </data>
  <data name="DescriptionContent1" xml:space="preserve">
    <value>In den Einstellungen dieser Komponente können Sie zwischen den Tutorials wechseln. Es folgt eine kurze Beschreibung der Chiffren der einzelnen Teile des Tutorials:</value>
  </data>
  <data name="DescriptionContent2" xml:space="preserve">
    <value>Tutorial 1 verwendet Chiffre 1 der ToyChiffren-Komponente. Diese Chiffre arbeitet auf 16 Bit Blöcken und verwendet zwei Rundenschlüssel. Es wird eine Verschlüsselungsrunde ausgeführt. In diesem Tutorial werden zwei unbekannte, je 16 Bit große Rundenschlüssel wiederhergestellt.</value>
  </data>
  <data name="DescriptionContent3" xml:space="preserve">
    <value>Tutorial 2 verwendet Chiffre 2 der ToyChiffren-Komponente. Diese Chiffre arbeitet auf 16 Bit Blöcken und verwendet vier Rundenschlüssel. Es werden drei Verschlüsselungsrunden ausgeführt. In diesem Tutorial werden vier unbekannte, je 16 Bit große Rundenschlüssel wiederhergestellt.</value>
  </data>
  <data name="DescriptionContent4" xml:space="preserve">
    <value>Tutorial 3 verwendet Chiffre 3 der ToyChiffren-Komponente. Diese Chiffre arbeitet auf 16 Bit Blöcken und verwendet sechs Rundenschlüssel. Es werden fünf Verschlüsselungsrunden ausgeführt. In diesem Tutorial werden sechs unbekannte, je 16 Bit große Rundenschlüssel wiederhergestellt.</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Beschreibung der Tutorials</value>
  </data>
  <data name="DescriptionSubHeader1" xml:space="preserve">
    <value>Tutorial 1</value>
  </data>
  <data name="DescriptionSubHeader2" xml:space="preserve">
    <value>Tutorial 2</value>
  </data>
  <data name="DescriptionSubHeader3" xml:space="preserve">
    <value>Tutorial 3</value>
  </data>
  <data name="DifferentialCryptanalysisHeader" xml:space="preserve">
    <value>2. Differenzielle Kryptoanalyse von Chiffre 1</value>
  </data>
  <data name="DifferentialCryptanalysisSlide1Content1" xml:space="preserve">
    <value>An dieser Stelle wenden wir die Idee der differenziellen Kryptoanalyse auf Chiffre 1 an. Der Aufbau einer Chiffre ist in aller Regel öffentlich, sodass alle Bestandteile und deren Funktionsweise bekannt sind. Die Sicherheit einer Chiffre sollte niemals auf Geheimhaltung der Konstruktion basieren, sondern auf der Geheimhaltung des Schlüssels. Diese Forderung wird auch Kerckhoffs’ Prinzip genannt.</value>
  </data>
  <data name="DifferentialCryptanalysisSlide1Content2" xml:space="preserve">
    <value>Chiffre 1 besteht aus Schlüsseladdition und Substitution. Der Aufbau kann in der ToyChiffre-Komponente betrachtet werden. Wir versuchen nun die zwei unbekannten Rundenschlüssel k0 und k1 wiederherzustellen. Dazu betrachten wir zunächst die einzelnen Schritte der Verschlüsselung. Zunächst wird eine Schlüsseladdition zum Eingabeblock durchgeführt mit k0. Wir erhalten:</value>
  </data>
  <data name="DifferentialCryptanalysisSlide1Content3" xml:space="preserve">
    <value>Anschließend erfolgt eine Substitution durch die SBoxen:</value>
  </data>
  <data name="DifferentialCryptanalysisSlide1Header" xml:space="preserve">
    <value>Differenzielle Kryptoanalyse von Chiffre 1</value>
  </data>
  <data name="DifferentialCryptanalysisSlide2Content1" xml:space="preserve">
    <value>als Letztes erfolgt wieder eine Schlüsseladdition mit k1:</value>
  </data>
  <data name="DifferentialCryptanalysisSlide2Header" xml:space="preserve">
    <value>Differenzielle Kryptoanalyse von Chiffre 1</value>
  </data>
  <data name="DifferentialCryptanalysisSlide3Content1" xml:space="preserve">
    <value>Die folgende Abbildung fasst den Verschlüsselungsprozess, wie zuvor skizziert, zusammen:</value>
  </data>
  <data name="DifferentialCryptanalysisSlide3Header" xml:space="preserve">
    <value>Differenzielle Kryptoanalyse von Chiffre 1</value>
  </data>
  <data name="ExpectedDifferential" xml:space="preserve">
    <value>Erwartete Differenz</value>
  </data>
  <data name="ExpectedDifferentialToolTip" xml:space="preserve">
    <value>Diese Differenz beschreibt den Erwartungswert, der an der zuvor spezifizierten Stelle (Runde, SBox) mit hoher Wahrscheinlichkeit auftreten soll</value>
  </data>
  <data name="IntroductionHeader" xml:space="preserve">
    <value>1. Einführung</value>
  </data>
  <data name="IntroductionSlide1Content1" xml:space="preserve">
    <value>In diesem Abschnitt betrachten wir die Grundidee der differenziellen Kryptoanalyse. Viele symmetrische rundenbasierte Blockchiffren bestehen aus drei grundlegenden Operationen: Schlüsseladdition, Substitution und Permutation. In diesem Abschnitt beschränken wir uns zunächst auf Schlüsseladdition und Substitution.</value>
  </data>
  <data name="IntroductionSlide1Content2" xml:space="preserve">
    <value>Bei der Schlüsseladdition verwenden sehr viele Chiffren die XOR-Operation (Exklusiv-Oder). Die XOR-Operation ist ein zweistelliger-Operator, der durch folgende Wertetabelle beschrieben werden kann:</value>
  </data>
  <data name="IntroductionSlide1DataColHeader1" xml:space="preserve">
    <value>Eingabebit A</value>
  </data>
  <data name="IntroductionSlide1DataColHeader2" xml:space="preserve">
    <value>Eingabebit B</value>
  </data>
  <data name="IntroductionSlide1DataColHeader3" xml:space="preserve">
    <value>Ergebnisbit</value>
  </data>
  <data name="IntroductionSlide1Header" xml:space="preserve">
    <value>Einführung</value>
  </data>
  <data name="IntroductionSlide2Content1" xml:space="preserve">
    <value>Wird die XOR-Operation mit einer Nachricht m und Schlüssel k durchgeführt, erhält man den Schlüsseltext:</value>
  </data>
  <data name="IntroductionSlide2Content2" xml:space="preserve">
    <value>Die Grundidee der differenziellen Kryptoanalyse ist es nun, dass der Schlüssel zweimal verwendet wird. Wir betrachten an dieser Stelle die Auswirkung:</value>
  </data>
  <data name="IntroductionSlide2Content3" xml:space="preserve">
    <value>Wir erhalten wieder die ursprüngliche Nachricht m. Der XOR-Operator wird häufig auch als Differenz-Operator bezeichnet. Diese Benennung nutzen wir in diesem Tutorial auch.</value>
  </data>
  <data name="IntroductionSlide2Content4" xml:space="preserve">
    <value>In der Realität sind Chiffren umfangreicher, komplizierter und bestehen nicht ausschließlich aus Schlüsseladditionen. Die
differenzielle Kryptoanalyse ist ein so genannter "Chosen Plaintext-Angriff", das bedeutet der Kryptoanalyst kann Klartext-Nachrichten auswählen und diese verschlüsseln lassen, so dass er passende Klartext-/Geheimtext-Paare hat.</value>
  </data>
  <data name="IntroductionSlide2Header" xml:space="preserve">
    <value>Einführung</value>
  </data>
  <data name="IntroductionSlide3Content1" xml:space="preserve">
    <value>Die Idee des zweimaligen Anwenden des Schlüssels nutzen wir, indem wir Paare von Nachrichten betrachen. Dann kann folgendes berechnet werden:</value>
  </data>
  <data name="IntroductionSlide3Content2" xml:space="preserve">
    <value>Nun gilt:</value>
  </data>
  <data name="IntroductionSlide3Content3" xml:space="preserve">
    <value>In Worten, wir erhalten die Differenz der Klartexte durch Berechnung der Differenz der Schlüsseltexte.</value>
  </data>
  <data name="IntroductionSlide3Header" xml:space="preserve">
    <value>Einführung</value>
  </data>
  <data name="MessageCount" xml:space="preserve">
    <value>Nachrichtenanzahl</value>
  </data>
  <data name="MessageCountToolTip" xml:space="preserve">
    <value>Anzahl an Nachrichten, die das Orakel generieren soll</value>
  </data>
  <data name="OverviewContent1" xml:space="preserve">
    <value>Herzlich willkommen zum Tutorial zur differenziellen Kryptoanalyse. Dieses Verfahren zur Analyse rundenbasierter symmetrischer Blockchiffren hat das Ziel, einzelne Bits bis hin zu vollständigen Rundenschlüsseln wiederherzustellen. Veröffentlicht wurde dieses Verfahren 1991 von den zwei israelischen Forschern Eli Biham und Adi Shamir. </value>
  </data>
  <data name="OverviewContent2" xml:space="preserve">
    <value>Dieses Tutorial handelt das DCA-Verfahren in drei Teilen. Teil 1 vermittelt die grundlegende Idee der differenziellen Kryptoanalyse (DCA) anhand einer Chiffre mit einer Verschlüsselungsrunde. Teil 2 vertieft diese Idee anhand einer Chiffre mit drei Verschlüsselungsrunden. In Teil drei wird das vermittelte Wissen vertieft durch Erhöhung der Komplexität der Chiffre auf 5 Verschlüsselungsrunden.</value>
  </data>
  <data name="OverviewContent3" xml:space="preserve">
    <value>In der Konfiguration dieser Komponente können die verschiedenen Teile des Tutorials ausgewählt werden.</value>
  </data>
  <data name="OverviewContent4" xml:space="preserve">
    <value>Viel Spaß beim Ausprobieren und Brechen der Chiffren!</value>
  </data>
  <data name="OverviewContent5" xml:space="preserve">
    <value>(Diese Einführung kann durch Starten des Workspaces übersprungen werden)</value>
  </data>
  <data name="OverviewHeader" xml:space="preserve">
    <value>Tutorial zur differenziellen Kryptoanalyse</value>
  </data>
  <data name="Path" xml:space="preserve">
    <value>Pfad der Charakteristik</value>
  </data>
  <data name="PathToolTip" xml:space="preserve">
    <value>Diese Werte beschreiben den Fluss der Differenzwerte durch eine Chiffre.</value>
  </data>
  <data name="PluginCaption" xml:space="preserve">
    <value>DCA PfadFinder</value>
  </data>
  <data name="PluginTooltip" xml:space="preserve">
    <value>Die DCA PfadFinder-Komponente sucht in Abhängigkeit von durch den User spezifizierten Parametern nach Differenzialen in einer symmetrischen Blockchiffre.</value>
  </data>
  <data name="StartMaskContent1" xml:space="preserve">
    <value>Durch Starten des Workspaces beginnt das Tutorial.</value>
  </data>
  <data name="StartMaskContent2" xml:space="preserve">
    <value>Momentan haben Sie Tutorial {0} ausgwählt.</value>
  </data>
  <data name="StartMaskHeader" xml:space="preserve">
    <value>Bereit zur Ausführung</value>
  </data>
  <data name="TitleHeader" xml:space="preserve">
    <value>Tutorial Differenzielle Kryptoanalyse symmetrischer Blockchiffren</value>
  </data>
</root>