<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BtnSkipChapter" xml:space="preserve">
    <value>Kapitel überspringen</value>
  </data>
  <data name="ChoiceOfAlgorithm" xml:space="preserve">
    <value>Wahl des Algorithmus</value>
  </data>
  <data name="ChoiceOfAlgorithmToolTop" xml:space="preserve">
    <value>An dieser Stelle kann einer der in der Liste enthaltenen Algorithmen ausgewählt werden. Dieser kann mittels differenzieller Kryptoanalyse untersucht werden.</value>
  </data>
  <data name="Cipher1" xml:space="preserve">
    <value>Chiffre 1: 16 Bit Blockgröße, 2 Rundenschlüssel, der Schlüssel ist 32 Bit groß</value>
  </data>
  <data name="Cipher2" xml:space="preserve">
    <value>Chiffre 2: 16 Bit Blockgröße, 4 Rundenschlüssel, der Schlüssel ist 64 Bit groß</value>
  </data>
  <data name="Cipher3" xml:space="preserve">
    <value>Chiffre 3: 16 Bit Blockgröße, 6 Rundenschlüssel, der Schlüssel ist 96 Bit groß</value>
  </data>
  <data name="Cipher4" xml:space="preserve">
    <value>Chiffre 4: 4 Bit Blockgröße , 4 Rundenschlüssel, der Schlüssel ist 16 Bit groß</value>
  </data>
  <data name="DescriptionContent1" xml:space="preserve">
    <value>In den Einstellungen dieser Komponente können Sie zwischen den Tutorials wechseln. Es folgt eine kurze Beschreibung der Chiffren der einzelnen Teile des Tutorials:</value>
  </data>
  <data name="DescriptionContent2" xml:space="preserve">
    <value>Tutorial 1 verwendet Chiffre 1 der ToyChiffren-Komponente. Diese Chiffre arbeitet auf 16 Bit Blöcken und verwendet zwei Rundenschlüssel. Es wird eine Verschlüsselungsrunde ausgeführt. In diesem Tutorial werden zwei unbekannte, je 16 Bit große Rundenschlüssel wiederhergestellt.</value>
  </data>
  <data name="DescriptionContent3" xml:space="preserve">
    <value>Tutorial 2 verwendet Chiffre 2 der ToyChiffren-Komponente. Diese Chiffre arbeitet auf 16 Bit Blöcken und verwendet vier Rundenschlüssel. Es werden drei Verschlüsselungsrunden ausgeführt. In diesem Tutorial werden vier unbekannte, je 16 Bit große Rundenschlüssel wiederhergestellt.</value>
  </data>
  <data name="DescriptionContent4" xml:space="preserve">
    <value>Tutorial 3 verwendet Chiffre 3 der ToyChiffren-Komponente. Diese Chiffre arbeitet auf 16 Bit Blöcken und verwendet sechs Rundenschlüssel. Es werden fünf Verschlüsselungsrunden ausgeführt. In diesem Tutorial werden sechs unbekannte, je 16 Bit große Rundenschlüssel wiederhergestellt.</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Beschreibung der Tutorials</value>
  </data>
  <data name="DescriptionSubHeader1" xml:space="preserve">
    <value>Tutorial 1</value>
  </data>
  <data name="DescriptionSubHeader2" xml:space="preserve">
    <value>Tutorial 2</value>
  </data>
  <data name="DescriptionSubHeader3" xml:space="preserve">
    <value>Tutorial 3</value>
  </data>
  <data name="ExpectedDifferential" xml:space="preserve">
    <value>Erwartete Differenz</value>
  </data>
  <data name="ExpectedDifferentialToolTip" xml:space="preserve">
    <value>Diese Differenz beschreibt den Erwartungswert, der an der zuvor spezifizierten Stelle (Runde, SBox) mit hoher Wahrscheinlichkeit auftreten soll</value>
  </data>
  <data name="MessageCount" xml:space="preserve">
    <value>Nachrichtenanzahl</value>
  </data>
  <data name="MessageCountToolTip" xml:space="preserve">
    <value>Anzahl an Nachrichten, die das Orakel generieren soll</value>
  </data>
  <data name="OverviewContent1" xml:space="preserve">
    <value>Herzlich willkommen zum Tutorial zur differenziellen Kryptoanalyse. Dieses Verfahren zur Analyse rundenbasierter symmetrischer Blockchiffren hat das Ziel, einzelne Bits bis hin zu vollständigen Rundenschlüsseln wiederherzustellen. Veröffentlicht wurde dieses Verfahren 1991 von den zwei israelischen Forschern Eli Biham und Adi Shamir. </value>
  </data>
  <data name="OverviewContent2" xml:space="preserve">
    <value>Dieses Tutorial handelt das DCA-Verfahren in drei Teilen. Teil 1 vermittelt die grundlegende Idee der differenziellen Kryptoanalyse (DCA) anhand einer Chiffre mit einer Verschlüsselungsrunde. Teil 2 vertieft diese Idee anhand einer Chiffre mit drei Verschlüsselungsrunden. In Teil drei wird das vermittelte Wissen vertieft durch Erhöhung der Komplexität der Chiffre auf 5 Verschlüsselungsrunden.</value>
  </data>
  <data name="OverviewContent3" xml:space="preserve">
    <value>In der Konfiguration dieser Komponente können die verschiedenen Teile des Tutorials ausgewählt werden.</value>
  </data>
  <data name="OverviewContent4" xml:space="preserve">
    <value>Viel Spaß beim Ausprobieren und Brechen der Chiffren!</value>
  </data>
  <data name="OverviewHeader" xml:space="preserve">
    <value>Tutorial zur differenziellen Kryptoanalyse</value>
  </data>
  <data name="Path" xml:space="preserve">
    <value>Pfad der Charakteristik</value>
  </data>
  <data name="PathToolTip" xml:space="preserve">
    <value>Diese Werte beschreiben den Fluss der Differenzwerte durch eine Chiffre.</value>
  </data>
  <data name="PluginCaption" xml:space="preserve">
    <value>DCA PfadFinder</value>
  </data>
  <data name="PluginTooltip" xml:space="preserve">
    <value>Die DCA PfadFinder-Komponente sucht in Abhängigkeit von durch den User spezifizierten Parametern nach Differenzialen in einer symmetrischen Blockchiffre.</value>
  </data>
</root>