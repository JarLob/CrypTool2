using System.ComponentModel;
using System.Windows.Controls;
using Cryptool.PluginBase;
using Cryptool.PluginBase.Miscellaneous;
using Cryptool.PluginBase.IO;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Cryptool.Plugins.SATAttack
{
    [Author("Max Brandi", "max.brandi@rub.de", null, null)]
    [PluginInfo("SATAttack.Properties.Resources", "PluginCaption", "PluginDescription", "SATAttack/Documentation/doc.xml", new[] { "CrypWin/images/default.png" })]
    [ComponentCategory(ComponentCategory.ToolsMisc)]
    public class SATAttack : ICrypComponent
    {
        #region Private Variables


        private readonly SATAttackSettings settings = new SATAttackSettings();
        private CStreamWriter outputStream;
        private StringBuilder outputString;
        private CStreamWriter cbmcDebugOutputStream;
        private StringBuilder cbmcDebugOutputString;
        private Encoding encoding = Encoding.UTF8;
        private string pluginDataPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
            + "\\Data\\SATAttack\\";
        string codefileName = "codefile.c";


        #endregion

        #region Data Properties

        [PropertyInfo(Direction.InputData, "InputStreamCaption", "InputDataStreamTooltip", false)]
        public ICryptoolStream InputStream
        {
            get;
            set;
        }

        [PropertyInfo(Direction.OutputData, "CBMCDebugStream", "CBMCDebugStreamTooltip", false)]
        public ICryptoolStream CbmcDebugOutputStream
        {
            get
            {
                return cbmcDebugOutputStream;
            }
            set
            {
                // empty
            }
        }

        [PropertyInfo(Direction.OutputData, "OutputStreamCaption", "OutputDataStreamTooltip", false)]
        public ICryptoolStream OutputStream
        {
            get
            {
                return outputStream;
            }
            set
            {
                // empty
            }
        }

        #endregion

        public void Execute()
        {

            //TODO: switch construct for selected attack mode

            ProgressChanged(0, 1);

            /* reset cbmc debug stream */
            cbmcDebugOutputString = null;
            cbmcDebugOutputString = new StringBuilder();


            /* get the file which contains the C code */
            string codefilePath = GetCodefilePath();


            /* call cbmc */
            string mainFunctionName = settings.MainFunctionName;
            if (CallCbmcProcess(codefilePath, mainFunctionName) != 0)
            {
                GuiLogMessage("Cbmc process returned with an error.", NotificationLevel.Error);
                return;
            }


            /* append encoding of the output hash to the cnf generated by cbmc */
            string outputMappingFilePath = "output.outputMapping.txt";
            string outputCnfFilePath = "output.cnf.txt";

            if (encodeHashInCnf(outputMappingFilePath, outputCnfFilePath) != 0)
            {
                GuiLogMessage("Hash encoding returned with an error.", NotificationLevel.Error);
                return;
            }

            /* call SAT solver and pass cnf file to it */
            string satSolverOutputFilename = "solver.output.txt";
            string satSolverOutputFilePath = pluginDataPath + satSolverOutputFilename;
            if (callSatSolver(outputCnfFilePath, satSolverOutputFilePath) != 10) // 10: sat, 20: unsat
            { 
                GuiLogMessage("SAT solver did not return \"satisfiable\".", NotificationLevel.Error);

                outputStream = new CStreamWriter();
                outputStream.Write(encoding.GetBytes("There exists no possible solution for the specified settings (hash value, input message bits, C code program logic)".ToString()));
                outputStream.Close();
                OnPropertyChanged("OutputStream");

                return;                
            }
               
            /* interpret SAT solver output */
            string inputMappingFilePath = "output.inputMapping.txt";
            string outputString = processSatSolverOutput(satSolverOutputFilePath, inputMappingFilePath);

            if (outputString == null)
            {
                GuiLogMessage("Processing SAT solver output returned an error.", NotificationLevel.Error);
                return;  
            }

            outputStream = new CStreamWriter();
            outputStream.Write(encoding.GetBytes(outputString.ToString()));
            outputStream.Close();
            OnPropertyChanged("OutputStream");


            ////DEBUG
            //outputStream = new CStreamWriter();
            //outputStream.Write(encoding.GetBytes("bla".ToString()));
            //outputStream.Close();
            //OnPropertyChanged("OutputStream");

            ProgressChanged(1, 1);
        }

        #region IPlugin Members

        public ISettings Settings
        {
            get { return settings; }
        }

        public UserControl Presentation
        {
            get { return null; }
        }

        public void PreExecution()
        {
        }

        public void PostExecution()
        {
        }

        public void Stop()
        {
        }

        public void Initialize()
        {
            settings.UpdateTaskPaneVisibility();
        }

        public void Dispose()
        {
        }

        #endregion

        #region Event Handling

        public event StatusChangedEventHandler OnPluginStatusChanged;

        public event GuiLogNotificationEventHandler OnGuiLogNotificationOccured;

        public event PluginProgressChangedEventHandler OnPluginProgressChanged;

        public event PropertyChangedEventHandler PropertyChanged;

        private void GuiLogMessage(string message, NotificationLevel logLevel)
        {
            EventsHelper.GuiLogMessage(OnGuiLogNotificationOccured, this, new GuiLogEventArgs(message, this, logLevel));
        }

        private void OnPropertyChanged(string name)
        {
            EventsHelper.PropertyChanged(PropertyChanged, this, new PropertyChangedEventArgs(name));
        }

        private void ProgressChanged(double value, double max)
        {
            EventsHelper.ProgressChanged(OnPluginProgressChanged, this, new PluginProgressEventArgs(value, max));
        }

        #endregion

        #region Custom Methods


        /// <summary>
        /// This event is fired when the CBMC process writes data to standard output.
        /// </summary>
        void CbmcProcess_OutputDataReceived(object sendingProcess, DataReceivedEventArgs data)
        {
            //GuiLogMessage(String.Format("cbmcProcess_OutputDataReceived event fired at {0}",
            //    System.DateTime.UtcNow), NotificationLevel.Debug);

            bool dataReceived = data.Data != null;

            if (dataReceived)
            {
                //GuiLogMessage(String.Format("Output data => {0}", data.Data.ToString()), NotificationLevel.Debug);

                cbmcDebugOutputString.AppendLine(data.Data.ToString());

                cbmcDebugOutputStream = new CStreamWriter();
                cbmcDebugOutputStream.Write(encoding.GetBytes(cbmcDebugOutputString.ToString()));
                cbmcDebugOutputStream.Close();
                OnPropertyChanged("CbmcDebugOutputStream");
            }
        }

        /// <summary>
        /// This event is fired when the CBMC process writes data to standard error.
        /// </summary>
        void CbmcProcess_ErrorDataReceived(object sendingProcess, DataReceivedEventArgs data)
        {
            //GuiLogMessage(String.Format("cbmcProcess_ErrorDataReceived event fired at {0}",
            //    System.DateTime.UtcNow), NotificationLevel.Debug);

            bool dataReceived = data.Data != null;

            if (dataReceived)
            {
                //GuiLogMessage(String.Format("Error data => {0}", data.Data.ToString()), NotificationLevel.Debug);

                cbmcDebugOutputString.AppendLine(data.Data.ToString());

                cbmcDebugOutputStream = new CStreamWriter();
                cbmcDebugOutputStream.Write(encoding.GetBytes(cbmcDebugOutputString.ToString()));
                cbmcDebugOutputStream.Close();
                OnPropertyChanged("CbmcDebugOutputStream");
            }
        }

        /// <summary>
        /// Writes a stream of type ICryptoolStream to a file. The parameter filepath should end with "\\".
        /// </summary>
        void ReadInputStreamToCodefile(ICryptoolStream inputStream, string path, string filename)
        {
            using (CStreamReader reader = InputStream.CreateReader())
            {
                int bytesRead;
                byte[] buffer = new byte[1024];

                /* create directory if not existent */
                bool dirExists = Directory.Exists(path);

                if (!dirExists)
                    Directory.CreateDirectory(path);

                FileStream fs = File.Open(path + filename, FileMode.Create);
                BinaryWriter bw = new BinaryWriter(fs);

                while ((bytesRead = reader.Read(buffer)) > 0)
                {
                    bw.Write(buffer, 0, bytesRead);
                }

                fs.Close();
                bw.Close();
            }
        }

        /// <summary>
        /// Get path and filename of the C code input file.
        /// </summary>
        string GetCodefilePath()
        {
            string inputFilename = "";

            /* either read from InputStream or get file location from settings.InputFile */
            int inputSelection = settings.InputSelection;

            if (inputSelection == 0) // via InputStream
            {
                ReadInputStreamToCodefile(InputStream, pluginDataPath, codefileName);

                inputFilename = pluginDataPath + codefileName;
            }
            else if (inputSelection == 1) // via settings.InputFile
            {
                inputFilename = settings.InputFile;
            }

            return inputFilename;
        }

        /// <summary>
        /// Calls the CBMC process. When successful, a file output.cnf.txt is created which contains the cnf representation
        /// of the code in codefile.c.
        /// </summary>
        /// <param name="codefilePath">Full path to the codefile, including the name of the codefile.</param>
        /// <returns>
        /// 0 if successful or 1 the input codefile could not be found
        /// </returns>
        int CallCbmcProcess(string codefilePath, string mainFunctionName)
        {
            bool codefileExists = File.Exists(codefilePath);

            if (!codefileExists)
            {
                GuiLogMessage(String.Format("Codefile not found at {0}.", codefilePath), NotificationLevel.Error);
                return 1;
            }           
            
            string cbmcExeFilename = "cbmc.exe";

            /* build args */
            string cbmcProcessArgs = "\"" + codefilePath + "\"";
            if (mainFunctionName != "" && mainFunctionName != null)
                cbmcProcessArgs += " --function " + mainFunctionName;

            //GuiLogMessage(String.Format("cbmc.exe path is {0}",
            //    (pluginDataPath + cbmcExecutableFilename)), NotificationLevel.Info);

            Process cbmcProcess = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = pluginDataPath + cbmcExeFilename,
                    CreateNoWindow = true,
                    Arguments = cbmcProcessArgs,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                }
            };

            cbmcProcess.OutputDataReceived += new DataReceivedEventHandler(CbmcProcess_OutputDataReceived);
            cbmcProcess.ErrorDataReceived += new DataReceivedEventHandler(CbmcProcess_ErrorDataReceived);

            cbmcProcess.Start();
            cbmcProcess.BeginOutputReadLine();
            cbmcProcess.BeginErrorReadLine();
            cbmcProcess.WaitForExit();

            GuiLogMessage(String.Format(String.Format("Cbmc process returned with exitcode {0}",
                cbmcProcess.ExitCode)), NotificationLevel.Debug);
                
            //TODO: review cbmc process exitcodes
            return cbmcProcess.ExitCode;            
        }

        /// <summary>
        /// Converts a hex string into a bit array. The first bit in the array is the least significant bit and the last bit in the array is the most significant bit.
        /// </summary>
        BitArray HexStringToBitArray(string hex)
        {
            BitArray bitArray;

            if (!IsHexString(hex)) // check if all characters are hex
            {
                GuiLogMessage("Ensure the hash value is an even amount of regular hex numbers.", NotificationLevel.Error);
                return null;
            }
            else if (hex.Length % 2 != 0) // hash value must have an even amount of hex values
            {
                GuiLogMessage("Ensure the hash value is an even amount of regular hex numbers.", NotificationLevel.Error);
                return null;
            }
            else
            {
                byte[] byteArray = HexStringToByteArray(hex);
                bitArray = new BitArray(byteArray);
            }

            return bitArray;
        }

        /// <summary>
        /// Converts a BitArray into a hex string. The first bit in the array should be the least significant bit and the last bit in the array should be the most significant bit.
        /// </summary>
        string BitArrayToHexString(BitArray ba)
        {
            byte[] data = new byte[ba.Length / 8];
            ba.CopyTo(data, 0);

            return BitConverter.ToString(data);
        }
        
        /// <summary>
        /// Converts a hex string into a byte array.
        /// </summary>
        byte[] HexStringToByteArray(String hex)
        {
            int NumberChars = hex.Length;
            byte[] bytes = new byte[NumberChars / 2];
            for (int i = 0; i < NumberChars; i += 2)
            {
                // begin with the last two nibbles and iterate from right to left to respect byte ordering
                bytes[(NumberChars / 2) - 1 - i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            }

            return bytes;
        }

        /// <summary>
        /// Check if a string only contains hex characters.
        /// </summary>
        bool IsHexString(string test)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(test, @"\A\b[0-9a-fA-F]+\b\Z");
        }

        /// <summary>
        /// Convert byte to bits
        /// </summary>
        IEnumerable<bool> GetBits(byte b)
        {
            for (int i = 0; i < 8; i++)
            {
                yield return (b & 0x80) != 0;
                b *= 2;
            }
        }

        /// <summary>
        /// Returns an int array which contains the labels of the output literals (from lsb to msb).
        /// </summary>
        int[] getMapping(string mappingFilePath)
        {
            bool mappingFileExists = File.Exists(mappingFilePath);

            if (!mappingFileExists)
            {
                GuiLogMessage(String.Format("Mapping file not found at {0}.", mappingFilePath), NotificationLevel.Error);
                return null;
            }
            
            /* read output mapping file  */
            string mappingFileContent = readFileToString(mappingFilePath);

            /* build mapping array */
            int[] mapping;

            string[] lines = mappingFileContent.Split(Environment.NewLine.ToCharArray());
            //mapping = new int[lines.Length - 1]; // -1 because last line in the file is a blank line

            string variableNumberAsString;
            int variableNumber;
            string variableType;
            int positionOfUnderscore;
            int literalValue;
            string[] tmp;

            /* read last variable to determine minimum size of the mapping array and variable type (input or output) */
            string lastVariable = lines[lines.Length - 2].Split(' ')[0];
            positionOfUnderscore = lastVariable.IndexOf("_");
            variableType = lastVariable.Substring(0, positionOfUnderscore);
            variableNumberAsString = lastVariable.Substring(positionOfUnderscore + 1);

            if (int.TryParse(variableNumberAsString, out variableNumber))
            {
                mapping = new int[variableNumber + 1];
            }
            else
            {
                GuiLogMessage(String.Format("Could not determine index of the most significant {0} variable {1}", variableType, lastVariable), NotificationLevel.Error);
                return null;
            }

            foreach (string line in lines)
            {
                tmp = null;
                tmp = line.Split(' ');

                if (tmp.Length == 2)
                {
                    positionOfUnderscore = tmp[0].IndexOf("_");
                    variableNumberAsString = tmp[0].Substring(positionOfUnderscore + 1);

                    if (int.TryParse(variableNumberAsString, out variableNumber))
                    {
                        if (int.TryParse(tmp[1], out literalValue))
                        {
                            if (variableNumber < mapping.Length)
                            {
                                mapping[variableNumber] = literalValue;
                            }
                            else
                            {
                                GuiLogMessage(String.Format("Make sure the variable definitions start with {0}_0 respectively, the indices are incremented steadily and each variable is used in the code.", variableType), NotificationLevel.Error);
                                return null;
                            }
                        }
                        else
                        {
                            GuiLogMessage(String.Format("Failed to parse the literal for {0} variable {1}: {2}.", variableType, tmp[0], literalValue), NotificationLevel.Error);
                            return null;
                        }
                    }
                    else
                    {
                        GuiLogMessage(String.Format("Failed to parse the variable index for {0} variable {1}: {2}.",variableType, tmp[0], variableNumberAsString), NotificationLevel.Error);
                        return null;
                    }
                }
            }

            /* print warning for unassigned variables */
            for (int i = 0; i < mapping.Length; i++)
            {
                if (mapping[i] == 0)
                    GuiLogMessage(String.Format("Variable {0}_{1} does not appear in the {0} mapping, is it used in the code? It will be assigned 'false' by default.", variableType, i), NotificationLevel.Warning);
            }

            return mapping;
        }

        /// <summary>
        /// Reads the mapping file generated by cbmc and reads the hash value provided by the user in the plugin parameters.
        /// Opens the cnf file generated by cbmc and appends the encoding of the hash value provided by the user.
        /// </summary>
        int encodeHashInCnf(string outputMappingFilePath, string outputCnfFilePath)
        {
            /* get the output literals */
            int[] outputMapping;
            if ((outputMapping = getMapping(outputMappingFilePath)) == null)
            {
                GuiLogMessage("Error retreiving outuput mapping.", NotificationLevel.Error);
                return 1;
            }

            /* get the hash value as bit array (ranging from lsb to msb) */
            BitArray hashBits;
            if ((hashBits = HexStringToBitArray(settings.InputHashValue)) == null)
            {
                GuiLogMessage("Error retreiving hash bits.", NotificationLevel.Error);
                return 1;
            }

            /* ensure hash value and output bits have the same size */
            if (hashBits.Length != outputMapping.Length)
            {
                GuiLogMessage("Ensure the specified hash value has the correct length." + Environment.NewLine
                    + String.Format("Hash value: {0} bits", hashBits.Length) + Environment.NewLine
                    + String.Format("Output: {0} bits", outputMapping.Length)
                    , NotificationLevel.Error);
                return 1;
            }

            /* build the cnf that encodes the hash value */
            StringBuilder hashEncoding = new StringBuilder();

            string sign;

            for (int i = 0; i < hashBits.Length; i++)
            {
                if (hashBits[i])    // 1
                    sign = "";
                else                // 0
                    sign = "-";

                hashEncoding.Append(String.Format("{0}{1} 0" + Environment.NewLine, sign, outputMapping[i])); // clause line
            }

            /* append hash encoding to the cnf generated by cbmc */
            bool cnfFileExists = File.Exists(outputCnfFilePath);

            if (!cnfFileExists)
            {
                GuiLogMessage(String.Format("Cnf file not found at {0}.", outputCnfFilePath), NotificationLevel.Error);
                return 1;
            }

            using (FileStream fs = File.Open(outputCnfFilePath, FileMode.Append))
            {
                fs.Write(encoding.GetBytes(hashEncoding.ToString()), 0, hashEncoding.Length);            
            }

            return 0;
        }

        /// <summary>
        /// Calls the SAT solver Cryptominisat and passes the CNF file at `cnfFilePath`. The output of the SAT solver (literal assignment) is written to `satSolverOutputFilepath`.
        /// </summary>
        /// <param name="cnfFilePath">Path to the CNF file</param>
        /// <param name="satSolverOutputFilePath">Path where the SAT solver output file is written to (including filename)</param>
        /// <returns></returns>
        int callSatSolver(string cnfFilePath, string satSolverOutputFilePath)
        {
            bool outputCnfFileExists = File.Exists(cnfFilePath);

            if (!outputCnfFileExists)
            {
                GuiLogMessage(String.Format("Cnf file not found @ {0}.", cnfFilePath), NotificationLevel.Error);
                return 1;
            }

            string satSolverFilename = "cryptominisat32.exe";

            /* build args */
            string satSolverProcessArgs = "\"" + cnfFilePath + "\" \"" + satSolverOutputFilePath + "\"";

            Process satSolverProcess = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = pluginDataPath + satSolverFilename,
                    CreateNoWindow = true,
                    Arguments = satSolverProcessArgs,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                }
            };

            GuiLogMessage(String.Format(String.Format("Calling SAT solver at {0} with parameters {1}",
                pluginDataPath+satSolverFilename, satSolverProcessArgs)), NotificationLevel.Debug);

            satSolverProcess.Start();
            satSolverProcess.WaitForExit();

            GuiLogMessage(String.Format(String.Format("SAT solver process returned with exitcode {0}",
                satSolverProcess.ExitCode)), NotificationLevel.Debug);

            //TODO: review cmsat exitcodes
            return satSolverProcess.ExitCode;
        }

        /// <summary>
        /// Interprets the SAT solver's output literal assignment to define the bits of the input variables.
        /// </summary>
        /// <param name="satSolverOutputFilePath">Path to the file which contains the literal assignments obtained by the SAT solver</param>
        /// <param name="inputMappingFilePath">Path to the input mapping file obtained by CBMC which maps the input variables to CNF literals</param>
        /// <returns>A string which describes the assignment of the input variables in binary and hexadecimal form</returns>
        string processSatSolverOutput(string satSolverOutputFilePath, string inputMappingFilePath)
        {
            BitArray messageBits = null;

            bool satSolverOutputFileExists = File.Exists(satSolverOutputFilePath);

            if (!satSolverOutputFileExists)
            { 
                GuiLogMessage(String.Format("Sat solver output file not found at {0}.", satSolverOutputFilePath), NotificationLevel.Error);
                return null;
            }
        
            /* read sat solver output file */
            string satSolverOutputFileContent = readFileToString(satSolverOutputFilePath);

            string[] lines = satSolverOutputFileContent.Split(Environment.NewLine.ToCharArray());

            if (lines[0] == "SAT")
            {
                int[] inputMapping = getMapping(inputMappingFilePath);
                if (inputMapping == null)
                {
                    GuiLogMessage("Error retreiving input mapping.", NotificationLevel.Error);
                    return null;                    
                }

                int numberOfInputBits = inputMapping.Length;
                string[] inputLiterals = lines[1].Split(' ');

                messageBits = new BitArray(numberOfInputBits, false);

                foreach (string literal in inputLiterals)
                {
                    int signedLiteralValue;
                    int literalValue;
                    bool sign;

                    if (int.TryParse(literal, System.Globalization.NumberStyles.AllowLeadingSign, null, out signedLiteralValue))
                    {
                        if (signedLiteralValue == 0)     // skip last zero which occurs at the end of the sat solver variable assignments
                            continue;

                        if (signedLiteralValue < 0)      // literal looks like "-x"
                        {
                            sign = false;
                            literalValue = Math.Abs(signedLiteralValue);  // get absolute value without sign
                        }
                        else                // literal looks like "x"
                        {
                            sign = true;
                            literalValue = signedLiteralValue;
                        }

                        /* get the variable number, (e.g. "1" for "INPUT_1") to which the current literal refers */
                        int variableNumber = Array.IndexOf(inputMapping, literalValue);

                        /* assign the sign to the related input bit if it occurs in the input mapping array (literals 1 and 2 will not appear there, since they are given out by cbmc encoding the constant zero and one gates) */
                        if (variableNumber != -1)
                            messageBits[variableNumber] = sign;
                    }
                    else
                    {
                        GuiLogMessage(String.Format("Failed to parse the literal {0}.", literal), NotificationLevel.Error);
                        return null;
                    }
                }
            }
            else
            {
                GuiLogMessage(String.Format("First line in SAT solver output file {0} is not \"SAT\".", satSolverOutputFilePath), NotificationLevel.Error);
                return null; 
            }

            StringBuilder messageBitsString = new StringBuilder();

            int separatorCounter = 0;

            /* by using insert instead of append, the string shows the lsb on the right and msb on the left */
            foreach (bool inputBit in messageBits)
            {
                if (separatorCounter % 4 == 0)
                    messageBitsString.Insert(0, " ");   // add a whitespace after every four bits

                if (inputBit)
                    messageBitsString.Insert(0, "1");
                else
                    messageBitsString.Insert(0, "0");

                separatorCounter++;
            }

            string messageBitsBinaryString = messageBitsString.ToString();
            string messageBitsHexString = "";
            string inputHexCaption = "";

            if (messageBits.Length % 8 == 0)
            {
                messageBitsHexString = BitArrayToHexString(messageBits);
                inputHexCaption = "Input (hex):" + Environment.NewLine;
            }

            string outputString = 
                "Input (bin):" + Environment.NewLine 
                + messageBitsBinaryString + Environment.NewLine 
                + inputHexCaption
                + messageBitsHexString;

            return outputString;
        }

        /// <summary>
        /// Reads a file and returns its content in a string object.
        /// </summary>
        /// <param name="filepath">Path to the file to be read</param>
        /// <returns>String which contains the content of the file</returns>
        string readFileToString(string filepath)
        {
            using (FileStream fs = File.Open(filepath, FileMode.Open))
            {
                StringBuilder sb = new StringBuilder();

                if (fs.Length > 65536) // stop if the mapping file is too big (arbitrary big number) (paranoid)
                {
                    GuiLogMessage(String.Format("File {0} is very big: {1} bytes", filepath, fs.Length), NotificationLevel.Warning);
                }

                byte[] buffer = new byte[fs.Length];

                while (fs.Read(buffer, 0, buffer.Length) > 0)
                {
                    sb.Append(encoding.GetString(buffer));
                }

                return sb.ToString();
            }        
        }

        #endregion
    }
}
