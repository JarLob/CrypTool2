<?xml version="1.0" encoding="utf-8" ?>

<!-- You can edit this file manually or with the Util/CrypDocumentationEditor -->
<documentation>
  <language culture="en"/>
  <language culture="de-DE"/>

  <introduction lang="en">
    The SAT problem (abbreviation for <i>Boolean <b>sat</b>isfiability problem</i>) deals with the question whether a Boolean formula is satisfiable. Algorithms named SAT solver are able to solve this problem even for very large formulas. For detailed information about SAT solvers and the SAT problem, you can read the help file of the <docRef item="Cryptool.Plugins.SATSolver.SATSolver"/> component.<newline /><newline />
    SAT solvers have been used as tools in cryptanalysis since 1999. Any cryptographic function can be encoded in a Boolean formula in conjunctive normal form (CNF), which is the common input format for a SAT solver. Further information for the encoding of the specific properties of an attack must be added to the CNF: Consider for instance a preimage attack on a hash function. In this case, the encoding of the bits of the hash value are added to the CNF. When the SAT solver is able to solve the resulting CNF, the variable assignment obtained from the SAT solver output contains information about a valid preimage (a message that hashes to the provided hash value).<newline /><newline />
    The encoding of a cryptographic function in CNF is a laborious task. Usually the complete function is first written in another format (algebraic normal form, ANF) and then transformed into CNF. The advantage of this intermediate step is that it is comparably simple to write a cryptographic function in ANF instead of directly encoding the function in CNF. The transformation from ANF to CNF does not require any further effort as the transformation is generic and can be performed automatically. The tool XL0 for instance which can be found at <ref id="xl0"/> provides the functionality to transform ANF equations into CNF.<newline /><newline />
    The benefit of the SAT Attack component is that the encoding in CNF is performed automatically. The component uses a modified version of the bounded model checker tool CBMC to transform the ANSI-C code of a cryptographic function into a Boolean circuit which is then transformed into CNF. The type of attack and the required parameters (e.g. the hash value for a preimage attack on a hash function) must be entered in the component's settings. The encoding of this information is added to the CNF before the SAT solver tries to solve the CNF. Finally the SAT Attack component outputs a solution to the attack or prints out status information if the attack failed. Notice that both the SAT solver and CBMC are called by the SAT Attack component as external processes.<newline /><newline /> <!-- TODO: Verweis auf template -->
    Clearly, SAT-based cryptanalysis with the SAT Attack component is not as successful as in the case when the CNF encoding is performed manually. This is due to the fact that the automatic transformation from ANSI-C code leads to a CNF which is not as optimized as manually performed encoding. However, the component provides a timely and easy-to-use approach for SAT-based cryptanalysis. Therefore, the component is especially useful for the first analysis of new cryptographic functions to get an idea of their vulnerability or resilience against algebraic attacks.
  </introduction>

  <introduction lang="de-DE">
    Das SAT-Problem (von engl. <i>Boolean <b>sat</b>isfiability problem</i>, <i>Erfüllbarkeitsproblem der Aussagenlogik</i>) fragt nach der Erfüllbarkeit einer aussagenlogischen Formel. Sogenannte SAT-Solver sind Algorithmen, die das SAT-Problem selbst für sehr große Formeln lösen können. Ausführliche Informationen über SAT-Solver und über das SAT-Problem finden Sie in der Hilfe-Datei der <docRef item="Cryptool.Plugins.SATSolver.SATSolver"/>-Komponente.<newline /><newline />
    SAT-Solver wurden 1999 zum ersten Mal als Werkzeug in der Kryptoanalyse eingesetzt. Grundsätzlich kann jede kryptographische Funktion als eine aussagenlogische Formel kodiert werden. Üblicherweise wird die Formel in die konjunktive Normalform (CNF von engl. conjunctive normal form) gebracht, da dies das gängige Eingabeformat von SAT-Solvern ist. Weitere Informationen, die die speziellen Eigenschaften des gewählten Angriffstyps kodieren, müssen der CNF hinzugefügt werden: Bei einem Pre-Image-Angriff auf eine Hashfunktion beispielsweise wird die Kodierung der Bits des Hashwertes der CNF hinzugefügt. Wenn der SAT-Solver eine Lösung für die CNF findet, kann man von der Variablenbelegung, die der SAT-Solver ausgibt, auf ein gültiges Pre-Image (eine Nachricht, deren Hash den angegebenen Hashwert ergibt) schließen.<newline /><newline />
    Das Kodieren einer kryptographischen Funktion in CNF ist sehr arbeitsaufwändig. Üblicherweise schreibt man zuerst die gesamte Funktion in einem anderen Format (algebraische Normalform, ANF) und transformiert diese dann nach CNF. Der Vorteil dieses Zwischenschrittes ist, dass es vergleichsweise einfach ist, eine kryptographische Funktion mit ANF-Gleichungen darzustellen anstatt direkt nach CNF zu kodieren. Die Transformation von ANF nach CNF braucht keinen weiteren Aufwand, da die Transformation generisch ist und daher automatisiert werden kann. Das Tool XL0 beispielsweise, welches bei <ref id="xl0"/> gefunden werden kann, ermöglicht die Transformation von ANF-Gleichungen nach CNF.<newline /><newline />
    Der Vorteil der SAT-Attack-Komponente ist es, dass das Kodieren in die CNF automatisch geschieht. Die Komponente nutzt eine modifizierte Version des Bounded-Model-Checker-Tools CBMC, um aus dem ANSI-C-Code einer kryptographischen Funktion einen Bool'schen Schaltkreis zu generieren. Dieser Schaltkreis wird dann in eine CNF-Darstellung der Funktion transformiert. Die Art des Angriffs und die benötigten Parameter (z.B. der Hashwert für einem Pre-Image-Angriff auf eine Hashfunktion) können in den Einstellungen der Komponente angegeben werden. Die Kodierung dieser zusätzlichen Parameter wird der CNF hinzugefügt, bevor der SAT-Solver versucht, die CNF zu lösen. Schließlich gibt die SAT-Attack-Komponente im Erfolgsfall eine Lösung für den Angriff aus, oder Statusinformationen, falls der Angriff fehlschlug. Sowohl der SAT-Solver als auch das CBMC-Tool werden  von der SAT-Attack-Komponente als externe Prozesse aufgerufen werden. <newline /><newline /> <!-- TODO: Verweis auf template -->
    Es ist offensichtlich, dass eine automatisierte SAT-basierte Kryptoanalyse, die mit der SAT-Attack-Komponente durchgeführt wird, nicht gleichermaßen erfolgreich ist, wie eine Analyse, bei der das Kodieren der CNF manuell durchgeführt wurde. Dies lässt sich damit begründen, dass eine manuelle Kodierung zu einer stärker optimierten CNF führt als bei der automatischen Transformation von ANSI-C-Code nach CNF. Nichtsdestotrotz bietet die SAT-Attack-Komponente eine leicht anwendbare Möglichkeit für die SAT-basierte Kryptoanalyse, die wenig zeitaufwändig ist. Daher ist die Komponente vor allem nützlich für erste Analysen von neuen kryptographischen Funktionen, um einen Eindruck von der Anfälligkeit oder der Widerstandsfähigkeit gegenüber algebraischen Angriffen zu bekommen.
  </introduction>

  <usage lang="en">
    <section headline="Input and Output">
      The SAT Attack component has one input and three output connectors. Through the input connector, the ANSI-C code can be passed directly to the component when pasted in a connected Text Input component. However, the input connector is not mandatory since the ANSI-C code can also directly be passed to the component when the "File input" option is chosen in the settings (see the <i>Parameters</i> section below). The two output connectors "CBMC output stream" and "SAT solver output stream" each forward the output of the related process. As they only display status information of these two processes, the outputs are optional and the component will run even when they are not connected. The last output connector named "Output stream" is the only mandatory connector. It outputs status information about the progress of the component and, finally, the result of the attack if it could be found.
    </section>

    <section headline="Parameters">
      The SAT Attack component allows the user to choose between several attack types and offers various settings which are explained in the following. Some parameters are entered via text boxes. The strings entered in these text boxes can either be hexadecimal strings denoted with the prefix "0x", or binary strings denoted with the prefix "0b".
      <list>
        <item>
          <b>Attack type</b> Choose between Preimage attack, Second preimage attack and Key-recovery attack.
        </item>
        <item>
          <b>Input selection</b> Choose whether the ANSI-C code is provided via a Text Input component which is connected with the input connector or directly via a file from a local storage device.
        </item>
        <item>
          <b>Main function name</b> Specify the name of the function which is the entry point in the ANSI-C code, if this is not the function named "main()".
        </item>
        <item>
          <b>Save CNF in file</b> Provides the option to save the generated CNF in a file on a local storage device.
        </item>
        <item>
          <b>CNF output only</b> Check this option, if the component should stop the execution after the CNF is generated and the chosen attack is encoded in the CNF. This will skip the solving by the SAT solver.
        </item>
        <item>
          <b>Fix input bits</b> Check this option for the possibility to fix (i.e. specify the value at specific bit locations) some of the input bits. When checked, a text box will appear below where the user can enter a binary or hexadecimal string to fix some of the input bits in advance. If a bit or a nibble in the string should not be fixed, this can be denoted with the character '*'. The string "0b0***1" for instance fixes the least significant bit to the value '1' and the most significant bit to the value '0'. The bits between these two bits are not fixed.
        </item>
      </list>
      The following options are visible depending on the selected attack type.
      <list>
        <item>
          <b>Hash value</b> Provide the hash value for which the component tries to find a valid preimage (or second preimage).
        </item>
        <item>
          <b>Second preimage</b> Provide a valid second preimage which hashes to the provided hash value.
        </item>
        <item>
          <b>Plaintext</b> Provide a plaintext for a key-recovery attack.
        </item>
        <item>
          <b>Ciphertext</b> Provide a ciphertext for a key-recovery attack.
        </item>
      </list>

      The solution which is output by the SAT Attack component is a valid preimage in case of a preimage or second preimage attack on a hash function, or the symmetric key in case of a key-recovery attack on a symmetric cipher. The ANSI-C code has to be modified since the input and output variables need to be known by the translation tool CBMC. Therefore, the input and output variables have to be tagged in a particular way: The input and output variables must be denoted "INPUT_x" and "OUTPUT_x" where the index 'x' is an incrementing number, starting with "INPUT_0" and "OUTPUT_0" for the least significant input or output variable. The ongoing numbers of the variables must be gapless and each of the variables must actually be used in the ANSI-C code.<newline /><newline />
      The variables must be assigned in the following way depending on the attack type:<newline /><newline />
      <b>Preimage and second preimage attack:</b>
      <list>
        <item>
          <b>INPUT_0 - INPUT_n</b> Message (Preimage)
        </item>
        <item>
          <b>OUTPUT_0 - OUTPUT_k</b> Hash value
        </item>
      </list>

      <b>Key-recovery attack:</b>
      <list>
        <item>
          <b>INPUT_0 - INPUT_n</b> Plaintext
        </item>
        <item>
          <b>INPUT_n+1 - INPUT_m</b> Key
        </item>
        <item>
          <b>OUTPUT_0 - OUTPUT_k</b> Ciphertext
        </item>
      </list>
      In a key-recovery attack, it is important that the index of the least significant variable of the key starts right after the index of the most significant variable of the plaintext (if the most significant plaintext variable is "INPUT_63", the least significant key variables must be "INPUT_64"). If the variable notations are faulty, the component may output false solutions or return an error. It is also important that none of the input variables is assigned in the ANSI-C code and that all of the output variables are assigned. This means the input variables must always be on the right side of an assignment and the output variables must always be on the left side (e.g. OUTPUT_0 = INPUT_0 ^ INPUT_1).
    </section>
  </usage>

  <usage lang="de-DE">
    <section headline="Input and Output">
      Die SAT-Attack-Komponente besitzt einen Eingabe-Konnektor und drei Ausgabe-Konnektoren. Durch den Eingabe-Konnektor kann der ANSI-C-Code direkt an die Komponente übergeben werden, indem dieser in einer angeschlossenen Texteingabe-Komponente eingefügt wird. Der Eingabe-Konnektor ist jedoch nur optional, da der ANSI-C Code auch direkt an die Komponente übergeben werden kann, wenn in den Einstellungen die Option "Dateieingabe" gewählt wurde (siehe Abschnitt <i>Parameter</i> weiter unten). Die beiden Ausgabe-Konnektoren "CBMC Ausgabestrom" und "SAT-Solver-Ausgabestrom" leiten beide die Ausgabe des jeweiligen Prozesses weiter. Da diese lediglich Statusinformationen der beiden Prozesse ausgeben, sind beide Anschlüsse optional und müssen nicht verbunden sein, damit die Komponente laufen kann. Der letzte Ausgabe-Konnektor hat die Bezeichnung "Ausgabestrom" und ist der einzige Anschluss, der verbunden sein muss, damit die Komponente ausführbar ist. Durch den Ausgabestrom-Konnektor werden Statusinformationen über den Fortschritt der Komponente ausgegeben und schließlich das Ergebnis des Angriffs, sofern eine Lösung gefunden wurde.
    </section>

    <section headline="Parameter">
      Die SAT-Attack-Komponente erlaubt dem Benutzer, zwischen verschiedenen Angriffs-Modi zu wählen. Sie bietet verschiedene Einstellungen, die im Folgenden erklärt werden. Einige der Parameter müssen über Textboxen eingegeben werden. Die Zeichenketten für diese Textboxen können entweder hexadezimale Zeichenketten sein, was mit dem Präfix "0x" gekennzeichnet wird, oder binäre Zeichenketten, was mit dem Präfix "0b" gekennzeichnet wird.
      <list>
        <item>
          <b>Angriffs-Modus</b> Wählen Sie zwischen First-Preimage-Angriff, Second-Preimage-Angriff und Key-Recovery-Angriff.
        </item>
        <item>
          <b>Eingabe-Auswahl</b> Wählen Sie aus, ob der ANSI-C-Code über die Texteingabe-Komponente, die mit dem Eingabe-Konnektor verbunden ist, zur Verfügung gestellt wird, oder direkt über eine Datei auf dem lokalen Speicher.
        </item>
        <item>
          <b>Name der main-Funktion</b> Geben Sie den Namen der Funktion ein, die der Einstiegspunkt des ANSI-C-Codes ist, falls dieser nicht "main()" lautet.
        </item>
        <item>
          <b>CNF in Datei speichern</b> Bietet die Möglichkeit, die generierte CNF in eine Datei auf dem lokalen Speicher zu schreiben.
        </item>
        <item>
          <b>Nur CNF-Ausgabe</b> Wählen Sie diese Option, wenn Sie wünschen, dass die Komponente die Ausführung stoppt, sobald die CNF generiert wurde und der gewählte Angriff in die CNF kodiert wurde. Diese Option überspringt den Aufruf des SAT-Solvers.
        </item>
        <item>
          <b>Eingabebits festlegen</b> Wählen Sie diese Option, um Eingabebits festzulegen. Wenn die Option angekreuzt ist, erscheint eine Textbox, in der Sie eine binäre oder hexadezimale Zeichenkette eingeben können, um einige Eingabebits im voraus festzulegen. Wenn ein Bit oder ein Nibble in der Zeichenkette nicht festgelegt werden soll, kann dafür das Zeichen '*' verwendet werden. Die Zeichenkette "0b0***1" beispielsweise legt das niederwertigste Bit auf den Wert '1' fest und das höchstwertigste Bit auf den Wert '0'. Die dazwischenliegenden Bits werden nicht festgelegt.
        </item>
      </list>
      Die folgenden Optionen sind abhängig von dem gewählten Angriffs-Modus.
      <list>
        <item>
          <b>Hashwert</b> Geben Sie den Hashwert an, für den die Komponente versucht, ein gültiges Urbild oder (zweites Urbild) zu finden.
        </item>
        <item>
          <b>Zweites Urbild</b> Geben Sie ein gültiges zweites Urbild an, dessen Hashwert den angegebenen Hashwert ergibt.
        </item>
        <item>
          <b>Klartext</b> Geben Sie den Klartext für einen Key-Recovery-Angriff an.
        </item>
        <item>
          <b>Geheimtext</b> Geben Sie den Geheimtext für einen Key-Recovery-Angriff an.
        </item>
      </list>

      Die ausgegebene Lösung der SAT-Attack-Komponente ist entweder ein gültiges Urbild im Falle eines First-Preimage-Angriffs oder eines Second-Preimage-Angriffs auf eine Hashfunktion, oder der Schlüssel im Falle eines Key-Recovery-Angriffs auf eine symmetrische Chiffre. Der ANSI-C-Code muss so angegeben werden, dass das Übersetzungstool CBMC weiß, welche Variablen die Eingabe und welche die Ausgabe darstellen. Dafür werden diese Variablen speziell gekennzeichnet: Eingabevariablen werden mit "INPUT_x" und Ausgabevariablen mit "OUTPUT_x" gekennzeichnet, wobei der Index 'x' eine fortlaufende Nummer darstellt, beginnend mit "INPUT_0" und "OUTPUT_0" für die niederwertigste Eingabe- und Ausgabevariable. Die fortlaufenden Zahlen müssen lückenlos sein und jede Variable muss im ANSI-C-Code tatsächlich verwendet werden.<newline /><newline />
      Die Variablen müssen abhängig vom Angriffs-Modus nach dem folgenden Schema zugewiesen werden:<newline /><newline />
      <b>First-Preimage- und Second-Preimage-Angriff:</b>
      <list>
        <item>
          <b>INPUT_0 - INPUT_n</b> Nachricht (Urbild)
        </item>
        <item>
          <b>OUTPUT_0 - OUTPUT_k</b> Hashwert
        </item>
      </list>

      <b>Key-Recovery-Attack:</b>
      <list>
        <item>
          <b>INPUT_0 - INPUT_n</b> Klartext
        </item>
        <item>
          <b>INPUT_n+1 - INPUT_m</b> Schlüssel
        </item>
        <item>
          <b>OUTPUT_0 - OUTPUT_k</b> Geheimtext
        </item>
      </list>
      Bei einem Key-Recovery-Angriff ist es wichtig, dass der Index der niederwertigsten Variable des Schlüssels direkt nach dem Index der höchstwertigsten Variable des Klartextes beginnt (wenn die höchstwertigste Variable des Klartextes "INPUT_63" ist, muss die niederwertigste Variable des Schlüssel "INPUT_64" sein). Wenn die Variablenbelegungen fehlerhaft sind, kann es sein, dass die Komponente falsche Lösungen ausgibt oder zu einem Fehler führt. Weiterhin ist es wichtig, dass keine der Eingabevariablen im ANSI-C-Code zugewiesen wird, und dass jede Ausgabevariablen zugewiesen sind. Das heißt, dass die Eingabevariablen immer auf der rechten Seite einer Zuweisung stehen müssen, und die Ausgabevariablen immer auf der linken Seite (z.B. OUTPUT_0 = INPUT_0 ^ INPUT_1).
    </section>
  </usage>

  <presentation lang="en">
  </presentation>

  <presentation lang="de-DE">
  </presentation>

  <references>
    <linkReference id ="xl0">
      <link url="http://www.cryptosystem.net/aes/tools.html" lang="en" />
      <caption lang="en">Tools for Experimental Algebraic Cryptanalysis</caption>
      <link url="http://www.cryptosystem.net/aes/tools.html" lang="de-DE" />
      <caption lang="de-DE">Tools für experimentelle algebraische Kryptoanalyse</caption>
    </linkReference>
  </references>
</documentation>
