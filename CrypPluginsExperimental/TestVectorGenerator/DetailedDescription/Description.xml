<?xml version="1.0" encoding="utf-8" ?>

<documentation>
  <language culture="en"/>
  <language culture="de-DE"/>

  <introduction lang="en">
    This component is designed to generate test vectors in the form of plaintexts and keys for all classical cryptanalytic components in CrypTool 2 (as of July 2017). The first use case is generating pure test vectors (pure in this context means only test vectors are generated and no analysis is done) by using the according cryptographic component to encrypt the plaintexts. The second use case is the analysis of the cryptanalytic component via detailed test series (these test series are created and evaluated by the <b>CryptAnalysisAnalyzer</b> component (<b>CAA</b>) from test vectors of the <b>TestVectorGenerator</b> (<b>TVG</b>)).

    <section headline="History">
      A general test vector generator making analytic results comparable is available in most computer science fields, but not in the field of cryptanalysis. In the paper "We Need Test Vectors!" (a proposal for the 2017th Cryptologic History Symposium of the NSA), Nils Kopal explained that standardized test vectors are important for the field of cryptanalysis in order to compare different cryptanalytic algorithms.
    </section>

    <section headline="Algorithm">
      The generation of the plaintexts and keys is based on a pseudo-random number generator that is seeded with the seed the user provides. This makes it reproducible with the same input values.
      <newline/>
      <newline/>
      The plaintext is generated in this way:
      <newline/>
      For the plaintext and the natural speech keys, the input text (usually a book in text format) is processed by some initial aspects (like removing all characters unlike letters, numbers, spaces, periods; replacing question and exclamation marks by periods first) and splitting it to complete sentences which are put into an array. The plaintext generation is basically choosing a (never occurred until now) starting sentence and appending following sentences until the specified plaintext length is reached or exceeded. Then the plaintext is cut to the specified length and given to the output connector. The plaintext length and specifics can be selected through the component settings.
      <newline/>
      <newline/>
      The natural speech keys are generated in this way:
      <newline/>
      Starting at a random starting sentence, the first step is searching a sentence of the exact specified length (that was not used as starting sentence before). If that fails, larger sentences are searched and cut to the specified length. All modifications according to the settings are done to the key at this point (like replacing numbers or umlauts). For Example:
      <newline/>
      "ThisIsAKey123ü" is modified to this:
      <newline/>
      "ThisIsAKeyONETWOTHREEue" (if replacing umlauts is active and numbers should be replaces by written English numbers.)
      <newline/>
      <newline/>
      The random keys are generated like this:
      <newline/>
      First, the alphabet from which the key symbols are taken is prepared as a list of strings (this alphabet can be chosen through the drop-down menu or the alphabet input). The next step is taking a random element from the list repeatedly until the specified key length is reached. If the unique symbol usage setting is enabled, the element is directly removed from the list and not used twice.
      <newline/>
      <newline/>
      The reverse regex keys are generated like this:
      <newline/>
      A regular expression is a pattern that defines rules for a set of strings. All strings that follow these rules match the pattern. The regex input takes a regex pattern from the user and the reverse regex generator builds a random string matching this pattern (using the pseudo-random number generator, seeded with the input seed). Additional functionalities are the special $length and $unique variables. The $length variable is replaced through the current calculated length that the key has to have. The $unique variable is parsed, a random key is generated using the parsed parameters, and the $unique variable is replaced by that key. After both replacements, the reverse regex generation is continued as usual (see usage for more details).
    </section>
  </introduction>

  <introduction lang="de-DE">
    Diese Komponente generiert Testvektoren (bestehend aus Klartexten und Schlüsseln) für alle klassischen kryptoanalytischen Komponenten in CrypTool 2 (Stand Juli 2017). Der erste Anwendungsfall ist die Generierung purer Testvektoren (pur in diesem Kontext bedeutet, dass nur Testvektoren generiert werden, aber keine Analyse stattfindet) durch Verschlüsselung der Klartexte mit der entsprechenden kryptographischen Verschlüsselungs-Komponente. Der zweite Anwendungsfall beinhaltet ausführliche Testserien zur Analyse von kryptoanalytischen Komponenten (diese Testserien werden von der <b>CryptAnalysisAnalyzer</b>-Komponente (<b>CAA</b>) aus den vom <b>TestVectorGenerator</b> (<b>TVG</b>) generierten Testvektoren erzeugt und evaluiert). 

    <section headline="Geschichte">
      In den meisten Bereichen der Informatik gibt es standardisierte Testvektoren, um Testergebnisse vergleichbar zu machen. Für den Bereich der Kryptoanalyse ist das bisher nicht der Fall. In dem Beitrag "We Need Test Vectors!" (vorgestellt auf dem "Symposium on Cryptologic History" der NSA in 2017), erklärt Nils Kopal, dass standardisierte Testvektoren im Bereich der Kryptoanalyse wichtig sind, um verschiedene kryptoanalytische Algorithmen miteinander zu vergleichen.
    </section>

    <section headline="Algorithmus">
      Die Klartexte und Schlüssel werden mit Hilfe eines Pseudo-Zufallszahlengenerators erzeugt, der einen durch den vom Benutzer bereitgestellten Samenwert (Seed) nutzt. Durch identische Eingabewerte kann die Generierung jederzeit reproduziert werden.
      <newline/>
      <newline/>
      Der Klartext wird wie folgt generiert:
      <newline/>
      Für den Klartext und die Natürliche-Sprache-Schlüssel wird der Eingabetext (normalerweise ein Buch in Textformat) anhand einiger initialer Aspekte verarbeitet (wie das Entfernen alle Zeichen, die keine Buchstaben, Zahlen, Leerzeichen oder Punkte sind, und der Ersetzung aller Frage- und Ausrufezeichen durch Punkte) und die Aufteilung nach vollständigen Sätzen, die dann in einem Array gespeichert werden. Die Generierung eines Klartexts besteht grundsätzlich aus einem (neuen) Startsatz und dem Anhängen der darauf folgenden Sätze bis die eingestellte Klartext-Länge erreicht oder überschritten wurde. Dann wird der Klartext auf die eingestellte Länge gekürzt und an den Ausgabekonnektor weiter gegeben. Die Klartext-Länge und Einzelheiten können durch die Komponenten-Einstellungen ausgewählt werden.
      <newline/>
      <newline/>
      Die Natürliche-Sprache-Schlüssel werden folgendermaßen generiert:
      <newline/>
      Beginnend mit einem zufälligen Startsatz wird im ersten Schritt nach einem Satz gesucht mit exakt der vorgegebenen Länge (der bisher noch nicht als Startsatz verwendet wurde). Wenn die Suche fehl schlägt, werden längere Sätze gesucht und an der eingestellten Länge abgeschnitten. Alle Modifikationen des Schlüssels, die in den Einstellungen festgelegt wurden, werden an dieser Stelle vorgenommen (wie die Ersetzung vom Zahlen und Umlauten). Beispiel:
      <newline/>
      "DiesIstEinSchlüssel123" wird zu:
      <newline/>
      "DiesIstEinSchluesselEINSZWEIDREI" (wenn das Ersetzen von Umlauten aktiviert und Zahlen durch ausgeschriebene deutsche Zahlen ersetzt werden sollen)
      <newline/>
      <newline/>
      Die einfachen zufälligen Schlüssel werden wie folgt generiert:
      <newline/>
      Als erstes wird das Alphabet, von dem die Schlüssel-Symbole ausgewählt werden, als eine liste von Zeichenketten vorbereitet (dieses Alphabet kann durch das Drop-Down-Menü oder das Eingabe-Alphabet festgelegt werden). Im nächsten Schritt wird wiederholt ein zufälliges Element aus der Liste ausgewählt bis die festgelegte Schlüssel-Länge erreicht wurde. Wenn die Option aktiviert ist, dass jedes Symbol nur einmal pro Schlüssel verwendet werden darf, wird das aktuelle Symbol direkt von der Liste entfernt und nicht mehrfach verwendet.
      <newline/>
      <newline/>
      Die Revers-Regex-Schlüssel werden folgendermaßen generiert:
      <newline/>
      Ein regulärer Ausdruck ist ein Muster, das Regeln für eine Menge von Zeichenketten festlegt. Alle Zeichenketten, die diese Regeln befolgen, passen zu diesem Muster. Normalerweise nutzt man reguläre Ausdrücke, um gegebene Texte zu filtern. Hier ist es umgekehrt: Die Eingabe-Verbindung für reguläre Ausdrücke empfängt das Muster vom Nutzer und der Revers-Regex-Generator baut daraus eine zufällige Zeichenkette, die diesem Muster entspricht (dabei verwendet er den Pseudo-Zufallszahlengenerator, initialisiert mit dem eingegebenen Samen). Zusätzliche Funktionen stellen die speziellen Variablen $length und $unique dar. Die $length-Variable wird durch die aktuell berechnete Länge des Schlüssels ersetzt. Die $unique-Variable wird analysiert, ein zufälliger Schlüssel wird nach den gefundenen Parametern generiert, und die $unique-Variable wird durch diesen Schlüssel ersetzt. Nach diesen Ersetzungen läuft die Revers-Regex-Generierung weiter wie normal (weitere Details finden Sie weiter unten).
    </section>
  </introduction>

  <usage lang="en">
    The <b>TVG</b> has two mandatory input connectors: text and seed. The optional inputs are the regex pattern and the alphabet.
    <newline/>
    <newline/>
    <b>Text input:</b>
    <newline/>
    The text to input should be a large text in natural Language (like a children's book).
    <newline/>
    <newline/>
    <b>Seed input:</b>
    <newline/>
    The seed can be any string. Together with the settings, text and seed are necessary to reproduce the generated test vectors. In order to get a new test vector, the seed has to be updated, by setting it to one of the directly previous test values (the second test vector has to be based on the first one to make the generation reproducible; the easiest way is to use the current key as the next seed).
    <newline/>
    <newline/>
    <b>Regex input:</b>
    <newline/>
    The regex input accepts most regex patterns (the complete list can be found in the Xeger wiki, linked in the references). A basic example would be "[ab]{4,6}" which generates strings consisting of a's and b's of the lengths 4 to 6 (like "aaaa", "ababab", "bbabb"). A more complex example is the generation of Enigma keys:
    <newline/>
    "$unique([I|II|III|IV|V|VI|VII|VIII]{3}) / $unique([1-26]{3}) / $unique([A-Z](2){26})"
    <newline/>
    The first $unique variable is replaced by a string of three symbols taken from the given alphabet, separated by the separator symbol specified in the components settings (like "IV, I, III"). The slash and its surrounding spaces are taken as they are, as they are not part of a pattern to generate (between brackets). The second $unique variable generates 3 numbers from 1 to 26 (like "2, 26, 15"). The last $unique specifies the frequency of the separator (", " in this case) to be 2 (instead of the default of 1) inside the round brackets. A frequency of 2 means that the separator symbol is inserted after each two characters. The curly brackets always define the length, while the square brackets define the alphabet. So the last part generates strings of 26 letters from A to Z, separated in groups of 2 (like "AG, IW, KC, RQ, ..."). All alphabet symbols are only used once, that's the main aspect of the $unique variable.
    <newline/>
    <newline/>
    <b>Alphabet input:</b>
    <newline/>
    The alphabet input can be used to specify an alphabet in an abbreviated format (like "A-Z0-9") or a complete alphabet, separated by space or pipe ("|"), which allows multiple characters as one alphabet symbol ("A C E F 8 12"). If all symbols have a length of 1, they can also be written without separators and will be split between them ("ABCDEF").
    <newline/>
    <newline/>
    <newline/>
    <b>Settings:</b>
    <newline/>
    The more complex part of the <b>TVG</b> are its settings. The most important settings are explained below:
    <newline/>
    <newline/>
    <b>Number of test runs:</b>
    <newline/>
    The setting for the number of test runs defines the overall test runs for the test series, divided into the different plaintext lengths and key lengths (if specified).
    <newline/>
    <newline/>
    <b>Show extended settings:</b>
    <newline/>
    To gain full control over all available settings, the extended settings have to be enabled though this setting.
    <newline/>
    <newline/>
    <b>Other general settings:</b>
    <newline/>
    The other general settings modify the text and natural speech keys through operations like making all letters uppercase, deleting all spaces, or replacing certain symbols.
    <newline/>
    <newline/>
    <b>Text length settings:</b>
    <newline/>
    The text length may be defined through the minimum and maximum length and the lengthening steps.
    <newline/>
    <newline/>
    <b>Dot replacing settings:</b>
    <newline/>
    The dot symbols may be ignored, removed, or replaced by another symbol. Once the replacing option is selected, an input field for the new symbol is shown.
    <newline/>
    <newline/>
    <b>Key generation type setting:</b>
    <newline/>
    There are three key generation types available: Natural speech keys, random keys, and reverse regex keys. The natural speech key generation takes sentences from the provided input text. The random keys are generated using the provided input alphabet or a simple one from the drop-down menu. For the reverse regex key generation, a regex pattern has to be provided through the regex input. More detailed information can be found above in the regex input section of this description.
    <newline/>
    <newline/>
    <b>Minimum and Maximum key length settings:</b>
    <newline/>
    These values specify the range of key lengths which will be generated.
    <newline/>
    <newline/>
    <b>Key symbol separator setting:</b>
    <newline/>
    The key symbols may be separated by an arbitrary string, specified in this input field.
    <newline/>
    <newline/>
    <b>Key format setting:</b>
    <newline/>
    The key format setting is available for natural speech and random keys. Natural speech keys can either consist of letters (and other symbols in the text, if not replaced or deleted) or be transformed to numbers. The numeric key can be chosen to be a unique numeric key, using each consecutive number only once, by enabling the unique setting.
    The random keys can consist of letters, numbers, binary numbers, or the input alphabet characters. All of those options can be combined with the unique setting, so that each alphabet character is only used once in the key.
    <newline/>
    The following image displays a pure test vector generation scenario. The input text is the book "Alice in Wonderland", the seed is "SEED", and the regex pattern consists of two $unique variables, which generate 25 numbers from 0 to 24 each, separated by a slash. The <b>TVG</b> has every replacement setting enabled. Before the encryption, the plaintext is split into blocks of five (so 5 blocks are encrypted in one go through the Cylinder Cipher). The Cylinder Cipher mode is encryption, using the M-94 disks. The last combination of string operations and other components calculates the offset part of the Cylinder Cipher key. This is specific for this cipher and not necessary otherwise. The gate at the bottom left is set to true and triggers the next key (if the number of test runs is set higher than 1). The string outputs on the bottom display the key, the plaintext, the ciphertext, and the offset of the key.

      <img src="TestVectorGenerator\DetailedDescription\Images\cylinderpurevectortemplate.png"/>

    This <b>TVG</b> component was developed as part of a master thesis which contains more details about it:

    "Development of an Evaluation Method for Cryptanalysis of Classical Ciphers in CrypTool 2"
    Bastian Heuser, University of Kassel -- 2017 -- Master thesis    
  </usage>

  <usage lang="de-DE">
    Der <b>TVG</b> hat zwei notwendige Eingangsverbindungen: Text und Samenwert (Seed). Die optionalen Eingänge sind das reguläre Ausdrucks-Muster und das Alphabet.
    <newline/>
    <newline/>
    <b>Text-Eingabe:</b>
    <newline/>
    Der Eingabetext sollte ein umfangreicher Text in natürlicher Sprache sein (bspw. ein Kinderbuch).
    <newline/>
    <newline/>
    <b>Samen-Eingabe:</b>
    <newline/>
    Der Samen (Seed) kann eine beliebige Zeichenkette sein. Gemeinsam mit den Einstellungen sind Text und Samen notwendig, um die generierten Testvektoren zu reproduzieren. Um einen neuen Testvektor zu erhalten, muss der Samen aktualisiert werden, indem er auf einen der letzten generierten Testwerte gesetzt wird (der zweite Testvektor muss auf dem ersten basieren, um die Generierung reproduzierbar zu machen; der einfachste Weg ist, den aktuell generierten Schlüssel als nächsten Samen zu verwenden).
    <newline/>
    <newline/>
    <b>Regex-Eingabe:</b>
    <newline/>
    Die Regex-Eingabe (oder auch reguläre Ausdrucks-Eingabe) akzeptiert die meisten regulären Ausdrucks-Muster (die komplette Liste ist im Xeger-Wiki zu finden, das in den Referenzen verlinkt ist). Ein einfaches Beispiel wäre "[ab]{4,6}", welches Zeichenketten generiert, die aus a's und b's der Länge 4 bis 6 bestehen (wie "aaaa", "ababab", "bbabb"). Ein kompliziertes Beispiel ist die Generierung von Enigma-Schlüsseln:
    <newline/>
    "$unique([I|II|III|IV|V|VI|VII|VIII]{3}) / $unique([1-26]{3}) / $unique([A-Z](2){26})"
    <newline/>
    Die erste $unique-Variable wird durch eine Zeichenkette von drei Symbolen aus dem gegebenen Alphabet ersetzt, separiert durch das Trennsymbol, welches in den Einstellungen der Komponente festgelegt wurde (wie "IV, I, III"). Der Schrägstrich und die umgebenden Leerzeichen werden belassen wie sie sind, weil sie nicht Teil eines zu generierenden Musters sind (zwischen den Klammern). Die zweite $unique-Variable generiert drei Zahlen von 1 bis 26 (wie "2, 26, 15"). Das letzte $unique spezifiziert auch die Frequenz des Trennsymbols (", " in diesem Fall) als 2 (anders als der Standard 1, der in den anderen beiden $unique-Variablen automatisch verwendet wird) in den runden Klammern. Eine Frequenz von 2 bedeutet, dass das Trennsymbol jeweils alle 2 Zeichen eingefügt wird. Folglich generiert der letzte Teil Zeichenketten von 26 Buchstaben von A bis Z, separiert in Zweiergruppen (wie "AG, IW, KC, RQ, ..."). Alle Alphabetsymbole werden nur einmal verwendet, was genau der hauptsächliche Zweck der $unique-Variable ist.
    <newline/>
    <newline/>
    <b>Alphabet-Eingabe:</b>
    <newline/>
    Mit der Alphabet-Eingabe können Sie ein Alphabet in einem abgekürzten Format angeben (wie "A-Z0-9") oder ein vollständiges Alphabet, separiert durch Leerzeichen oder Pipe-Symbole, wodurch auch mehrere Zeichen ein Alphabet-Symbol darstellen dürfen ("A C E F 8 12"). Wenn alle Symbole die Länge 1 besitzen, können die Trennsymbole auch weggelassen werden ("ABCDEF").
    <newline/>
    <newline/>
    <newline/>
    <b>Einstellungen:</b>
    <newline/>
    Der komplexere Teil des <b>TVG</b> sind seine Einstellungen. Die wichtigsten sind im Folgenden erklärt:
    <newline/>
    <newline/>
    <b>Anzahl an Testläufen:</b>
    <newline/>
    Diese Einstellung definiert die Gesamtanzahl der Testläufe in einer Testserie, aufgeteilt in die verschiedenen Klartext- und Schlüssellängen (wenn definiert).
    <newline/>
    <newline/>
    <b>Zeige erweiterte Einstellungen:</b>
    <newline/>
    Um volle Kontrolle über alle verfügbaren Einstellungen zu bekommen, müssen die erweiterten Einstellungen durch diese Einstellung aktiviert werden.
    <newline/>
    <newline/>
    <b>Andere allgemeine Einstellungen:</b>
    <newline/>
    Die anderen allgemeinen Einstellungen modifizieren den Text und die Natürliche-Sprache-Schlüssel durch Operationen wie Konvertierung zu Großbuchstaben, Löschen aller Leerzeichen oder Ersetzung bestimmter Symbole.
    <newline/>
    <newline/>
    <b>Textlängen-Einstellungen:</b>
    <newline/>
    Die Textlänge kann definiert werden durch die minimale und maximale Länge und die Verlängerungsschritte zwischen den verschiedenen Längen.
    <newline/>
    <newline/>
    <b>Punkt-Ersetzungs-Einstellung:</b>
    <newline/>
    Punkte können ignoriert, entfernt oder durch ein anderes Symbol ersetzt werden. Wird die Ersetzungs-Option gewählt, wird ein Eingabefeld für das neue Symbol angezeigt.
    <newline/>
    <newline/>
    <b>Schlüsseltyp:</b>
    <newline/>
    Es gibt drei verfügbare Schlüsseltypen: Natürliche-Sprachen-Schlüssel, zufällige Schlüssel und Revers-Regex-Schlüssel. Die Generierung Natürlicher-Sprachen-Schlüssel verwendet Sätze des gegebenen Eingabetextes. Die zufälligen Schlüssel werden aus dem gegebenen Eingabealphabet generiert, oder entsprechend der gewählten Kategorie im Drop-Down-Menü. Für die Generierung der Revers-Regex-Schlüssel muss ein regulärer Ausdruck in Form eines Musters durch die Regex-Eingabe bereitgestellt werden. Detailliertere Informationen finden Sie weiter oben bei der Regex-Eingabe.
    <newline/>
    <newline/>
    <b>Minimale und maximale Schlüssellänge:</b>
    <newline/>
    Diese Werte geben den Bereich der Schlüssellänge an, in dem die generierten Schlüssel liegen sollen.
    <newline/>
    <newline/>
    <b>Schlüsselsymbol-Trenner:</b>
    <newline/>
    Die Schlüsselsymbole können durch eine beliebige Zeichenkette getrennt werden, die in diesem Eingabefeld festgelegt wird.
    <newline/>
    <newline/>
    <b>Schlüsselformat:</b>
    <newline/>
    Die Einstellung Schlüsselformat ist verfügbar für Natürliche-Sprache-Schlüssel und zufällige Schlüssel. Natürliche-Sprache-Schlüssel können entweder aus Buchstaben bestehen (und anderen Symbolen des Eingabetextes, wenn nicht ersetzt oder gelöscht) oder zu Zahlen transformiert werden. Der Schlüssel aus Zahlen kann jede Zahl entweder einmal verwenden (wenn die "Einmalig"-Option gewählt wurde) oder mehrfach. Der zufällige Schlüssel kann Buchstaben, Zahlen, binäre Zahlen oder Symbole des Eingabealphabets beinhalten. All diese Möglichkeiten können auch mit der "Einmalig"-Option kombiniert werden, sodass jedes Symbol höchstens einmal im Schlüssel beinhaltet sein darf.
    <newline/>
    Das folgende Bild zeigt das Szenario der Generierung purer Testvektoren. Der Eingabetext ist das Buch "Alice in Wonderland", der eingegebene Samen ist "SEED", und das Regex-Muster besteht aus zwei $unique-Variablen, die jeweils 25 Zahlen von 0 bis 24 generieren, getrennt durch einen Schrägstrich. Alle Einstellungen zu Ersetzungen im Text sind im <b>TVG</b> aktiviert. Vor der Verschlüsselung wird der Klartext in Blöcke von je fünf Zeichen geteilt (also werden fünf Blöcke in einem Durchgang von der Zylinder-Chiffre verschlüsselt). Der Modus der Zylinder-Chiffre ist Verschlüsselung mit den M-94-Scheiben. Die letzte Kombination von Zeichenketten-Operationen und anderen Komponenten berechnet den Offset-Teil des Schlüssels. Diese Berechnung ist spezifisch für diese Chiffre und woanders nicht nötig. Das Tor (Gate) unten links steht auf wahr und stößt den nächsten Schlüssel an (wenn die Anzahl an Testläufen größer ist als 1). Die Zeichenausgaben unten zeigen den Schlüssel, Klartext, Geheimtext und das Offset des Schlüssels an.

      <img src="TestVectorGenerator\DetailedDescription\Images\cylinderpurevectortemplate.png"/>

    Diese <b>TVG</b>-Komponente wurde im Rahmen einer Masterarbeit entwickelt. Die Masterarbeit enthält weitere Details hierzu:

    "Development of an Evaluation Method for Cryptanalysis of Classical Ciphers in CrypTool 2"
    Bastian Heuser, Universität Kassel -- 2017 -- Masterarbeit    
  </usage>

  <presentation lang="en">
  </presentation>
  <presentation lang="de-DE">
  </presentation>

  <references>
    <linkReference>
      <link url="https://code.google.com/archive/p/xeger/wikis/XegerLimitations.wiki" lang="en" />
      <caption lang="en">Xeger Limitations</caption>
      <link url="https://code.google.com/archive/p/xeger/wikis/XegerLimitations.wiki" lang="de-DE" />
      <caption lang="de-DE">Xeger Limitationen (Englisch)</caption>
    </linkReference>
  </references>

</documentation>
