<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CapacityCaption" xml:space="preserve">
    <value>Capacity</value>
  </data>
  <data name="CapacityTooltip" xml:space="preserve">
    <value>Größe der Capacity in Bit</value>
  </data>
  <data name="DebugDataStreamTooltip" xml:space="preserve">
    <value>Ausgabestrom für Debuginformation</value>
  </data>
  <data name="DebugStreamCaption" xml:space="preserve">
    <value>Debugausgabestrom</value>
  </data>
  <data name="InputDataStreamTooltip" xml:space="preserve">
    <value>Eingabedaten, deren Hashwert berechnet wird</value>
  </data>
  <data name="InputStreamCaption" xml:space="preserve">
    <value>Eingabedatenstrom</value>
  </data>
  <data name="KECCAKFunctionCaption" xml:space="preserve">
    <value>Keccak Funktion</value>
  </data>
  <data name="KeccakFunctionList1" xml:space="preserve">
    <value>Keccak</value>
  </data>
  <data name="KeccakFunctionList2" xml:space="preserve">
    <value>SHA3-224</value>
  </data>
  <data name="KeccakFunctionList3" xml:space="preserve">
    <value>SHA3-256</value>
  </data>
  <data name="KeccakFunctionList4" xml:space="preserve">
    <value>SHA3-384</value>
  </data>
  <data name="KeccakFunctionList5" xml:space="preserve">
    <value>SHA3-512</value>
  </data>
  <data name="KECCAKFunctionTooltip" xml:space="preserve">
    <value>Auswahl der Keccak Variante</value>
  </data>
  <data name="ManualSettingsCaption" xml:space="preserve">
    <value>Manuell einstellen</value>
  </data>
  <data name="ManualSettingsTooltip" xml:space="preserve">
    <value>Keccak-Parameter manuell festlegen</value>
  </data>
  <data name="OutputDataStreamTooltip" xml:space="preserve">
    <value>Hashwert</value>
  </data>
  <data name="OutputLengthCaption" xml:space="preserve">
    <value>Ausgabelänge</value>
  </data>
  <data name="OutputLengthTooltip" xml:space="preserve">
    <value>Ausgabelänge in Bit (muss durch 8 teilbar sein)</value>
  </data>
  <data name="OutputStreamCaption" xml:space="preserve">
    <value>Hashwert</value>
  </data>
  <data name="ParametersCaption" xml:space="preserve">
    <value>Parameter</value>
  </data>
  <data name="PluginCaption" xml:space="preserve">
    <value>Keccak</value>
  </data>
  <data name="PluginDescription" xml:space="preserve">
    <value>Keccak Hash Funktion</value>
  </data>
  <data name="RateCaption" xml:space="preserve">
    <value>Bit Rate</value>
  </data>
  <data name="SelectedStateSizeCaption" xml:space="preserve">
    <value>State Größe</value>
  </data>
  <data name="SelectedStateSizeTooltip" xml:space="preserve">
    <value>Größe des States in Bit (muss mit der Summe von Bitrate und Kapazität übereinstimmen)</value>
  </data>
  <data name="StateSize0" xml:space="preserve">
    <value>25 Bit</value>
  </data>
  <data name="StateSize1" xml:space="preserve">
    <value>50 Bit</value>
  </data>
  <data name="StateSize2" xml:space="preserve">
    <value>100 Bit</value>
  </data>
  <data name="StateSize3" xml:space="preserve">
    <value>200 Bit</value>
  </data>
  <data name="StateSize4" xml:space="preserve">
    <value>400 Bit</value>
  </data>
  <data name="StateSize5" xml:space="preserve">
    <value>800 Bit</value>
  </data>
  <data name="StateSize6" xml:space="preserve">
    <value>1600 Bit</value>
  </data>
  <data name="OutputMatchError" xml:space="preserve">
    <value>Ausgabelänge muss durch 8 teilbar sein.</value>
  </data>
  <data name="OutputTooLongWarning" xml:space="preserve">
    <value>Die Ausgabe ist zu lang. Sie wird auf 174.760 Bit gekürzt.</value>
  </data>
  <data name="RateTooltip" xml:space="preserve">
    <value>Größe der Bit Rate in Bit (muss durch 8 teilbar sein)</value>
  </data>
  <data name="StateSizeMatchError" xml:space="preserve">
    <value>Die Summe von Bit Rate und Capacity muss mit der Größe des State übereinstimmen.</value>
  </data>
  <data name="PresentationCaption" xml:space="preserve">
    <value>Präsentation einschalten</value>
  </data>
  <data name="PresentationGroupCaption" xml:space="preserve">
    <value>Präsentation</value>
  </data>
  <data name="PresentationTooltip" xml:space="preserve">
    <value>Auswählen, ob die Präsentation angezeigt werden soll.</value>
  </data>
  <data name="PresInitialization" xml:space="preserve">
    <value>Initialisierung</value>
  </data>
  <data name="PresIntroduction" xml:space="preserve">
    <value>Einführung</value>
  </data>
  <data name="PresAbsorbingPhase" xml:space="preserve">
    <value>Absorbing Phase</value>
  </data>
  <data name="PresAbsorbingPhaseExplanation" xml:space="preserve">
    <value>Eingabeblock #{0} wird durch eine XOR Operation von dem r-Bit Anteil des States 'aufgesaugt'. Bei genauerer Betrachtung des States kann man eindeutig sehen, dass der Capacity Anteil (unterer Teil des States) nicht verändert wurde.</value>
  </data>
  <data name="PresAbsorbingPhaseText" xml:space="preserve">
    <value>Jeder Block p der gepaddeten Eingabedaten wird durch eine XOR Operation von dem Sponge-State aufgesaugt. Die Eingabeblöcke betreffen die {0} Bits des r-bit Anteils. Der c-bit Anteil wird nicht beeinflusst. Nach dem Aufsaugen wird die Keccak-f Permutation ausgeführt um die State-Bits zu vermischen.</value>
  </data>
  <data name="PresChiPhaseText" xml:space="preserve">
    <value>Chi iteriert über jede Zeile des States.</value>
  </data>
  <data name="PresChiStepText" xml:space="preserve">
    <value>Jedes Bit einer Zeile wird XOR-verknüpft mit der Konjunktion der beiden Bits zur Rechten des betrachteten Bits. Das erste von den beiden Bits wird vor der Konjunktion invertiert.</value>
  </data>
  <data name="PresExecution" xml:space="preserve">
    <value>Ausführung</value>
  </data>
  <data name="PresExecutionInfoBitRateSize" xml:space="preserve">
    <value>Bit Rate Größe: {0} Bits</value>
  </data>
  <data name="PresExecutionInfoCapacitySize" xml:space="preserve">
    <value>Capacity Größe: {0} Bits</value>
  </data>
  <data name="PresExecutionInfoStateSize" xml:space="preserve">
    <value>State Größe: {0} Bits</value>
  </data>
  <data name="PresExecutionMessageLength" xml:space="preserve">
    <value>Eingabelänge: {0} Bits = {1} Bytes</value>
  </data>
  <data name="PresExecutionNumberOfBlocks" xml:space="preserve">
    <value>Anzahl Eingabeblöcke (Länge der gepaddeten Eingabe / Bit Rate Größe): {0}</value>
  </data>
  <data name="PresExecutionPaddedMessageLength" xml:space="preserve">
    <value>Länge der gepaddeten Eingabe: {0} Bits = {1} Bytes</value>
  </data>
  <data name="PresInitializationText" xml:space="preserve">
    <value>Der State (Zustand) der Sponge-Konstruktion wird initialisiert. Jedes der b Bits wird mit dem Wert 0 initialisiert. Der State ist in zwei Teile geteilt: Capacity -- c bits und Bit Rate -- r bits. Bei den gewählten Einstellungen sind diese Werte b = {0}, c = {1} und r = {2}.</value>
  </data>
  <data name="PresInputInformation" xml:space="preserve">
    <value>Eingabe Information</value>
  </data>
  <data name="PresIotaPhaseText" xml:space="preserve">
    <value>Iota XOR-verknüpft eine Runenkonstante mit der ersten Lane (x,y) = (1,1).</value>
  </data>
  <data name="PresIotaStepText" xml:space="preserve">
    <value>Die Rundenkonstante der aktuellen Runde ist in dem roten Rechteck angegeben, zwischen den grünen Blöcken, welche den alten und neuen Wert der Lane zeigen. Die Rundenkonstanten sind in jeder Rune unterschiedlich.</value>
  </data>
  <data name="PresKeccakFIterations" xml:space="preserve">
    <value>{0} Wiederholungen</value>
  </data>
  <data name="PresKeccakFPhase" xml:space="preserve">
    <value>Keccak-f Permutation</value>
  </data>
  <data name="PresKeccakFPhaseText" xml:space="preserve">
    <value>Die Keccak-f Permuation besteht aus 12 + 2 * l Runden. In jeder Runde werden fünf "step mappings" ausgeführt, die den State auf unterschiedliche Weise permutieren. Bei der eingestellten State Größe entspricht l dem Wert {0} und die Gesamtanzahl an Runden ist 24.</value>
  </data>
  <data name="PresKeccakFStateMapping" xml:space="preserve">
    <value>Damit die step mappings einfacher dargestellt werden können wird der State als dreidimensionaler Würfel repräsentiert. Die Länge der Reihen und Spalten ist 5 Bit, Die Länge einer Lane hängt von der State Größe ab (bei der ausgewählten State Größe ist die Länge der Lanes {1} Bits).</value>
    <comment>für lane fällt mir keine gute Übersetzung ein... (Linie, Spur, Weg klingt alles nicht gut)</comment>
  </data>
  <data name="PresOverview" xml:space="preserve">
    <value>Übersicht</value>
  </data>
  <data name="PresPiPhaseText" xml:space="preserve">
    <value>Pi permutiert die Anordnung der Lanes innerhalb des States. Die Koordinaten sind verschoben zwecks besserer Visualisierung.</value>
  </data>
  <data name="PresPiStepText" xml:space="preserve">
    <value>Jede Lane, ausser die Lane an Position (x,y) = (1,1), dargestellt in schwarz, wird an eine andere Stelle geschoben. Der Rechte Würfel zeigt die neuen Positionen der Lanes. Bereits verschobene Lanes werden grau dargestellt.</value>
  </data>
  <data name="PresRhoPhaseText" xml:space="preserve">
    <value>Rho iteriert über jede Lane des States.</value>
  </data>
  <data name="PresRhoStepText" xml:space="preserve">
    <value>Jede Lane wird um einen bestimmten Wert (rot markiert) nach rechts rotiert. Der obere grüne Block stellt die Lane vor der Rotation dar, der untere grüne Block nach der Rotation.</value>
  </data>
  <data name="PresRoundOfRounds" xml:space="preserve">
    <value>Runde {0}/{1}</value>
  </data>
  <data name="PresSpongeConstructionParameter" xml:space="preserve">
    <value>Parameter der Sponge Konstruktion</value>
  </data>
  <data name="PresSqueezingPhase" xml:space="preserve">
    <value>Squeezing Phase</value>
  </data>
  <data name="PresSqueezingPhaseExplanation" xml:space="preserve">
    <value>Der {0}-bit Hashwert wird aus dem Bit Rate Anteil (oberer Teil des States) extrahiert.</value>
  </data>
  <data name="PresSqueezingPhaseText" xml:space="preserve">
    <value>Der Hashwert wird aus dem r-bit Anteil des States extrahiert (z). Sofern die angeforderte Ausgabelänge größer ist als r, wird der State immer wieder permutiert bis genug Ausgabe vorhanden ist.</value>
  </data>
  <data name="PresThetaPhaseText" xml:space="preserve">
    <value>Theta iteriert über jede Spalte des States.</value>
  </data>
  <data name="PresThetaStepText" xml:space="preserve">
    <value>Die Paritäten zweier benachbarter Spalten (türkis und hellgrün) werden XOR-verknüpft. Das Ergebnis wird XOR-verknüpft mit jedem Bit der betrachteten Spalte (grün).</value>
  </data>
</root>