<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="btnAll" xml:space="preserve">
    <value>Decrypt completely</value>
  </data>
  <data name="btnAuto" xml:space="preserve">
    <value>Auto search</value>
  </data>
  <data name="btnLblP1" xml:space="preserve">
    <value>Change Byte</value>
  </data>
  <data name="btnLblP1End" xml:space="preserve">
    <value>Go to Phase 2</value>
  </data>
  <data name="btnLblP1Init" xml:space="preserve">
    <value>Send Request</value>
  </data>
  <data name="btnLblP2" xml:space="preserve">
    <value>Next byte</value>
  </data>
  <data name="btnLblP2End" xml:space="preserve">
    <value>Go to Phase 3</value>
  </data>
  <data name="btnLblP2Init" xml:space="preserve">
    <value>Start Search</value>
  </data>
  <data name="btnLblP3Decrypt" xml:space="preserve">
    <value>Decrypt Byte</value>
  </data>
  <data name="btnLblP3End" xml:space="preserve">
    <value>Recover Plaintext</value>
  </data>
  <data name="btnLblP3Find" xml:space="preserve">
    <value>Change Current Byte</value>
  </data>
  <data name="btnLblP3IncPad" xml:space="preserve">
    <value>Increase Padding</value>
  </data>
  <data name="btnNext" xml:space="preserve">
    <value>Next</value>
  </data>
  <data name="descDone" xml:space="preserve">
    <value>Plaintext Recovered. Attack completed successfully.</value>
  </data>
  <data name="descFinishAll" xml:space="preserve">
    <value>Please wait while the message is being decrypted.</value>
  </data>
  <data name="descP1Done" xml:space="preserve">
    <value>Phase 1 finished! Valid padding found.</value>
  </data>
  <data name="descP1Init" xml:space="preserve">
    <value>Phase 1: Find a message that decrypts to a valid padding. Send the unchanged message to see if a valid padding already exists.</value>
  </data>
  <data name="descP1Task" xml:space="preserve">
    <value>Task: Change the last byte until the padding is valid.</value>
  </data>
  <data name="descP2Done" xml:space="preserve">
    <value>Phase 2 finished! First padding byte found! Padding length:</value>
  </data>
  <data name="descP2DoneSpecial" xml:space="preserve">
    <value>Phase 2 finished! The first 7 bytes did not affect the padding, so the padding length must be 1!</value>
  </data>
  <data name="descP2Init" xml:space="preserve">
    <value>Phase 2: Find first padding byte. Change the bytes from left to right. If the padding turns invalid, a padding byte must have been changed.</value>
  </data>
  <data name="descP2Task" xml:space="preserve">
    <value>The changed byte does not belong to the padding. Try the next byte!</value>
  </data>
  <data name="descP3Dec" xml:space="preserve">
    <value>Byte Decrypted! Increase the padding to continue the decryption.</value>
  </data>
  <data name="descP3DecDone" xml:space="preserve">
    <value>The byte was decrypted. Increase the padding to continue the decryption.</value>
  </data>
  <data name="descP3DecPadDone" xml:space="preserve">
    <value>All Padding Bytes Decrypted. Increase the padding to continue the decryption.</value>
  </data>
  <data name="descP3Done" xml:space="preserve">
    <value>Message was decrypted! Click to see the original plaintext.</value>
  </data>
  <data name="descP3FindDone" xml:space="preserve">
    <value>Valid padding found! Byte can be decrypted.</value>
  </data>
  <data name="descP3FindTask" xml:space="preserve">
    <value>Task: Change the byte until the message decrypts to the desired value! If the correct value is found, the padding will turn valid.</value>
  </data>
  <data name="descP3Init" xml:space="preserve">
    <value>Phase 3: Decrypt the message. Start with decrypting the padding bytes.</value>
  </data>
  <data name="descPadIn" xml:space="preserve">
    <value>Response from the Padding Oracle</value>
  </data>
  <data name="langCheck" xml:space="preserve">
    <value>English</value>
  </data>
  <data name="ttBtnAll" xml:space="preserve">
    <value>Automatically decrypt the complete message.</value>
  </data>
  <data name="ttBtnAuto" xml:space="preserve">
    <value>Search automatically for the next valid value.</value>
  </data>
  <data name="ttBtnNext" xml:space="preserve">
    <value>Perform the next step.</value>
  </data>
  <data name="ttBtnReturn" xml:space="preserve">
    <value>Undo the last performed action.</value>
  </data>
  <data name="ttBtnReturnPhase" xml:space="preserve">
    <value>Return to the beginning of the current phase.</value>
  </data>
  <data name="ttCipherBlock" xml:space="preserve">
    <value>The encrypted informationblock.</value>
  </data>
  <data name="ttCorruptedBlock" xml:space="preserve">
    <value>The corrupted initializationblock (original C1 XOR O).</value>
  </data>
  <data name="ttDecBlock" xml:space="preserve">
    <value>The decrypted initializationblock (is completely known at the end). XORd with the original initializationblock C1 results in the plaintext P2.</value>
  </data>
  <data name="ttOverlayBlock" xml:space="preserve">
    <value>The overlay used to modify the initializationblock.</value>
  </data>
  <data name="ttPlainBlock" xml:space="preserve">
    <value>The resulting plaintext when XORing D2 with the original initializationblock C1 and O.</value>
  </data>
  <data name="ttPrelBlock" xml:space="preserve">
    <value>The encrypted initializationblock.</value>
    <comment>Presentation Tooltip for the Preliminary Block</comment>
  </data>
  <data name="ttSentRequests" xml:space="preserve">
    <value>Amount of requests sent to the server</value>
  </data>
  <data name="ttViewByte" xml:space="preserve">
    <value>The plugin only displays 8 bytes at a time. If the block size exceeds 8 bytes, hidden bytes can be displayed by using the scrollbar.</value>
  </data>
  <data name="ttViewByteDesc" xml:space="preserve">
    <value>Currently Viewing Bytes</value>
  </data>
</root>