<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PluginCaption" xml:space="preserve">
    <value>港币基金SHA-256</value>
  </data>
  <data name="HKDFSHA256Tooltip" xml:space="preserve">
    <value>密钥派生函数HKDF SHA-256的可视化</value>
  </data>
  <data name="ConfigInfinityOutput" xml:space="preserve">
    <value>将实现定向到RFC 5869</value>
  </data>
  <data name="ConfigInfinityOutputTooltip" xml:space="preserve">
    <value>配置基于RFC5869。这意味着使用8位计数器，并且输出字节的长度限制为8192。可以在帮助中找到更多信息。</value>
  </data>
  <data name="ConfigPresCaption" xml:space="preserve">
    <value>解释HKDF SHA-256</value>
  </data>
  <data name="ConfigPresTooltip" xml:space="preserve">
    <value>激活或取消激活说明</value>
  </data>
  <data name="ConfigPrintKMToFileCaption" xml:space="preserve">
    <value>将生成的密钥材料保存到文件</value>
  </data>
  <data name="ConfigPrintKMToFileTooltip" xml:space="preserve">
    <value>定义将生成的密钥材料保存到文件中，以便可以在其他工具中使用。</value>
  </data>
  <data name="InputSaltCaption" xml:space="preserve">
    <value>盐</value>
  </data>
  <data name="InputSaltToolTip" xml:space="preserve">
    <value>盐的输入</value>
  </data>
  <data name="InputOutputLengthCaption" xml:space="preserve">
    <value>钥匙材料长度</value>
  </data>
  <data name="InputOutputLengthToolTip" xml:space="preserve">
    <value>密钥材料的长度（以字节为单位）</value>
  </data>
  <data name="InputSKMCaption" xml:space="preserve">
    <value>源密钥材料</value>
  </data>
  <data name="InputSKMToolTip" xml:space="preserve">
    <value>输入源密钥资料</value>
  </data>
  <data name="OutputKeyMaterialCaption" xml:space="preserve">
    <value>关键材料</value>
  </data>
  <data name="OutputKeyMaterialDebugCaption" xml:space="preserve">
    <value>除错</value>
  </data>
  <data name="OutputKeyMaterialDebugToolTip" xml:space="preserve">
    <value>密钥推导的单个步骤的输出</value>
  </data>
  <data name="OutputKeyMaterialToolTip" xml:space="preserve">
    <value>输出以生成关键材料</value>
  </data>
  <data name="PresCalc" xml:space="preserve">
    <value>跳过计算</value>
  </data>
  <data name="PresIntro" xml:space="preserve">
    <value>跳过章节</value>
  </data>
  <data name="PresNext" xml:space="preserve">
    <value>下一个</value>
  </data>
  <data name="SaveFileDialogCaption" xml:space="preserve">
    <value>将关键材料保存到文件：</value>
  </data>
  <data name="SaveFileDialogTooltip" xml:space="preserve">
    <value>指定生成的密钥材料的输出文件（如果要保存到文件中）</value>
  </data>
  <data name="PresConstructionSectionHeading" xml:space="preserve">
    <value>施工</value>
  </data>
  <data name="PresConstructionSectionHeadingNum" xml:space="preserve">
    <value>2. HKDF SHA-256的建造</value>
  </data>
  <data name="PresExplanationSectionHeading" xml:space="preserve">
    <value>港币基金SHA-256</value>
  </data>
  <data name="PresIntroductionPart1Text" xml:space="preserve">
    <value>函数HKDF SHA-256是密钥派生函数（KDF）。它使用密钥哈希消息验证码（HMAC）作为伪随机函数（PRF）。作为输入，它获取SKM和密钥。在此实现中，SHA-256用于HMAC。美国国家标准与技术研究院（NIST）推荐这种关键的推导功能。</value>
  </data>
  <data name="PresIntroductionSectionHeading" xml:space="preserve">
    <value>介绍</value>
  </data>
  <data name="PresIntroductionSectionHeadingNum" xml:space="preserve">
    <value>1.简介</value>
  </data>
  <data name="PresSectionIntroductionText" xml:space="preserve">
    <value>&lt;Bold&gt;&lt;Underline&gt;输入：&lt;/Underline&gt;&lt;/Bold&gt;&lt;Bold&gt;源密钥材料：&lt;/Bold&gt;指定源密钥材料（SKM）&lt;Bold&gt;盐：&lt;/Bold&gt;指定用于计算伪随机密钥（PRK）的盐值。不必保密。&lt;Bold&gt;上下文信息：&lt;/Bold&gt;指定特定于应用程序的常量上下文信息（CTXInfo）。可以为空。&lt;Bold&gt;密钥材料的长度（以字节为单位）：&lt;/Bold&gt;指定密钥材料的长度（以字节为单位）。&lt;Bold&gt;&lt;Underline&gt;输出：&lt;/Underline&gt;&lt;/Bold&gt;&lt;Bold&gt;关键材料：&lt;/Bold&gt;计算后，结果的关键材料（KM）在文本字段中可见。&lt;Bold&gt;调试：&lt;/Bold&gt;关键材料将分多个步骤计算。每个子结果将在此文本字段中可见。</value>
  </data>
  <data name="PresTitleHeading" xml:space="preserve">
    <value>HKDF SHA-256-具有可扩展输出长度的密钥推导功能</value>
  </data>
  <data name="ExToMuchOutputRequested" xml:space="preserve">
    <value>请为请求的输出字节长度指定一个较小的值。您指定了：{0}。仅允许使用：{1}</value>
  </data>
  <data name="InputCtxInfoCaption" xml:space="preserve">
    <value>CTXInfo</value>
  </data>
  <data name="InputCtxInfoToolTip" xml:space="preserve">
    <value>输入特定于应用程序的常量CTXInfo</value>
  </data>
  <data name="KeyMaterialDebugTextTemplate" xml:space="preserve">
    <value>{0} {ord}计算回合的输出：字节1-8：{1}字节9-16：{2}字节17-24：{3}字节25-32：{4}</value>
  </data>
  <data name="PresConstructionPart1Text" xml:space="preserve">
    <value>关键材料的计算可描述如下：</value>
  </data>
  <data name="PresConstructionPart2Text" xml:space="preserve">
    <value>HKDF程序包括两个步骤。第一步，生成伪随机密钥（PRK）。它是根据SKM和可选盐计算的。</value>
  </data>
  <data name="PresConstructionPart3Text" xml:space="preserve">
    <value>在步骤2中，计算密钥材料。为此，将步骤1中的prk用作HMAC的密钥。 KM是逐步计算的。 HKDF方法为此使用反馈回路和计数器：各个预先计算的值用作后续计算的输入。计数器在每个步骤中递增。输入CTXinfo是一个特定于应用程序的常量，也可以为空。</value>
  </data>
  <data name="PresConstructionPart4Text" xml:space="preserve">
    <value>下图显示了第二步：</value>
  </data>
  <data name="PresConstructionScheme" xml:space="preserve">
    <value>步骤1：提取PRK = HMAC-SHA256（Salt，SKM）步骤2：展开KM（0）=空字符串（零长度）KM（1）= HMAC-SHA256（PRK，KM（0）||信息||点阅率）KM（2）= HMAC-SHA256（PRK，KM（1）|| info || CTR）…KM（n）= HMAC-SHA256（PRK，KM（n-1）|| info || CTR）</value>
  </data>
  <data name="PresIterationPRKCalc" xml:space="preserve">
    <value>步骤1：使用以下输入来计算PRK：SKM：{0}盐：{1}</value>
  </data>
  <data name="PresIterationRounds" xml:space="preserve">
    <value>步骤2：在{1} PRK：{2} SKM：{3} CTXInfo：{4}计数器：{5}中，从{0}开始计算</value>
  </data>
  <data name="PresKeyMaterialDebugTextTemplate" xml:space="preserve">
    <value>{0} {ord}计算回合的输出：字节1-8：{1}字节9-16：{2}字节17-24：{3}字节25-32：{4}</value>
  </data>
  <data name="PresPRKDebugTextTemplate" xml:space="preserve">
    <value>PRK的输出：字节1-8：{1}字节9-16：{2}字节17-24：{3}字节25-32：{4}</value>
  </data>
  <data name="PRKDebugTextTemplate" xml:space="preserve">
    <value>PRK的输出：字节1-8：{1}字节9-16：{2}字节17-24：{3}字节25-32：{4}</value>
  </data>
  <data name="ExSystemOutOfMemory" xml:space="preserve">
    <value>从系统请求内存时，发生了异常。请为输出字节尝试较小的值。</value>
  </data>
  <data name="PresErrorText" xml:space="preserve">
    <value>发生错误。请在CrypTool2的日志中找到详细信息。</value>
  </data>
  <data name="PresFinishedSectionHeading" xml:space="preserve">
    <value>4.计算完成</value>
  </data>
  <data name="PresFinishedText" xml:space="preserve">
    <value>要重复计算，有3种选择：-停止执行并再次开始执行-或更改输入之一-或单击“重新启动”按钮（然后计算将自动重新开始）</value>
  </data>
  <data name="PresIterationSectionHeading" xml:space="preserve">
    <value>计算方式</value>
  </data>
  <data name="PresIterationSectionHeadingNum" xml:space="preserve">
    <value>3.计算</value>
  </data>
  <data name="PresRestart" xml:space="preserve">
    <value>重新开始</value>
  </data>
  <data name="PresStart" xml:space="preserve">
    <value>开始</value>
  </data>
  <data name="TooMuchOutputRequestedLogForKPFStd" xml:space="preserve">
    <value>如果参考RFC 5869实施，则输出字节的最大大小为8160。 {0}字节的请求amout设置为最大值。</value>
  </data>
  <data name="TooMuchOutputRequestedLogMSG" xml:space="preserve">
    <value>最大输出量为5 MB 5242880字节）。请求的{0}字节数量已设置为最大值。</value>
  </data>
  <data name="PresStepText" xml:space="preserve">
    <value>{0} / {1}</value>
  </data>
  <data name="PrintToFileGroup" xml:space="preserve">
    <value>保存参数</value>
  </data>
</root>