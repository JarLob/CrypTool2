<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PluginCaption" xml:space="preserve">
    <value>KKDF SHA-256</value>
  </data>
  <data name="KKDFSHA256Tooltip" xml:space="preserve">
    <value>密钥派生函数KKDF SHA-256的可视化</value>
  </data>
  <data name="ConfigPrintKMToFileCaption" xml:space="preserve">
    <value>将生成的密钥材料保存到文件</value>
  </data>
  <data name="ConfigPrintKMToFileTooltip" xml:space="preserve">
    <value>定义将生成的密钥材料保存到文件中，以便可以在其他工具中使用</value>
  </data>
  <data name="InputKeyCaption" xml:space="preserve">
    <value>键</value>
  </data>
  <data name="InputKeyToolTip" xml:space="preserve">
    <value>按键输入</value>
  </data>
  <data name="InputOutputLengthCaption" xml:space="preserve">
    <value>钥匙材料长度</value>
  </data>
  <data name="InputOutputLengthToolTip" xml:space="preserve">
    <value>密钥材料的长度（以字节为单位）</value>
  </data>
  <data name="InputSKMCaption" xml:space="preserve">
    <value>源密钥材料</value>
  </data>
  <data name="InputSKMToolTip" xml:space="preserve">
    <value>输入源密钥资料</value>
  </data>
  <data name="KeyMaterialDebugTextTemplate" xml:space="preserve">
    <value>{0} {ord}计算回合的输出：字节1-8：{1}字节9-16：{2}字节17-24：{3}字节25-32：{4}</value>
  </data>
  <data name="OutputKeyMaterialCaption" xml:space="preserve">
    <value>关键材料</value>
  </data>
  <data name="OutputKeyMaterialDebugCaption" xml:space="preserve">
    <value>除错</value>
  </data>
  <data name="OutputKeyMaterialDebugToolTip" xml:space="preserve">
    <value>密钥推导的单个步骤的输出</value>
  </data>
  <data name="OutputKeyMaterialToolTip" xml:space="preserve">
    <value>输出以生成关键材料</value>
  </data>
  <data name="PrintToFileGroup" xml:space="preserve">
    <value>保存参数</value>
  </data>
  <data name="ConfigPresCaption" xml:space="preserve">
    <value>解释KKDF SHA-256</value>
  </data>
  <data name="ConfigPresTooltip" xml:space="preserve">
    <value>激活或取消激活说明</value>
  </data>
  <data name="PresIntro" xml:space="preserve">
    <value>跳过章节</value>
  </data>
  <data name="PresIntroductionSectionHeading" xml:space="preserve">
    <value>介绍</value>
  </data>
  <data name="PresNext" xml:space="preserve">
    <value>下一个</value>
  </data>
  <data name="ProcessGroup" xml:space="preserve">
    <value>产生过程</value>
  </data>
  <data name="SaveFileDialogCaption" xml:space="preserve">
    <value>将关键材料保存到文件：</value>
  </data>
  <data name="SaveFileDialogTooltip" xml:space="preserve">
    <value>指定生成的密钥材料的输出文件（如果要保存到文件中）</value>
  </data>
  <data name="ExToMuchOutputRequested" xml:space="preserve">
    <value>请为请求的输出字节长度指定一个较小的值。您指定了：{0}。仅允许使用：{1}</value>
  </data>
  <data name="PresCalc" xml:space="preserve">
    <value>跳过计算</value>
  </data>
  <data name="PresConstructionPart2Text" xml:space="preserve">
    <value>通过执行由密钥扩展的哈希函数，可以连续计算密钥材料。然后将各个输出组合成结果键。作为输入，哈希函数使用密钥，每次执行后递增的计数器以及源密钥材料。通过增加计数器，哈希函数的输入在每次执行时都会更改。</value>
  </data>
  <data name="PresConstructionSectionHeading" xml:space="preserve">
    <value>施工</value>
  </data>
  <data name="PresIntroductionPart1Text" xml:space="preserve">
    <value>功能KKDF SHA-256是密钥派生功能（KDF）。它使用键控哈希函数作为伪随机函数（PRF）。该键将作为输入的前缀。它使用SHA-256哈希函数。在此实现中，计数器模式用于迭代。&lt;Bold&gt;注意：&lt;/Bold&gt;由于Merkle-Damgard结构的问题，不应将SHA-256用作PRF。&lt;Bold&gt;此实现仅用于演示目的。</value>
  </data>
  <data name="PresIterationSectionHeading" xml:space="preserve">
    <value>计算阶段</value>
  </data>
  <data name="PresExplanationSectionHeading" xml:space="preserve">
    <value>KKDF SHA-256</value>
  </data>
  <data name="PresSectionIntroductionText" xml:space="preserve">
    <value>&lt;Bold&gt;&lt;Underline&gt;输入：&lt;/Underline&gt;&lt;/Bold&gt;&lt;Bold&gt;源密钥材料：&lt;/Bold&gt;指定源密钥材料（SKM）。&lt;Bold&gt;键：&lt;/Bold&gt;指定用于计算的密钥。&lt;Bold&gt;密钥材料的长度（以字节为单位）：&lt;/Bold&gt;指定密钥材料的长度（以字节为单位）。&lt;Bold&gt;&lt;Underline&gt;输出：&lt;/Underline&gt;&lt;/Bold&gt;&lt;Bold&gt;关键材料：&lt;/Bold&gt;计算后，关键材料（KM）在文本字段中可见。&lt;Bold&gt;调试：&lt;/Bold&gt;关键材料将分多个步骤计算。每个子结果将在此文本字段中可见。</value>
  </data>
  <data name="PresConstructionPart3Text" xml:space="preserve">
    <value>下图显示了计算方案：</value>
  </data>
  <data name="PresConstructionScheme" xml:space="preserve">
    <value>KM = H（K || 1 || SKM）|| H（K || 2 || SKM）|| ... || H（K || n || SKM）</value>
  </data>
  <data name="PresIterationRounds" xml:space="preserve">
    <value>{1} SKM的{0}轮的计算回合：{2}计数器：{3}密钥：{4}</value>
  </data>
  <data name="ConfigInfinityOutput" xml:space="preserve">
    <value>将实现定向到RFC 5869</value>
  </data>
  <data name="ConfigInfinityOutputTooltip" xml:space="preserve">
    <value>配置基于RFC5869。这意味着使用8位计数器，并且输出字节的长度限制为8192。可以在帮助中找到更多信息。</value>
  </data>
  <data name="PresConstructionPart1Text" xml:space="preserve">
    <value>关键材料的计算可描述如下：</value>
  </data>
  <data name="PresConstructionSectionHeadingNum" xml:space="preserve">
    <value>2. KKDF SHA-256的建造</value>
  </data>
  <data name="PresErrorText" xml:space="preserve">
    <value>发生错误。请在Cryptool2的日志中找到详细信息。</value>
  </data>
  <data name="PresFinishedSectionHeading" xml:space="preserve">
    <value>4.计算完成</value>
  </data>
  <data name="PresFinishedText" xml:space="preserve">
    <value>要重复计算，有3种选择：-停止执行并再次开始执行-或更改输入之一-或单击“重新启动”按钮（然后计算将自动重新开始）</value>
  </data>
  <data name="PresIntroductionSectionHeadingNum" xml:space="preserve">
    <value>1.简介</value>
  </data>
  <data name="PresIterationSectionHeadingNum" xml:space="preserve">
    <value>3.计算阶段</value>
  </data>
  <data name="PresKeyMaterialDebugTextTemplate" xml:space="preserve">
    <value>{0} {ord}计算回合的输出：字节1-8：{1}字节9-16：{2}字节17-24：{3}字节25-32：{4}</value>
  </data>
  <data name="PresTitleHeading" xml:space="preserve">
    <value>KKDF SHA-256-具有可扩展输出长度的按键推导功能</value>
  </data>
  <data name="ExSystemOutOfMemory" xml:space="preserve">
    <value>从系统请求内存时，发生了异常。请为输出字节尝试较小的值。</value>
  </data>
  <data name="TooMuchOutputRequestedLogMSG" xml:space="preserve">
    <value>最大输出量为5 MB 5242880字节）。请求的{0}字节数量已设置为最大值。</value>
  </data>
  <data name="TooMuchOutputRequestedLogForKKDFStd" xml:space="preserve">
    <value>如果参考RFC 5869实施，则输出字节的最大大小为8160。 {0}字节的请求amout设置为最大值。</value>
  </data>
  <data name="PresRestart" xml:space="preserve">
    <value>重新开始</value>
  </data>
  <data name="PresSkipChapter" xml:space="preserve">
    <value>跳过章节</value>
  </data>
  <data name="PresStart" xml:space="preserve">
    <value>开始</value>
  </data>
  <data name="PresStepText" xml:space="preserve">
    <value>{0} / {1}</value>
  </data>
</root>