<FlowDocument FontFamily="Tahoma" FontSize="10" Background="#FFFFFFFF" PagePadding="5,0,5,0" AllowDrop="True" NumberSubstitution.CultureSource="User" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"><Paragraph><Run FontWeight="Bold" FontSize="24">HMAC algorithm</Run></Paragraph><Paragraph><Run FontSize="18.6666666666667" xml:lang="de-de">Introduction</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">In cryptography, a keyed-Hash Message Authentication Code (HMAC or KHMAC), is a type of message authentication code (MAC) calculated using a specific algorithm involving a cryptographic hash function in combination with a secret key. As with any MAC, it may be used to simultaneously verify both the data integrity and the authenticity of a message. Any iterative cryptographic hash function, such as MD5 or SHA-1, may be used in the calculation of an HMAC; the resulting MAC algorithm is termed HMAC-MD5 or HMAC-SHA1 accordingly. The cryptographic strength of the HMAC depends upon the cryptographic strength of the underlying hash function, on the size and quality of the key and the size of the hash output length in bits.</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">An iterative hash function breaks up a message into blocks of a fixed size and iterates over them with a compression function. For example, MD5 and SHA-1 operate on 512-bit blocks. The size of the output of HMAC is the same as that of the underlying hash function (128 or 160 bits in the case of MD5 or SHA-1, respectively), although it can be truncated if desired.</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">The construction and analysis of HMACs was first published in 1996 by Mihir Bellare, Ran Canetti, and Hugo Krawczyk, who also wrote RFC 2104. FIPS PUB 198 generalizes and standardizes the use of HMACs. HMAC-SHA-1 and HMAC-MD5 are used within the IPsec and TLS protocols.</Run></Paragraph><Paragraph><Run FontSize="18.6666666666667">Definition</Run><Run FontSize="13.3333333333333" xml:space="preserve"> (from RFC 2104)</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">Let:</Run></Paragraph><List MarkerStyle="Disc"><ListItem><Paragraph><Run FontSize="13.3333333333333">H(·) be a cryptographic hash function</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontSize="13.3333333333333">K be a secret key padded to the right with extra zeros to the block size of the hash function</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontSize="13.3333333333333">m be the message to be authenticated</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontSize="13.3333333333333">∥ denote concatenation</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontSize="13.3333333333333">⊕ denote exclusive or (XOR)</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontSize="13.3333333333333">opad be the outer padding (0x5c5c5c…5c5c, one-block-long hexadecimal constant)</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontSize="13.3333333333333">ipad be the inner padding (0x363636…3636, one-block-long hexadecimal constant)</Run></Paragraph></ListItem></List><Paragraph><Run FontSize="13.3333333333333">Then HMAC(K,m) is mathematically defined by</Run></Paragraph><Paragraph TextAlignment="Center"><Run FontSize="13.3333333333333">HMAC(K,m) = H((K ⊕ opad) ∥ H((K ⊕ ipad) ∥ m)).</Run></Paragraph><Paragraph><Run FontSize="18.6666666666667">Implementation</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">The following pseudocode demonstrates how HMAC may be implemented.</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333">function hmac (key, message)</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    opad = [0x5c * blocksize] // Where blocksize is that of the underlying hash function</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    ipad = [0x36 * blocksize]</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve" /></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    if (length(key) &gt; blocksize) then</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">        key = hash(key) // keys longer than blocksize are shortened</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    end if</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve" /></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    for i from 0 to length(key) - 1 step 1</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">        ipad[i] = ipad[i] ⊕ key[i] // Where ⊕ is exclusive or (XOR)</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">        opad[i] = opad[i] ⊕ key[i]</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    end for</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve" /></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333" xml:space="preserve">    return hash(opad ∥ hash(ipad ∥ message)) // Where ∥ is concatenation</Run></Paragraph><Paragraph><Run FontFamily="Courier New" FontSize="13.3333333333333">end function</Run></Paragraph><Paragraph><Run FontSize="18.6666666666667">Example usage</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">A business that suffers from attackers that place fraudulent Internet orders may insist that all its customers deposit a secret key with them. Along with an order, a customer must supply the order's HMAC digest, computed using the customer's symmetric key. The business, knowing the customer's symmetric key, can then verify that the order originated from the stated customer and has not been tampered with.</Run></Paragraph><Paragraph><Run FontSize="18.6666666666667">Design principles</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">The design of the HMAC specification was motivated by the existence of attacks on more trivial mechanisms for combining a key with a hash function. For example, one might assume the same security that HMAC provides could be achieved with MAC = H(key ∥ message). However this method suffers from a serious flaw: with most hash functions, it is easy to append data to the message without knowing the key and obtain another valid MAC. The alternative, appending the key using MAC = H(message ∥key), suffers from the problem that an attacker who can find a collision in the (unkeyed) hash function has a collision in the MAC. Using MAC = H(key ∥ message ∥ key) is better, however various security papers have suggested vulnerabilities with this approach, even when two different keys are used.</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">No known extensions attacks have been found against the current HMAC specification which is defined as H(key1 ∥ H(key2 ∥ message)) because the outer application of the hash function masks the intermediate result of the internal hash. The values of ipad and opad are not critical to the security of the algorithm, but were defined in such a way to have a large Hamming distance from each other and so the inner and outer keys will have fewer bits in common.</Run></Paragraph><Paragraph><Run FontSize="18.6666666666667">Security</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">The cryptographic strength of the HMAC depends upon the size of the secret key that is used. The most common attack against HMACs is brute force to uncover the secret key. HMACs are not affected by collisions.</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333">In 2006, Jongsung Kim, Alex Biryukov, Bart Preneel, and Seokhie Hong showed how to distinguish HMAC with reduced versions of MD5 and SHA-1 or full versions of HAVAL, MD4, and SHA-0 from a random function or HMAC with a random function. Differential distinguishers allow an attacker to devise a forgery attack on HMAC. Furthermore, differential and rectangle distinguishers can lead to second-preimage attacks. HMAC with the full version of MD4 can be forged with this knowledge. These attacks do not contradict the security proof of HMAC, but provide insight into HMAC based on existing cryptographic hash functions.</Run></Paragraph><Paragraph><Run FontSize="13.3333333333333" xml:space="preserve" /></Paragraph><Paragraph><Run FontStyle="Italic" FontSize="13.3333333333333" xml:lang="de-de" xml:space="preserve">Source: </Run></Paragraph><Paragraph><Run FontSize="13.3333333333333" xml:lang="de-de">HMAC. (2009, October 22). In Wikipedia, The Free Encyclopedia. Retrieved 12:55, October 22, 2009, from http://en.wikipedia.org/w/index.php?title=HMAC&amp;oldid=321322433</Run></Paragraph></FlowDocument>