<?xml version="1.0" encoding="utf-8" ?>

<documentation>
  <language culture="en"/>
  <language culture="de-DE"/>

  <introduction lang="en">
    This plugin is an implementation of a side channel and a man-in-the-middle attack that has been discovered
    by Serge Vaudenay in 2002. It exploits information revealed by a padding oracle. Padding oracles reveal the
    validity of a message. For a long time, this was considered insignificant in terms of
    <external ref="http://en.wikipedia.org/wiki/Information_leakage">Information Leakage</external>.
    This plugin illustrates how this validity information can be misused to allow the attacker to decrypt
    ciphertext blocks. In order to work, the plugin requires several other plugins. Further informations are
    available in the section 'Usage'.
    <section headline="Setup">
      A client tries to send a message to the server. This message was encrypted in
      <external ref="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">CBC mode</external>
      and consists of several
      ciphertext blocks. Only the client and the server know the cryptographic key that was used to encrypt the
      message. Before the message reaches the server, it is intercepted by an attacker. This attacker is able to
      modify the ciphertext blocks and send messages to the server. Upon receipt of a message, the server decrypts
      it in CBC mode and checks the padding afterwards. The result of the padding validation is then returned to
      the attacker. The attacker uses these server responses to decrypt the message.
    </section>
    <section headline="Strategy">
      The client sends an encrypted message to the server. The attacker intercepts this message before it reaches
      its destination. In order to gain knowledge about the underlying plaintext, the attacker modifies the intercepted
      message and forwards it to the server. The server provides a padding oracle to validate any received message.
      The server responses are intercepted as well, since the attacker needs them for the decryption. The goal of the
      attacker is to ascertain the underlying plaintext <b>P2</b> of a ciphertext block <b>C2</b>. In CBC mode
      decryption, a plaintext block <b>P2</b> is generated with the decrypted ciphertext block <b>D2</b> and the
      preceding ciphertext block <b>C1</b>. The formula to decrypt <b>P2</b> is:
      <newline/>
      <b>C1 XOR D2 = P2</b>
      <newline/>
      An attacker who was able to intercept two ciphertext blocks <b>C1</b> and <b>C2</b>, is able to ascertain
      the underlying plaintext as soon as <b>D2</b> is known. The attacker therefore tries to gain
      knowledge about <b>D2</b>. The general idea behind the attack is to replace <b>C2</b> in the above
      equation with a modified ciphertext block. The modified ciphertext block is generated by computing the XOR
      of the original <b>C2</b> with an Overlay block <b>O</b>. This will automatically result in a different
      plaintext block P2. If the attacker knows which plaintext is generated when using <b>C1 XOR O</b>, <b>D2</b>
      can be computed easily:
      <newline/>
      <b>C1 XOR O XOR P2 = D2</b>
      <newline/>
      The attack consists of 3 phases, which will be explained in the following.
    </section>
    <section headline="Phase 1: Find Valid Padding">
      In the first phase, a ciphertext message that results in a plaintext with a valid padding needs to
      be found. The original ciphertext block <b>C1</b> is therefore modified by computing an XOR of <b>C1</b> and the Overlay <b>O</b>.
      The value of every byte of <b>O</b> is set to 00 in order to check if the plaintext message already has a valid padding.
      If no valid padding exists, <b>O</b> has to be changed until a valid padding is found. Following CBC mode, the
      padding oracle decrypts <b>C2</b> and then generates the plaintext by computing the XOR of <b>C1</b>
      and the decrypted block <b>D2</b>. Afterwards, the padding oracle checks if the padding is correct.
      As long as the padding oracle returns FALSE (invalid padding), the last byte of <b>O</b> is changed and
      the message is resent to the padding oracle. When the padding oracle returns TRUE, the
      padding is valid. Therefore, <b>C1 XOR O XOR D2</b> must end with ‘01’ or ‘02 02’ or ‘03 03 03’, …, or
      ‘FF…FF’.
    </section>
    <section headline="Phase 2: Find Padding Length">
      At this point, the message results in a valid padding. The next step is to determine the
      length of the padding by finding the first padding byte. The padding bytes are always at the
      end of a block. When the position of the first padding byte is known, the length of the padding
      is therefore known as well. Determining the padding length can be done by using the padding
      oracle again.
      This time, the first byte of <b>O</b> is changed. The message is again sent to the padding
      oracle. If the padding remains valid, the first byte does not influence the padding. In this case,
      the second byte of <b>O</b> is changed. This process is repeated until the padding oracle returns false.
      As soon as false is returned, a previously valid padding byte must have been changed. The
      changed byte and all subsequent bytes of the block therefore must be padding bytes. The
      amount of existing padding bytes is defined as the padding length <i>l</i>.
    </section>
    <section headline="Phase 3: Block Decryption">
      In phase 3, the ciphertext block is decrypted. The padding length had been determined in the
      previous phase. Since the value of the padding bytes equals the padding length, the last <i>l</i>
      ciphertext byte(s) can already be decrypted by computing the XOR of <b>C1</b>, <b>O</b> and <i>l</i>.
      The other bytes cannot be decrypted yet, because only the value of the padding bytes is
      known. In order to decrypt the hindmost unknown byte, the generated padding has to be
      increased. This can be achieved by modifying the last l bytes of <b>O</b>, so the last <i>l</i> bytes of <b>P2</b>
      have the value <i>l+1</i>.
      The new plaintext <b>P2</b> will only be valid if the last <i>l+1</i> bytes have the value <i>l+1</i>. Similar to phase 1, <b>O</b> has
      to be changed at position until the padding turns valid. As soon as the padding is valid,
      the value of the hindmost unknown byte can be calculated as well. This process is repeated until the whole block is
      decrypted.
    </section>
  </introduction>

  <introduction lang="de-de">
    Dieses Plugin ist eine Implementierung des "Side-channel"- und "Man-in-the-middle"-Angriffes, der 2002 von Serge Vaudenay
    entdeckt wurde. Dieser Angriff nutzt Informationen aus, die von einem Padding-Orakel offenbart werden. Padding-Orakel
    geben Auskunft über die Gültigkeit des Paddings einer Nachricht. Dieses Verhalten wurde in Bezug auf
    <external ref="http://de.wikipedia.org/wiki/Information_Disclosure">Information Leakage</external>
    lange Zeit als unbedeutend angesehen. Dieses Plugin illustriert, wie diese Gültigkeits-Information ausgenutzt werden kann,
    damit ein Angreifer verschlüsselte Geheimtext-Blöcke entschlüsseln kann. Dieses Plugin benötigt mehrere Plugins, um korrekt
    zu funktionieren. Weitere Informationen dazu erhalten Sie im Abschnitt "Benutzung".

    <section headline="Aufbau">
      Der Client versucht eine Nachricht zum Server zu schicken. Diese Nachricht wurde im
      <external ref="http://de.wikipedia.org/wiki/Cipher_Block_Chaining_Mode">CBC-Modus</external>
      verschlüsselt und besteht
      aus zwei Geheimtextblöcken. Der zweite Block <b>C2</b> enthält den Klartext, den der Angreifer ermitteln möchte. Der
      erste Block dient nur als Initialisierungvektor (IV) und enthält keinen zugrundeliegenden Klartext, für den sich der Angreifer
      interessiert. Nur der Client und der Server kennen den kryptographischen Schlüssel, der zu Verschlüsselung
      benutzt wurde. Bevor die Nachricht den Server erreicht, wird sie vom Angreifer abgefangen. Der Angreifer ist in der Lage,
      die Geheimtextblöcke zu modifizieren und Nachrichten zum Server zu schicken. Bei Erhalt einer Nachricht, entschlüsselt der
      Server diese zunächst im CBC-Modus und überprüft anschließend das Padding. Das Ergebnis dieser Überprüfung wird
      anschließend an den Angreifer zurückgeschickt. Der Angreifer nutzt diese Antworten vom Server, um den zweiten
      Geheimtext-Block zu entschlüsseln.
    </section>
    
    <section headline="Phase 1: Gültiges Padding finden">
      In der ersten Phase geht es darum, eine Geheimtext-Nachricht zu finden, die entschlüsselt ein gültiges Padding hat.
      Der ursprüngliche Geheimtextblock <b>C1</b> wird dazu mit Hilfe des Overlays <b>O</b> angepasst. Im CBC-Modus wird
      der Klartext <b>P2</b> erzeugt, indem man das XOR aus dem entschlüsselten Geheimtext <b>D2</b> und <b>C1</b>
      berechnet. Anschließend wird das Padding vom Padding-Orakel überprüft. So lange das Padding ungültig ist, wird das letzte
      Byte vom Overlay <b>O</b> angepasst und eine neue Nachricht, bestehend aus zwei Geheimtextblöcken an den Server
      geschickt. Der erste Block besteht dabei aus dem XOR aus <b>O</b> und <b>C1</b>, während der zweite Block aus dem
      unveränderten Block <b>C2</b> besteht. Wenn das Padding gültig wird, muss C1 XOR O XOR D2 entweder mit '01' oder '02 02'
      oder '03 03 03' oder .... 'FF ... FF' enden.
    </section>
    <section headline="Phase 2: Padding Länge ermitteln">
      An dieser Stelle haben wir einen Geheimtext, der ein gültiges Padding hat. Der nächste Schritt ist nun die Ermittlung
      der Padding-Länge, indem das erste Padding-Byte gesucht wird. Die Padding-Bytes befinden sich immer am Ende des Klartext-Blockes.
      Wenn die Position des ersten Padding-Bytes bekannt ist, kann man dadurch sehr leicht auf die Länge des Paddings
      schließen. Die Position des ersten Padding-Bytes lässt sich wieder mit Hilfe des Padding-Orakels ermitteln.
      Dieses Mal wird das erste Byte des Overlays <b>O</b> verändert. Wenn das Padding immer noch gültig ist, dann gehört das
      geänderte Byte nicht zum Padding. In diesem Fall wird das zweite Byte von <b>O</b> geändert. Dieser Prozess wird solange
      fortgesetzt, bis das Padding ungültig wird. Wenn das Padding ungültig wird, muss ein Padding-Byte geändert worden sein. Das
      geänderte Byte und alle nachfolgenden Bytes müssen daher zum Padding gehören. Die Anzahl existierender Padding-Bytes
      wird als die Länge <i>l</i> definiert.
    </section>
    <section headline="Phase 3: Entschlüsselung">
      In Phase 3 wird der Geheimtext entschlüsselt. Die Padding-Länge wurde bereits in der vorherigen Phase ermittelt. Da der Wert
      der Padding-Bytes der Padding-Länge <i>l</i> entspricht, können die letzten <i>l</i> Bytes des Geheimtextes schon entschlüsselt werden.
      Dies geschieht durch die Berechnung eines XORs aus <b>C1</b>, <b>O</b> und <i>l</i>.
      Die anderen Bytes können noch nicht entschlüsselt werden, da die entsprechenden Klartext-Werte noch nicht bekannt sind. Um
      das hinterste unbekannte Byte zu entschlüsseln wird das Padding vergrößert. Dazu werden die letzten <i>l</i> Bytes von <b>O</b>
      so verändert, dass die resultierenden Klartext-Bytes den Wert <i>l+1</i> haben. Der neue Klartext <b>P2</b> wird nun nur gültig,
      wenn die letzten <i>l+1</i> Bytes diesen Wert haben (inklusive des hintersten unbekannten Bytes). Wenn das Padding nicht gültig ist,
      so wird ähnlich wie in Phase 1 versucht, das gewünschte Ergebnis durch Änderung des Overlays <b>O</b> zu erhalten.
      Sobald das Padding gültig wird, kann auch dieses Byte entschlüsselt werden. Dieser Prozess wird nun solange wiederholt, bis
      alle Geheimtext-Bytes entschlüsselt wurden. Danach muss nur noch das Overlay entfernt werden, damit man den
      ursprünglichen Klartext erhält.
    </section>
  </introduction>

  <usage lang="en">
    The Padding Oracle Attack Plugin (POA) has several requirements:
    <list>
      <item>Two 8 byte long ciphertexts as input</item>
      <item>CBC mode: The cipher itself, the key and the IV can be modified, but the cipher has to be run in CBC mode</item>
      <item>Padding Oracle: The output of the POA has to be decrypted (same cipher as during the encryption) and then has to be forwarded to the Padding Oracle Plugin. The output of the Padding Oracle has to be connected to the POA again.</item>
    </list>
  </usage>

  <usage lang="de-de">
    Das Plugin Padding-Orakel-Angriff (POA) hat mehrere Voraussetzungen:
    <list>
      <item>Zwei 8 Byte lange Geheimtextblöcke als Input</item>
      <item>CBC-Modus: Die Chiffre selbst, der Schlüssel und der IV können frei gewählt werden, aber die Chiffre muss in CBC Modus laufen, damit der Angriff funktioniert</item>
      <item>Padding-Orakel: Der Output des POAs muss entschlüsselt werden und dann an das Padding-Orakel-Plugin weitergeleitet werden. Der Output des Padding-Orakels dient dabei wiederum als Inputfaktor für das POA.</item>
    </list>
  </usage>

  <presentation lang="en">
    The presentation is divided into three major parts: input, attack logic and output.<newline/>
    1. The input section displays the intercepted ciphertext blocks <b>C1</b> and <b>C2</b> and the response from the padding
    oracle. Only two ciphertext blocks are used during the attack. The second block (<b>C2</b>) contains an
    underlying plaintext, which the attacker tries to ascertain. The first block (<b>C1</b>) is manipulated to
    influence the generation of the plaintext block <b>P2</b>. While the ciphertext blocks remain constant during
    the attack, the response from the padding oracle is variable.
    <newline/>
    2.The attack logic displays the data blocks relevant for the attack. This includes the decrypted
    second ciphertext block <b>D2</b>, the first ciphertext block <b>C1</b>, an overlay <b>O</b> and the plaintext
    <b>P2</b>. <b>D2</b> and <b>P2</b> are only completely known at the end of the
    attack. <b>O</b> displays how <b>C1</b> is modified. During the attack, the
    plaintext block <b>P2</b> displays the result of computing an XOR of <b>D2</b>, <b>C1</b> and <b>O</b>.
    Therefore, it reflects which padding is currently generated or targeted.
    Since only one byte is targeted during a step, a pointer indicates which byte is currently
    changed. All data blocks in the presentation have tooltips to allow users to easily access explanations.
    The attack logic also contains a text field which informs about interim results and further actions. The
    actions are triggered by buttons. The button labeled ‘Next’ performs the next step only.
    Occasionally, brute forcing is necessary. Another button, ‘Auto Search’, was included, so
    it is not necessary to click through the complete brute forcing sequence. By clicking this
    button, the currently targeted byte is automatically changed until the wanted value is found. In
    phase 3, up to 7 values have to be brute forced. Therefore, it is possible to decrypt the whole
    message with the button ‘Decrypt Completely’.
    It is also possible to undo steps. The button "&lt;" undoes the last performed step, while the button "&lt;&lt;" 
    goes back to the beginning of the current phase.
    <newline/>
    3. The output section displays the first ciphertext block with its current modifications (<b>C1</b> XOR
    <b>O</b>) and the
    second ciphertext block. A counter which reflects the amount of server requests is also
    included.
  </presentation>

  <presentation lang="de-de">
    Die präsentation ist in drei Teile unterteilt: Input, Angriffslogik und Output.<newline/>
    1. Die Input-Sektion enthält die abgefangenen Geheimtext-Blöcke <b>C1</b> und <b>C2</b> und die Antwort vom Padding-Orakel.
    Während des Angriffs werden nur 2 Geheimtext-Blöcke betrachtet. Der zweite Block <b>C2</b> enthält einen Klartext, den der
    Angreifer ermitteln möchte. Der erste Block <b>C1</b> wird während des Angriffes modifiziert, um die Generierung des
    Klartext-Blockes <b>P2</b> zu beeinflussen. Die Antwort des Padding-Orakels ist der einzige Input, der sich im Laufe des
    Angriffes ändert; die Geheimtext-Blöcke bleiben konstant.
    <newline/>
    2. Die Angriffslogik zeigt die für den Angriff relevanten Datenblöcke. Dies umfasst den entschlüsselten Geheimtext-Block <b>D2</b>,
    den ersten Geheimtext-Block <b>C1</b>, das Overlay <b>O</b> und den Klartext <b>P2</b>. <b>D2</b> und <b>P2</b>
    sind erst am Ende des Angriffs vollständig bekannt. <b>O</b> stellt dar, wie <b>C1</b> modifiziert wird. Der Klartext-Block
    <b>P2</b> stellt während des Angriffes die Berechnung des XORs von <b>D2</b>, <b>C1</b> und <b>O</b> dar.
    <b>P2</b> spiegelt dadurch das aktuelle generierte bzw. angezielte Padding wieder.
    Ein sogenannter Pointer zeigt an, welches Byte zur Zeit betrachtet und angepasst wird. Alle Datenblöcke haben Tooltips, die die Bedeutung
    der einzelnen Blöcke erklären. Die Angriffslogik enthält außerdem ein Textfeld, das Informationen zu Zwischenergebnissen oder
    nächste Schritte bereitstellt. Die einzelnen Schritte/Aktionen werden durch Knöpfe (Buttons) ausgelöst. Der Button "Weiter" führt
    nur den nächsten Schritt durch. An einigen Stellen muss Brute-Force angewandt werden. Der Button "Automatische Suche" dient
    dazu, dass man sich nicht durch den ganzen Brute-Force-Ablauf klicken muss. Bei Betätigung des Buttons wird das aktuelle Byte
    so oft geändert, bis das gewünschte Ergebnis erhalten wird. In Phase 3 müssen bis zu 7 Werte mit Brute-Force gefunden werden.
    Aus diesem Grund kann man mit dem Button "Alles Entschlüsseln" die gesamte Nachricht mit einem Klick entschlüsseln.
    Es ist auch möglich, Aktionen rückgängig zu machen. Der Button "&lt;" macht die letzte Aktion rückgängig, während "&lt;&lt;" 
    zum Beginn der aktuellen Phase zurückgeht.
    <newline/>
    3. Die Output-Sektion enthält den ersten Geheimtext-Block <b>C1</b> mit den aktuellen Modifikationen
    (<b>C1</b> XOR <b>O</b>) und den unveränderter Geheimtext-Block <b>C2</b>. Ein Zähler stellt die Anzahl der Padding-Orakel-Anfragen (Requests) dar.
  </presentation>

  <references>
    <bookReference id="POA">
      <author>Alexander Juettner</author>
      <name lang="en">
        Analysis of the Functionality, Risks and Counter-Measures of Current
        Padding Attacks and the Implementation of an Attack in the Open Source
        Program CrypTool 2
      </name>
      <name lang="de-DE">
        Analysis of the Functionality, Risks and Counter-Measures of Current
        Padding Attacks and the Implementation of an Attack in the Open Source
        Program CrypTool 2
      </name>
    </bookReference>
    <bookReference id="POA_Vaud">
      <author>Serge Vaudenay</author>
      <publisher lang="en">Springer</publisher>
      <publisher lang="de-DE">Springer</publisher>
      <name lang="en">
        Security Flaws Induced by CBC Padding Applications to SSL, IPSEC, WTLS….
      </name>
      <name lang="de-DE">
        Security Flaws Induced by CBC Padding Applications to SSL, IPSEC, WTLS….
      </name>
    </bookReference>
  </references>
</documentation>