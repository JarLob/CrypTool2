<?xml version="1.0" encoding="utf-8"?>
<documentation>
  <language culture="en" />
  <language culture="zh-CN" />
  <language culture="ru" />
  <language culture="de-DE" />
  <introduction lang="en">
    This plugin is an implementation of a side channel and a man-in-the-middle attack that has been discovered
    by Serge Vaudenay in 2002. It exploits information revealed by a padding oracle. Padding oracles reveal the
    validity of a message. For a long time, this was considered insignificant in terms of
    <external ref="http://en.wikipedia.org/wiki/Information_leakage">Information Leakage</external>.
    This plugin illustrates how this validity information can be misused to allow the attacker to decrypt
    ciphertext blocks. In order to work, the plugin requires several other plugins. Further information is
    available in the section 'Usage'.
    <section headline="Setup">
      A client tries to send a message to the server. This message was encrypted in
      <external ref="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">CBC mode</external>
      and consists of several
      ciphertext blocks. Only the client and the server know the cryptographic key that was used to encrypt the
      message. Before the message reaches the server, it is intercepted by an attacker. This attacker is able to
      modify the ciphertext blocks and send messages to the server. Upon receipt of a message, the server decrypts
      it in CBC mode and checks the padding afterwards. The result of the padding validation is then returned to
      the attacker. The attacker uses these server responses to decrypt the message.
    </section><section headline="Strategy">
      The client sends an encrypted message to the server. The attacker intercepts this message before it reaches
      its destination. In order to gain knowledge about the underlying plaintext, the attacker modifies the intercepted
      message and forwards it to the server. The server provides a padding oracle to validate any received message.
      The server responses are intercepted as well, since the attacker needs them for the decryption. The goal of the
      attacker is to ascertain the underlying plaintext <b>P2</b> of a ciphertext block <b>C2</b>. In CBC mode
      decryption, a plaintext block <b>P2</b> is generated with the decrypted ciphertext block <b>D2</b> and the
      preceding ciphertext block <b>C1</b>. The formula to decrypt <b>P2</b> is:
      <newline /><b>C1 XOR D2 = P2</b><newline />
      An attacker who was able to intercept two ciphertext blocks <b>C1</b> and <b>C2</b>, is able to ascertain
      the underlying plaintext as soon as <b>D2</b> is known. The attacker therefore tries to gain
      knowledge about <b>D2</b>. The general idea behind the attack is to replace <b>C2</b> in the above
      equation with a modified ciphertext block. The modified ciphertext block is generated by computing the XOR
      of the original <b>C2</b> with an Overlay block <b>O</b>. This will automatically result in a different
      plaintext block P2. If the attacker knows which plaintext is generated when using <b>C1 XOR O</b>, <b>D2</b>
      can be computed easily:
      <newline /><b>C1 XOR O XOR P2 = D2</b><newline />
      The attack consists of 3 phases, which will be explained in the following.
    </section><section headline="Phase 1: Find Valid Padding">
      In the first phase, a ciphertext message that results in a plaintext with a valid padding needs to
      be found. The original ciphertext block <b>C1</b> is therefore modified by computing an XOR of <b>C1</b> and the Overlay <b>O</b>.
      The value of every byte of <b>O</b> is set to 00 in order to check if the plaintext message already has a valid padding.
      If no valid padding exists, <b>O</b> has to be changed until a valid padding is found. Following CBC mode, the
      padding oracle decrypts <b>C2</b> and then generates the plaintext by computing the XOR of <b>C1</b>
      and the decrypted block <b>D2</b>. Afterwards, the padding oracle checks if the padding is correct.
      As long as the padding oracle returns FALSE (invalid padding), the last byte of <b>O</b> is changed and
      the message is resent to the padding oracle. When the padding oracle returns TRUE, the
      padding is valid. Therefore, <b>C1 XOR O XOR D2</b> must end with ‘01’ or ‘02 02’ or ‘03 03 03’, …, or
      ‘FF…FF’.
    </section><section headline="Phase 2: Find Padding Length">
      At this point, the message results in a valid padding. The next step is to determine the
      length of the padding by finding the first padding byte. The padding bytes are always at the
      end of a block. When the position of the first padding byte is known, the length of the padding
      is therefore known as well. Determining the padding length can be done by using the padding
      oracle again.
      This time, the first byte of <b>O</b> is changed. The message is again sent to the padding
      oracle. If the padding remains valid, the first byte does not influence the padding. In this case,
      the second byte of <b>O</b> is changed. This process is repeated until the padding oracle returns false.
      As soon as false is returned, a previously valid padding byte must have been changed. The
      changed byte and all subsequent bytes of the block therefore must be padding bytes. The
      amount of existing padding bytes is defined as the padding length <i>l</i>.
    </section><section headline="Phase 3: Block Decryption">
      In phase 3, the ciphertext block is decrypted. The padding length had been determined in the
      previous phase. Since the value of the padding bytes equals the padding length, the last <i>l</i>
      ciphertext byte(s) can already be decrypted by computing the XOR of <b>C1</b>, <b>O</b> and <i>l</i>.
      The other bytes cannot be decrypted yet, because only the value of the padding bytes is
      known. In order to decrypt the hindmost unknown byte, the generated padding has to be
      increased. This can be achieved by modifying the last l bytes of <b>O</b>, so the last <i>l</i> bytes of <b>P2</b>
      have the value <i>l+1</i>.
      The new plaintext <b>P2</b> will only be valid if the last <i>l+1</i> bytes have the value <i>l+1</i>. Similar to phase 1, <b>O</b> has
      to be changed at position until the padding turns valid. As soon as the padding is valid,
      the value of the hindmost unknown byte can be calculated as well. This process is repeated until the whole block is
      decrypted.
    </section></introduction>
  <introduction lang="zh-CN">该插件是Serge Vaudenay在2002年发现的一种侧通道和中间人攻击的实现。它利用填充预告片显示的信息。填充预言片显示消息的有效性。长期以来，这在信息泄漏方面被认为是微不足道的。该插件说明了如何滥用此有效性信息以允许攻击者解密密文块。为了正常工作，该插件需要其他几个插件。有关更多信息，请参见“用法”部分。客户端尝试向服务器发送消息。此消息以CBC模式加密，由几个密文块组成。只有客户端和服务器才知道用于加密消息的加密密钥。在邮件到达服务器之前，它会被攻击者拦截。该攻击者能够修改密文块并将消息发送到服务器。收到消息后，服务器将以CBC模式对其进行解密，然后再检查填充。然后，将填充验证的结果返回给攻击者。攻击者使用这些服务器响应来解密消息。客户端将加密的消息发送到服务器。攻击者在此消息到达目的地之前对其进行拦截。为了获得有关底层明文的知识，攻击者修改了截获的消息并将其转发给服务器。服务器提供了一个填充预告片来验证任何收到的消息。服务器响应也被拦截，因为攻击者需要使用它们进行解密。攻击者的目标是确定密文块C2的基础明文P2。在CBC模式解密中，利用解密的密文块D2和先前的密文块C1生成明文块P2。解密P2的公式为：C1 XOR D2 = P2能够截获两个密文块C1和C2的攻击者一知道D2就可以确定基础明文。因此，攻击者试图获取有关D2的知识。攻击背后的总体思路是用修改后的密文块替换上式中的C2。修改后的密文块是通过计算原始C2与Overlay块O的XOR生成的。这将自动产生不同的明文块P2。如果攻击者知道使用C1 XOR O时生成了哪个明文，则可以轻松地计算D2：C1 XOR O XOR P2 = D2攻击包括3个阶段，下面将对此进行说明。在第一阶段中，需要找到密文消息，该密文消息会产生具有有效填充的明文。因此，通过计算C1与Overlay O的XOR来修改原始密文块C1。O的每个字节的值都设置为00，以便检查明文消息是否已经具有有效的填充。如果不存在有效的填充，则必须更改O，直到找到有效的填充。遵循CBC模式，填充预告片解密C2，然后通过计算C1与解密块D2的XOR生成明文。此后，填充预告片检查填充是否正确。只要填充oracle返回FALSE（无效的填充），O的最后一个字节就会更改，并且消息会重新发送到填充oracle。当填充oracle返回TRUE时，填充有效。因此，C1 XOR O XOR D2必须以“ 01”或“ 02 02”或“ 03 03 03”，……或“ FF…FF”结尾。此时，该消息将导致有效的填充。下一步是通过找到第一个填充字节来确定填充的长度。填充字节始终在块的末尾。当第一填充字节的位置已知时，填充的长度因此也已知。可以通过再次使用padding oracle来确定padding的长度。这次，O的第一个字节被更改。该消息再次发送到填充oracle。如果填充保持有效，则第一个字节不会影响填充。在这种情况下，O的第二个字节被更改。重复此过程，直到填充oracle返回false。一旦返回false，就必须更改先前有效的填充字节。因此，块的已更改字节和所有后续字节必须是填充字节。现有填充字节的数量定义为填充长度l。在阶段3中，密文块被解密。填充长度已在上一阶段确定。由于填充字节的值等于填充长度，因此最后一个密文字节可以通过计算C1，O和l的XOR来解密。其他字节不能被解密，因为只有填充字节的值是已知的。为了解密最后面的未知字节，必须增加生成的填充。这可以通过修改O的最后1个字节来实现，因此P2的最后1个字节具有值l + 1。仅当最后的l + 1个字节的值为l + 1时，新的明文P2才有效。与阶段1相似，在填充变为有效之前，必须在位置上更改O。一旦填充有效，就可以计算出最后一个未知字节的值。重复该过程，直到整个块被解密为止。</introduction>
  <introduction lang="ru">Этот плагин представляет собой реализацию бокового канала и нападение «человек-в-середине», обнаруженное Сержем Водэнаем в 2002 году. Он использует информацию, обнаруженную прописью оракула. Прописные оракулы показывают достоверность сообщения. Долгое время это считалось несущественным с точки зрения информационного утечки. Этот плагин иллюстрирует, как эту информацию о достоверности можно использовать неправильно, чтобы позволить злоумышленнику расшифровать блоки зашифрованного текста. Для работы плагин требует нескольких других плагинов. Дополнительную информацию можно найти в разделе «Использование». Клиент пытается отправить сообщение на сервер. Это сообщение было зашифровано в режиме CBC и состоит из нескольких блоков зашифрованного текста. Только клиент и сервер знают криптографический ключ, который использовался для шифрования сообщения. До того, как сообщение достигнет сервера, оно будет перехвачено злоумышленником. Этот злоумышленник может модифицировать блоки шифрованного текста и отправлять сообщения на сервер. После получения сообщения сервер расшифровывает его в режиме CBC и после этого проверяет заполнение. Результат проверки дополнений затем возвращается злоумышленнику. Злоумышленник использует эти ответы сервера для дешифрования сообщения. Клиент отправляет зашифрованное сообщение на сервер. Атакующий перехватывает это сообщение, прежде чем он достигнет своего адресата. Чтобы получить знания о базовом открытом тексте, злоумышленник модифицирует перехваченное сообщение и перенаправляет его на сервер. Сервер предоставляет прокрутку для проверки любого принятого сообщения. Ответы сервера также перехватываются, так как злоумышленник нуждается в них для дешифрования. Цель злоумышленника состоит в том, чтобы определить лежащий в основе открытый текст P2 блока C2 шифрованного текста. В расшифровке режима CBC блок P2 открытого текста генерируется с расшифрованным блоком D2 зашифрованного текста и предыдущим блоком C1 шифрованного текста. Формула для дешифрования P2: C1 XOR D2 = P2 Нападавший, который смог перехватить два блока шифрованного текста C1 и C2, может установить базовый открытый текст, как только D2 будет известен. Поэтому злоумышленник пытается получить знания о D2. Общая идея атаки заключается в том, чтобы заменить C2 в приведенном выше уравнении модифицированным блоком зашифрованного текста. Измененный блок зашифрованного текста генерируется путем вычисления XOR исходного C2 с блоком O Overlay. Это автоматически приведет к другому блоку открытого текста P2. Если злоумышленник знает, какой открытый текст генерируется при использовании C1 XOR O, D2 можно легко вычислить: C1 XOR O XOR P2 = D2 Атака состоит из трех фаз, что будет объяснено ниже. На первом этапе необходимо найти сообщение с зашифрованным текстом, которое приводит к созданию открытого текста с допустимым заполнением. Поэтому исходный блок C1 зашифрованного текста модифицируется путем вычисления XOR C1 и Overlay O. Значение каждого байта O устанавливается равным 00, чтобы проверить, действительно ли сообщение открытого текста имеет допустимое заполнение. Если не существует допустимого дополнения, O необходимо изменить до тех пор, пока не будет найдено допустимое дополнение. В соответствии с режимом CBC одинак ​​расшифровывает C2, а затем генерирует открытый текст, вычисляя XOR C1 и расшифрованный блок D2. Впоследствии прописной оратор проверяет правильность заполнения. До тех пор, пока оскорбление прокрутки вернет FALSE (недопустимое заполнение), последний байт O изменится и сообщение будет повторно отправлено на прописную букву. Когда возвращаемый оракул возвращает TRUE, заполнение является допустимым. Следовательно, C1 XOR O XOR D2 должен заканчиваться «01» или «022» или «03 03 03», ... или «FF ... FF». На этом этапе сообщение приводит к действительному заполнению. Следующим шагом будет определение длины заполнения путем поиска первого байта заполнения. Байты заполнения всегда находятся в конце блока. Когда позиция первого байта заполнения известна, поэтому длина прокладки также известна. Определение длины заполнения может быть выполнено с помощью пропиточного оракула снова. На этот раз первый байт O изменяется. Сообщение снова отправляется в прописной оракул. Если заполнение остается в силе, первый байт не влияет на заполнение. В этом случае второй байт O изменяется. Этот процесс повторяется до тех пор, пока прописной оракул не вернет false. Как только возвращается false, должен быть изменен ранее допустимый байт заполнения. Измененный байт и все последующие байты блока, следовательно, должны быть байтами заполнения. Количество существующих байтов заполнения определяется как длина заполнения l. На этапе 3 блок зашифрованного текста дешифруется. Длина прокладки была определена на предыдущей фазе. Так как значение байтов заполнения равно длине заполнения, последний l шифротекст (байты) уже может быть дешифрован путем вычисления XOR C1, O и l. Остальные байты еще не дешифруются, поскольку известно только значение байтов заполнения. Чтобы расшифровать нижний неизвестный байт, сгенерированное заполнение должно быть увеличено. Это может быть достигнуто путем изменения последних l байтов O, поэтому последние l байтов P2 имеют значение l + 1. Новый открытый текст P2 будет действителен только в том случае, если последние l + 1 байты имеют значение l + 1. Как и в случае с фазой 1, значение O должно быть изменено в позиции до тех пор, пока прокладка не станет действительной. Как только заполнение будет действительным, можно также вычислить значение самого младшего неизвестного байта. Этот процесс повторяется до тех пор, пока весь блок не будет дешифрован.</introduction>
  <introduction lang="de-de">
    Dieses Plugin ist eine Implementierung des "Side-channel"- und "Man-in-the-middle"-Angriffes, der 2002 von Serge Vaudenay
    entdeckt wurde. Dieser Angriff nutzt Informationen aus, die von einem Padding-Orakel offenbart werden. Padding-Orakel
    geben Auskunft über die Gültigkeit des Paddings einer Nachricht. Dieses Verhalten wurde in Bezug auf
    <external ref="http://de.wikipedia.org/wiki/Information_Disclosure">Information Leakage</external>
    lange Zeit als unbedeutend angesehen. Dieses Plugin illustriert, wie diese Gültigkeits-Information ausgenutzt werden kann,
    damit ein Angreifer verschlüsselte Geheimtext-Blöcke entschlüsseln kann. Dieses Plugin benötigt mehrere Plugins, um korrekt
    zu funktionieren. Weitere Informationen dazu erhalten Sie im Abschnitt "Benutzung".

    <section headline="Aufbau">
      Der Client versucht eine Nachricht zum Server zu schicken. Diese Nachricht wurde im
      <external ref="http://de.wikipedia.org/wiki/Cipher_Block_Chaining_Mode">CBC-Modus</external>
      verschlüsselt und besteht
      aus zwei Geheimtextblöcken. Der zweite Block <b>C2</b> enthält den Klartext, den der Angreifer ermitteln möchte. Der
      erste Block dient nur als Initialisierungvektor (IV) und enthält keinen zugrundeliegenden Klartext, für den sich der Angreifer
      interessiert. Nur der Client und der Server kennen den kryptographischen Schlüssel, der zu Verschlüsselung
      benutzt wurde. Bevor die Nachricht den Server erreicht, wird sie vom Angreifer abgefangen. Der Angreifer ist in der Lage,
      die Geheimtextblöcke zu modifizieren und Nachrichten zum Server zu schicken. Bei Erhalt einer Nachricht, entschlüsselt der
      Server diese zunächst im CBC-Modus und überprüft anschließend das Padding. Das Ergebnis dieser Überprüfung wird
      anschließend an den Angreifer zurückgeschickt. Der Angreifer nutzt diese Antworten vom Server, um den zweiten
      Geheimtext-Block zu entschlüsseln.
    </section><section headline="Phase 1: Gültiges Padding finden">
      In der ersten Phase geht es darum, eine Geheimtext-Nachricht zu finden, die entschlüsselt ein gültiges Padding hat.
      Der ursprüngliche Geheimtextblock <b>C1</b> wird dazu mit Hilfe des Overlays <b>O</b> angepasst. Im CBC-Modus wird
      der Klartext <b>P2</b> erzeugt, indem man das XOR aus dem entschlüsselten Geheimtext <b>D2</b> und <b>C1</b>
      berechnet. Anschließend wird das Padding vom Padding-Orakel überprüft. So lange das Padding ungültig ist, wird das letzte
      Byte vom Overlay <b>O</b> angepasst und eine neue Nachricht, bestehend aus zwei Geheimtextblöcken an den Server
      geschickt. Der erste Block besteht dabei aus dem XOR aus <b>O</b> und <b>C1</b>, während der zweite Block aus dem
      unveränderten Block <b>C2</b> besteht. Wenn das Padding gültig wird, muss C1 XOR O XOR D2 entweder mit '01' oder '02 02'
      oder '03 03 03' oder .... 'FF ... FF' enden.
    </section><section headline="Phase 2: Padding Länge ermitteln">
      An dieser Stelle haben wir einen Geheimtext, der ein gültiges Padding hat. Der nächste Schritt ist nun die Ermittlung
      der Padding-Länge, indem das erste Padding-Byte gesucht wird. Die Padding-Bytes befinden sich immer am Ende des Klartext-Blockes.
      Wenn die Position des ersten Padding-Bytes bekannt ist, kann man dadurch sehr leicht auf die Länge des Paddings
      schließen. Die Position des ersten Padding-Bytes lässt sich wieder mit Hilfe des Padding-Orakels ermitteln.
      Dieses Mal wird das erste Byte des Overlays <b>O</b> verändert. Wenn das Padding immer noch gültig ist, dann gehört das
      geänderte Byte nicht zum Padding. In diesem Fall wird das zweite Byte von <b>O</b> geändert. Dieser Prozess wird solange
      fortgesetzt, bis das Padding ungültig wird. Wenn das Padding ungültig wird, muss ein Padding-Byte geändert worden sein. Das
      geänderte Byte und alle nachfolgenden Bytes müssen daher zum Padding gehören. Die Anzahl existierender Padding-Bytes
      wird als die Länge <i>l</i> definiert.
    </section><section headline="Phase 3: Entschlüsselung">
      In Phase 3 wird der Geheimtext entschlüsselt. Die Padding-Länge wurde bereits in der vorherigen Phase ermittelt. Da der Wert
      der Padding-Bytes der Padding-Länge <i>l</i> entspricht, können die letzten <i>l</i> Bytes des Geheimtextes schon entschlüsselt werden.
      Dies geschieht durch die Berechnung eines XORs aus <b>C1</b>, <b>O</b> und <i>l</i>.
      Die anderen Bytes können noch nicht entschlüsselt werden, da die entsprechenden Klartext-Werte noch nicht bekannt sind. Um
      das hinterste unbekannte Byte zu entschlüsseln wird das Padding vergrößert. Dazu werden die letzten <i>l</i> Bytes von <b>O</b>
      so verändert, dass die resultierenden Klartext-Bytes den Wert <i>l+1</i> haben. Der neue Klartext <b>P2</b> wird nun nur gültig,
      wenn die letzten <i>l+1</i> Bytes diesen Wert haben (inklusive des hintersten unbekannten Bytes). Wenn das Padding nicht gültig ist,
      so wird ähnlich wie in Phase 1 versucht, das gewünschte Ergebnis durch Änderung des Overlays <b>O</b> zu erhalten.
      Sobald das Padding gültig wird, kann auch dieses Byte entschlüsselt werden. Dieser Prozess wird nun solange wiederholt, bis
      alle Geheimtext-Bytes entschlüsselt wurden. Danach muss nur noch das Overlay entfernt werden, damit man den
      ursprünglichen Klartext erhält.
    </section></introduction>
  <usage lang="en">
    The Padding Oracle Attack Plugin (POA) has several requirements:
    <list><item>Two 8 byte long ciphertexts as input</item><item>CBC mode: The cipher itself, the key and the IV can be modified, but the cipher has to be run in CBC mode</item><item>Padding Oracle: The output of the POA has to be decrypted (same cipher as during the encryption) and then has to be forwarded to the Padding Oracle Plugin. The output of the Padding Oracle has to be connected to the POA again.</item></list></usage>
  <usage lang="zh-CN">填充Oracle攻击插件（POA）有几个要求：两个8字节长的密文作为inputCBC模式：密码本身，密钥和IV可以修改，但是密码必须以CBC模式运行填充Oracle：必须对POA进行解密（与加密期间的密码相同），然后将其转发到Padding Oracle Plugin。填充Oracle的输出必须再次连接到POA。</usage>
  <usage lang="ru">У Padding Oracle Attack Plugin (POA) есть несколько требований: два 8-байтных зашифрованных текста в режиме ввода: в CBC: сам шифр, ключ и IV могут быть изменены, но шифр должен запускаться в режиме CBC. Падение Oracle: вывод POA необходимо расшифровать (тот же шифр, что и во время шифрования), а затем должен быть перенаправлен в плагин Padding Oracle. Выходной сигнал Padding Oracle должен быть снова подключен к POA.</usage>
  <usage lang="de-de">
    Das Plugin Padding-Orakel-Angriff (POA) hat mehrere Voraussetzungen:
    <list><item>Zwei 8 Byte lange Geheimtextblöcke als Input</item><item>CBC-Modus: Die Chiffre selbst, der Schlüssel und der IV können frei gewählt werden, aber die Chiffre muss in CBC Modus laufen, damit der Angriff funktioniert</item><item>Padding-Orakel: Der Output des POAs muss entschlüsselt werden und dann an das Padding-Orakel-Plugin weitergeleitet werden. Der Output des Padding-Orakels dient dabei wiederum als Inputfaktor für das POA.</item></list></usage>
  <presentation lang="en">
    The presentation is divided into three major parts: input, attack logic and output.<newline />
    1. The input section displays the intercepted ciphertext blocks <b>C1</b> and <b>C2</b> and the response from the padding
    oracle. Only two ciphertext blocks are used during the attack. The second block (<b>C2</b>) contains an
    underlying plaintext, which the attacker tries to ascertain. The first block (<b>C1</b>) is manipulated to
    influence the generation of the plaintext block <b>P2</b>. While the ciphertext blocks remain constant during
    the attack, the response from the padding oracle is variable.
    <newline />
    2.The attack logic displays the data blocks relevant for the attack. This includes the decrypted
    second ciphertext block <b>D2</b>, the first ciphertext block <b>C1</b>, an overlay <b>O</b> and the plaintext
    <b>P2</b>. <b>D2</b> and <b>P2</b> are only completely known at the end of the
    attack. <b>O</b> displays how <b>C1</b> is modified. During the attack, the
    plaintext block <b>P2</b> displays the result of computing an XOR of <b>D2</b>, <b>C1</b> and <b>O</b>.
    Therefore, it reflects which padding is currently generated or targeted.
    Since only one byte is targeted during a step, a pointer indicates which byte is currently
    changed. All data blocks in the presentation have tooltips to allow users to easily access explanations.
    The attack logic also contains a text field which informs about interim results and further actions. The
    actions are triggered by buttons. The button labeled ‘Next’ performs the next step only.
    Occasionally, brute forcing is necessary. Another button, ‘Auto Search’, was included, so
    it is not necessary to click through the complete brute forcing sequence. By clicking this
    button, the currently targeted byte is automatically changed until the wanted value is found. In
    phase 3, up to 7 values have to be brute forced. Therefore, it is possible to decrypt the whole
    message with the button ‘Decrypt Completely’.
    It is also possible to undo steps. The button "&lt;" undoes the last performed step, while the button "&lt;&lt;" 
    goes back to the beginning of the current phase.
    <newline />
    3. The output section displays the first ciphertext block with its current modifications (<b>C1</b> XOR
    <b>O</b>) and the
    second ciphertext block. A counter which reflects the amount of server requests is also
    included.
  </presentation>
  <presentation lang="zh-CN">演示文稿分为三个主要部分：输入，攻击逻辑和输出。 1.输入部分显示截取的密文块C1和C2以及填充预告片的响应。攻击期间仅使用两个密文块。第二个块（C2）包含一个潜在的明文，攻击者试图确定该明文。第一块（C1）被操纵以影响明文块P2的生成。虽然密文块在攻击期间保持不变，但填充预言的响应是可变的。 2.攻击逻辑显示与攻击相关的数据块。这包括解密的第二密文块D2，第一密文块C1，覆盖O和明文P2。仅在攻击结束时才完全知道D2和P2。 O显示如何修改C1。在攻击期间，明文块P2显示计算D2，C1和O的XOR的结果。因此，它反映了当前生成或目标填充的内容。由于在一个步骤中仅将一个字节作为目标，因此指针指示当前更改了哪个字节。演示文稿中的所有数据块都有工具提示，以使用户可以轻松访问说明。攻击逻辑还包含一个文本字段，用于通知临时结果和进一步的操作。这些动作由按钮触发。标有“下一步”的按钮仅执行下一步。有时，强行强制是必要的。包括另一个按钮“自动搜索”，因此无需单击完整的暴力破解顺序。通过单击此按钮，当前目标字节将自动更改，直到找到所需的值为止。在阶段3中，必须强制使用多达7个值。因此，可以使用“完全解密”按钮解密整个消息。也可以撤消步骤。按钮“ &amp;lt;”撤消上一个执行的步骤，而按钮“ &amp;lt;&amp;lt;”返回到当前阶段的开始。 3.输出部分显示第一个密文块及其当前修改（C1 XOR O）和第二个密文块。还包括一个反映服务器请求量的计数器。</presentation>
  <presentation lang="ru">Презентация разделена на три основные части: вход, логика атаки и выход. 1. Секция ввода отображает перехваченные блоки шифрованного текста C1 и C2 и ответ от прописного оракула. Во время атаки используются только два блока зашифрованного текста. Второй блок (C2) содержит базовый открытый текст, который атакующий пытается выяснить. Первый блок (C1) управляется, чтобы влиять на генерацию блока P2 открытого текста. Хотя блоки зашифрованного текста остаются постоянными во время атаки, ответ от прокрутки дополнения является переменным. 2. Логика атаки отображает блоки данных, соответствующие атаке. Это включает в себя расшифрованный второй блок D2 зашифрованного текста, первый блок C1 зашифрованного текста, наложение O и открытый текст P2. D2 и P2 полностью известны в конце атаки. Вывода показывает, как C1 изменен. Во время атаки блок P2 открытого текста отображает результат вычисления XOR из D2, C1 и O. Поэтому он отражает, какое дополнение в настоящее время генерируется или целенаправлено. Поскольку только один байт нацелен во время шага, указатель указывает, какой байт в настоящее время изменен. Все блоки данных в презентации имеют всплывающие подсказки, чтобы пользователи могли легко получить доступ к объяснениям. Логика атаки также содержит текстовое поле, которое информирует о промежуточных результатах и ​​дальнейших действиях. Действия запускаются с помощью кнопок. Кнопка с надписью «Далее» выполняет только следующий шаг. Иногда требуется грубое принуждение. Была добавлена ​​еще одна кнопка «Автоматический поиск», поэтому нет необходимости переходить к полной последовательности принудительного форматирования. Нажимая эту кнопку, текущий адресный байт автоматически изменяется до тех пор, пока не будет найдено требуемое значение. В фазе 3 до 7 значений должны быть принудительно принудительными. Таким образом, можно дешифровать все сообщение с помощью кнопки «Полностью дешифровать». Также можно отменить шаги. Кнопка «&amp;lt;» отменяет последний выполненный шаг, а кнопка «&amp;lt;&amp;lt;» возвращается к началу текущей фазы. 3. В разделе вывода показан первый блок зашифрованного текста с его текущими модификациями (C1 XOR O) и вторым блоком зашифрованного текста. Также включен счетчик, который отражает количество запросов сервера.</presentation>
  <presentation lang="de-de">
    Die präsentation ist in drei Teile unterteilt: Input, Angriffslogik und Output.<newline />
    1. Die Input-Sektion enthält die abgefangenen Geheimtext-Blöcke <b>C1</b> und <b>C2</b> und die Antwort vom Padding-Orakel.
    Während des Angriffs werden nur 2 Geheimtext-Blöcke betrachtet. Der zweite Block <b>C2</b> enthält einen Klartext, den der
    Angreifer ermitteln möchte. Der erste Block <b>C1</b> wird während des Angriffes modifiziert, um die Generierung des
    Klartext-Blockes <b>P2</b> zu beeinflussen. Die Antwort des Padding-Orakels ist der einzige Input, der sich im Laufe des
    Angriffes ändert; die Geheimtext-Blöcke bleiben konstant.
    <newline />
    2. Die Angriffslogik zeigt die für den Angriff relevanten Datenblöcke. Dies umfasst den entschlüsselten Geheimtext-Block <b>D2</b>,
    den ersten Geheimtext-Block <b>C1</b>, das Overlay <b>O</b> und den Klartext <b>P2</b>. <b>D2</b> und <b>P2</b>
    sind erst am Ende des Angriffs vollständig bekannt. <b>O</b> stellt dar, wie <b>C1</b> modifiziert wird. Der Klartext-Block
    <b>P2</b> stellt während des Angriffes die Berechnung des XORs von <b>D2</b>, <b>C1</b> und <b>O</b> dar.
    <b>P2</b> spiegelt dadurch das aktuelle generierte bzw. angezielte Padding wieder.
    Ein sogenannter Pointer zeigt an, welches Byte zur Zeit betrachtet und angepasst wird. Alle Datenblöcke haben Tooltips, die die Bedeutung
    der einzelnen Blöcke erklären. Die Angriffslogik enthält außerdem ein Textfeld, das Informationen zu Zwischenergebnissen oder
    nächste Schritte bereitstellt. Die einzelnen Schritte/Aktionen werden durch Knöpfe (Buttons) ausgelöst. Der Button "Weiter" führt
    nur den nächsten Schritt durch. An einigen Stellen muss Brute-Force angewandt werden. Der Button "Automatische Suche" dient
    dazu, dass man sich nicht durch den ganzen Brute-Force-Ablauf klicken muss. Bei Betätigung des Buttons wird das aktuelle Byte
    so oft geändert, bis das gewünschte Ergebnis erhalten wird. In Phase 3 müssen bis zu 7 Werte mit Brute-Force gefunden werden.
    Aus diesem Grund kann man mit dem Button "Alles Entschlüsseln" die gesamte Nachricht mit einem Klick entschlüsseln.
    Es ist auch möglich, Aktionen rückgängig zu machen. Der Button "&lt;" macht die letzte Aktion rückgängig, während "&lt;&lt;" 
    zum Beginn der aktuellen Phase zurückgeht.
    <newline />
    3. Die Output-Sektion enthält den ersten Geheimtext-Block <b>C1</b> mit den aktuellen Modifikationen
    (<b>C1</b> XOR <b>O</b>) und den unveränderter Geheimtext-Block <b>C2</b>. Ein Zähler stellt die Anzahl der Padding-Orakel-Anfragen (Requests) dar.
  </presentation>
  <references>
    <bookReference id="POA">
      <author>Alexander Juettner</author>
      <name lang="en">
        Analysis of the Functionality, Risks and Counter-Measures of Current
        Padding Attacks and the Implementation of an Attack in the Open Source
        Program CrypTool 2
      </name>
      <name lang="de-DE">
        Analysis of the Functionality, Risks and Counter-Measures of Current
        Padding Attacks and the Implementation of an Attack in the Open Source
        Program CrypTool 2
      </name>
    </bookReference>
    <bookReference id="POA_Vaud">
      <author>Serge Vaudenay</author>
      <publisher lang="en">Springer</publisher>
      <publisher lang="de-DE">Springer</publisher>
      <name lang="en">
        Security Flaws Induced by CBC Padding Applications to SSL, IPSEC, WTLS….
      </name>
      <name lang="de-DE">
        Security Flaws Induced by CBC Padding Applications to SSL, IPSEC, WTLS….
      </name>
    </bookReference>
  </references>
</documentation>