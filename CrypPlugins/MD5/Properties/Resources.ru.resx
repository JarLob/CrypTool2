<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PluginCaption" xml:space="preserve">
    <value>MD5</value>
  </data>
  <data name="PluginTooltip" xml:space="preserve">
    <value>MD5 хэш-функция</value>
  </data>
  <data name="InputDataCaption" xml:space="preserve">
    <value>Входной поток</value>
  </data>
  <data name="InputDataTooltip" xml:space="preserve">
    <value>Входные данные должны быть хэшированы</value>
  </data>
  <data name="OutputDataStreamCaption" xml:space="preserve">
    <value>Значение хеширования</value>
  </data>
  <data name="OutputDataStreamTooltip" xml:space="preserve">
    <value>Выходные данные хешированного значения в виде потока</value>
  </data>
  <data name="OutputDataCaption" xml:space="preserve">
    <value>Значение хеширования</value>
  </data>
  <data name="OutputDataTooltip" xml:space="preserve">
    <value>Выходные данные хешированного значения в виде байтового массива</value>
  </data>
  <data name="End_of_Block__" xml:space="preserve">
    <value>Конец блока &gt;&gt;&gt;&gt;</value>
  </data>
  <data name="End_of_Round__" xml:space="preserve">
    <value>Конец тура &gt;&gt;&gt;</value>
  </data>
  <data name="Next__" xml:space="preserve">
    <value>Следующая &gt;&gt;</value>
  </data>
  <data name="Round_" xml:space="preserve">
    <value>Круглый:</value>
  </data>
  <data name="Step_" xml:space="preserve">
    <value>Шаг:</value>
  </data>
  <data name="We_have_added_the_length_at_the_end_of_our_data_buffer" xml:space="preserve">
    <value>Мы добавили длину в конце нашего буфера данных</value>
  </data>
  <data name="We_have_added_the_padding_bytes_and_our_data_now_looks_like_this" xml:space="preserve">
    <value>Мы добавили байты заполнения, и наши данные теперь выглядят так:</value>
  </data>
  <data name="__Previous" xml:space="preserve">
    <value>&lt;&lt; Предыдущая</value>
  </data>
  <data name="We_now_calculate_the_length_of_our_data" xml:space="preserve">
    <value>Теперь мы вычисляем длину наших данных (без байтов заполнения от предыдущего шага) в битах:</value>
  </data>
  <data name="In_the_next_step" xml:space="preserve">
    <value>На следующем шаге мы пишем малозначное представление этого значения в следующие 8 байтов нашего буфера данных.</value>
  </data>
  <data name="The_algorithm_is_not_yet_initialized" xml:space="preserve">
    <value>Алгоритм еще не инициализирован. Подключите входной поток и запустите поток процесса рабочей области. Убедитесь, что презентация видна, когда подключен плагин MD5.</value>
  </data>
  <data name="We_are_now_starting_round" xml:space="preserve">
    <value>Сейчас мы начинаем раунд</value>
  </data>
  <data name="of_4" xml:space="preserve">
    <value>из 4.</value>
  </data>
  <data name="Each_round_has_16_steps" xml:space="preserve">
    <value>Каждый раунд имеет 16 шагов, которые меняют наши временные переменные A - D.</value>
  </data>
  <data name="There_are_4_non_linear_inner_round_functions" xml:space="preserve">
    <value>Существует 4 нелинейных внутренних круглых функции, называемых F, G, H и I. Они являются центральной частью расчетов, выполненных на каждом шаге. В этом раунде мы используем функцию</value>
  </data>
  <data name="Addition_constant" xml:space="preserve">
    <value>Константа сложения</value>
  </data>
  <data name="After_that__we_append_multiple_zero_bytes_to_our_data_" xml:space="preserve">
    <value>После этого мы добавляем несколько нулевых байтов к нашим данным. Мы выбираем количество нулевых байтов таким образом, чтобы длина полного блока данных была на 8 байт ниже следующего кратного 64. Это позволяет нам добавить еще 8 байтов в данные и достичь точного кратного числа 64 как наша длина данных.</value>
  </data>
  <data name="and_start_the_padding_process_by_appending_one_single__1__bit" xml:space="preserve">
    <value>и запустите процесс заполнения, добавив один единственный бит до конца наших данных. Поскольку мы работаем с октетами, это сводится к добавлению байта с двоичным значением 10000000, что равно шестнадцатеричному значению 0x80, до конца наших данных.</value>
  </data>
  <data name="bytes_in_the_previous_step_" xml:space="preserve">
    <value>байт на предыдущем шаге, мы заключаем, что мы достигли конца наших данных.</value>
  </data>
  <data name="bytes_of_data" xml:space="preserve">
    <value>байт данных.</value>
  </data>
  <data name="bytes_of_data_" xml:space="preserve">
    <value>байт данных.</value>
  </data>
  <data name="bytes_of_data_left_in_our_buffer" xml:space="preserve">
    <value>байт данных, оставшихся в нашем буфере</value>
  </data>
  <data name="Rotating_left_shift" xml:space="preserve">
    <value>Вращающийся сдвиг влево</value>
  </data>
  <data name="Selected_part_from_input_data_block" xml:space="preserve">
    <value>Выбранная часть из блока входных данных</value>
  </data>
  <data name="shifted_by" xml:space="preserve">
    <value>сдвинутый на</value>
  </data>
  <data name="shifted_value" xml:space="preserve">
    <value>сдвинутое значение</value>
  </data>
  <data name="Shift_constant" xml:space="preserve">
    <value>Постоянная сдвига</value>
  </data>
  <data name="Since_we_read_only" xml:space="preserve">
    <value>Поскольку мы читаем только</value>
  </data>
  <data name="So_far__we_have_processed" xml:space="preserve">
    <value>До сих пор мы обработали</value>
  </data>
  <data name="MD5State_Algorithm_uninitialized" xml:space="preserve">
    <value>Алгоритм неинициализирован</value>
  </data>
  <data name="MD5State_Finished_padding" xml:space="preserve">
    <value>Готовое дополнение</value>
  </data>
  <data name="MD5State_Starting_the_compression" xml:space="preserve">
    <value>Запуск сжатия</value>
  </data>
  <data name="MD5State_Starting_a_compression_round" xml:space="preserve">
    <value>Начало раунда сжатия</value>
  </data>
  <data name="MD5State_Before_compression_step" xml:space="preserve">
    <value>До этапа сжатия</value>
  </data>
  <data name="MD5State_Performing_compression_step" xml:space="preserve">
    <value>Выполнение этапа сжатия</value>
  </data>
  <data name="MD5State_Finished_compression_round" xml:space="preserve">
    <value>Готовое сжатие</value>
  </data>
  <data name="MD5State_Finalizing_compression" xml:space="preserve">
    <value>Завершение сжатия</value>
  </data>
  <data name="MD5State_Finished_compression" xml:space="preserve">
    <value>Готовое сжатие</value>
  </data>
  <data name="MD5State_Finished" xml:space="preserve">
    <value>Законченный</value>
  </data>
  <data name="MD5State_Unknown_state" xml:space="preserve">
    <value>Неизвестное состояние</value>
  </data>
  <data name="MD5State_Initialization" xml:space="preserve">
    <value>инициализация</value>
  </data>
  <data name="MD5State_Reading_data" xml:space="preserve">
    <value>Чтение данных</value>
  </data>
  <data name="MD5State_Read_data" xml:space="preserve">
    <value>Чтение данных</value>
  </data>
  <data name="MD5State_Beginning_padding_process" xml:space="preserve">
    <value>Начало процесса заполнения</value>
  </data>
  <data name="MD5State_Adding_the_padding_bytes" xml:space="preserve">
    <value>Добавление байтов заполнения</value>
  </data>
  <data name="MD5State_Added_the_padding_bytes" xml:space="preserve">
    <value>Добавлены байты заполнения</value>
  </data>
  <data name="MD5State_Adding_the_data_length" xml:space="preserve">
    <value>Добавление длины данных</value>
  </data>
  <data name="MD5State_Added_the_data_length" xml:space="preserve">
    <value>Добавлена ​​длина данных</value>
  </data>
  <data name="The_compression_function_of_MD5_processes_data_in_blocks_of_64_bytes_" xml:space="preserve">
    <value>Функция сжатия MD5 обрабатывает данные в блоках по 64 байта. Наша цель - прочитать достаточно данных, которые мы можем сразу вызвать функцию сжатия. Таким образом, мы продолжаем читать как можно больше байтов, пока не получим 64.</value>
  </data>
  <data name="The_compression_function_operates_on_32_bit_integers_" xml:space="preserve">
    <value>Функция сжатия работает с 32-битными целыми числами. Существует 4 временных переменных A, B, C и D, которые используются во время сжатия. Мы инициализируем их значениями из H1 - H4:</value>
  </data>
  <data name="The_data_block_we_have_read_looks_like_this" xml:space="preserve">
    <value>Блок данных, который мы читаем, выглядит следующим образом:</value>
  </data>
  <data name="The_first_thing_we_do_is_initialize_our_accumulators" xml:space="preserve">
    <value>Первое, что мы делаем, это инициализировать наши аккумуляторы до их начальных значений, которые являются фиксированными константами, которые вы можете видеть выше.</value>
  </data>
  <data name="The_variables_H1_H4_are_our_accumulator_variables" xml:space="preserve">
    <value>Переменные H1 - H4 являются нашими переменными аккумулятора. Пока мы выполняем хеш, мы будем менять их после каждого выполнения функции сжатия. Когда мы закончим, они содержат окончательное значение хеша MD5.</value>
  </data>
  <data name="Unsigned_integer_addition_discarding_carry_bit" xml:space="preserve">
    <value>Беззнаковое целочисленное добавление, отбрасывающее бит переноса</value>
  </data>
  <data name="We_also_split_our_512_bit_data_block_into_16_" xml:space="preserve">
    <value>Мы также разделили наш 512-битный блок данных на 16 чисел с маленькими концами, каждый 32 бит:</value>
  </data>
  <data name="We_can_now_begin_the_padding_process_" xml:space="preserve">
    <value>Теперь мы можем начать процесс заполнения, который имеет две цели: • Он дает нам возможность увеличить длину наших данных до тех пор, пока мы снова не будем иметь блоки с длиной в 64 байта. • Он позволяет нам работать с общей длиной данных в конечное значение хэш-функции.</value>
  </data>
  <data name="We_continue_by_calling_the_compression_function_for_this_input" xml:space="preserve">
    <value>Мы продолжаем вызывать функцию сжатия для этого ввода.</value>
  </data>
  <data name="We_continue_by_reading_the_next_block_of_data_" xml:space="preserve">
    <value>Продолжаем чтение следующего блока данных.</value>
  </data>
  <data name="We_have_finished_all_16_steps_of_this_round_" xml:space="preserve">
    <value>Мы закончили все 16 шагов этого раунда.</value>
  </data>
  <data name="We_have_finished_padding_and_have" xml:space="preserve">
    <value>Мы закончили заполнение и</value>
  </data>
  <data name="We_have_finished_with_the_last_round_of_the_compression_" xml:space="preserve">
    <value>Мы закончили последний раунд сжатия. Теперь пришло время обновить наши аккумуляторы. Мы делаем это, просто добавляя к ним переменные A - D.</value>
  </data>
  <data name="We_have_finished_with_the_last_round_of_the_compression_function" xml:space="preserve">
    <value>Мы закончили последний раунд функции сжатия. Чтобы закончить, мы берем результат шагов функции сжатия, наших временных переменных A - D и добавляем их к нашим аккумуляторам H1 - H4.</value>
  </data>
  <data name="We_have_now_finished_compression_of_the_last_block_of_data" xml:space="preserve">
    <value>Теперь мы закончили сжатие последнего блока данных. Наши хэш-накопители выглядят так:</value>
  </data>
  <data name="We_have_read_a_total_of" xml:space="preserve">
    <value>Мы прочитали в общей сложности</value>
  </data>
  <data name="We_now_start_the_compression_function_for_our_next_data_block_" xml:space="preserve">
    <value>Теперь мы начинаем функцию сжатия для нашего следующего блока данных,</value>
  </data>
  <data name="We_obtain_our_final_result_the_actual_MD5_hash_value" xml:space="preserve">
    <value>Мы получаем наш конечный результат, фактическое значение хеш-файла MD5, просто конкатенируя нижестоящее представление наших аккумуляторов:</value>
  </data>
  <data name="We_take_the_incomplete_block_of_data_that_we_ve_read_" xml:space="preserve">
    <value>Мы берем неполный блок данных, который мы читаем,</value>
  </data>
</root>