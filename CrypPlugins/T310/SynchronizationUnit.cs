using System;
using Cryptool.PluginBase;
using System.Linq;

namespace Cryptool.Plugins.T310
{

    /// <summary>
    /// This class handles the initialisation vector F of the algorithm as well as the header bytes of a ciphertext
    /// </summary>
    /// 
    /// It represents the T310 synchronisation unit (Synchronisationseinheit) 
    /// 
    /// The exact purpose is to handle a 25 character (61 bit) initialisation vector F, which is generated by a
    /// randomness generator. It is stored in an Linear Shift Feedback Register (LSFR).
    /// It is processed by XORing it according to the polynom x60 = x5 + x2 + x + 1. 
    public class SynchronizationUnit
    {

        private T310 master;
        private BitSelectorEnum selectorInternal = BitSelectorEnum.Low;
        private RandomnessGenerator rand;

        /// <summary>
        /// Initialize an instance of the T310 synchronization unit (purpose: inizialitation vector and message parsing)
        /// </summary>
        /// <param name="t310Master">the calling plugin function, needed for error messages</param>
        /// <param name="selector">selects if most or least significant bits are selected</param>
        public SynchronizationUnit(T310 t310Master, BitSelectorEnum selector)
        {
            master = t310Master;
            selectorInternal = selector;
            rand = new RandomnessGenerator();
        }


        /*
         * Build the synchronization sequence (33 byte), which starts an encrypted message
         * the structure is as follows:
         *  - 4 characters 0x19 (BBBB)
         *  - 25 characters of random iV (5 bit characters)
         *  - 4 characters of 0x0F (KKKK)
         */
        private byte[] syncSequence = new byte[33];
        public ulong initVector;


        public byte[] InitSync(ulong nonce)
        {

            initVector = RotateInitVectorFull(nonce); // initVector = initialisation vector

            int i = 0;

            
            // Begin the sequence with 4 synchronization characters 0x19 = BBBB
            for (; i < 4; i++)
                syncSequence[i] = 0x19;

            /*
             * Append the 12 characters 
             */
            for (int k = 0; k < 60; k += 5, i++)
                syncSequence[i] = (byte)((nonce >> k) & 0x1f);


            ulong lastBit, syncTemp = nonce, fsLastByte = 0, initBeforeRotate = nonce >> 60;
            for (byte k = 0; k < 4; ++k)
            {
                syncTemp = RotateInitVector(syncTemp);
                lastBit = syncTemp & 0x1000000000000000ul;
                fsLastByte |= lastBit >> (59 - k);
            }
            syncSequence[i++] = (byte)(fsLastByte | initBeforeRotate);

            for (int k = 0; k < 60; k += 5, i++)
                syncSequence[i] = (byte)((initVector >> k) & 0x1f);

            // End the sequence with 4 synchronization characters 0x0F = KKKK
            for (int k = 0; k < 4; k++)
                syncSequence[i + k] = 0x0f;

            return syncSequence;
        }

        ///
        /// Create the header of a ciphertext (Spruch) including the initialization vector 
        ///
        public byte[] InitSync()
        {
            return InitSync(rand.GetRandomBits());
        }

        /// <summary>
        /// Parse a header of a given ciphertext, containing the inizialitation vector.
        /// </summary>
        /// 
        /// Prints the error messages itself.
        /// 
        /// <param name="externSyncSequence"> a ciphertext with proper length (at least 33 byte)</param>
        /// <returns>true on valid sequence, false otherwise</returns>
        public bool ProcessSync(byte[] externSyncSequence)
        {

            // Parse the control characters BBBB (0x19) in the beginning and KKKK (0x0F) at the end 
            if (!(externSyncSequence.Length != 33) &&
                !((externSyncSequence[0] == 0x19) & (externSyncSequence[1] == 0x19) & (externSyncSequence[2] == 0x19) & (externSyncSequence[3] == 0x19) &
                (externSyncSequence[29] == 0x0f) & (externSyncSequence[30] == 0x0f) & (externSyncSequence[31] == 0x0f) & (externSyncSequence[32] == 0x0f)))
            {
                master.GuiLogMessage(T_310.Properties.Resources.ErrorHeaderBytes, NotificationLevel.Error);
                return false;
            }

            ulong nonce = 0;
            for (int i = 16; i > 3; i--)
                nonce = (nonce << 5) | externSyncSequence[i];

            //Recalculate the sync sequence with the nonce.
            InitSync(nonce);

            // If they were not equal we return false
            if (!Enumerable.SequenceEqual(externSyncSequence, syncSequence))
            {
                master.GuiLogMessage(T_310.Properties.Resources.ErrorHeaderIntegrity, NotificationLevel.Error);
                return false;
            }

            return true;
        }


        /// <summary>
        /// Rotate F fully.
        /// </summary>
        /// <param name="f">the initialisation vector</param>
        /// <returns>rotated F</returns>
        public ulong RotateInitVectorFull(ulong f)
        {
            for (int i = 0; i <= 64; i++)
                f = RotateInitVector(f);
            return f;
        }


        /// <summary>
        /// Rotate F once
        /// </summary>
        /// <param name="f">the initialisation vector</param>
        /// <returns>single rotated F</returns>
        public ulong RotateInitVector(ulong f)
        {
            ulong bit = (f ^ (f >> 1) ^ (f >> 2) ^ (f >> 5)) & 1;
            return (f >> 1) | (bit << 60);
        }


        /// <summary>
        /// Get a bit from the vector
        /// </summary>
        /// <returns>a byte with 0 or 1</returns>
        public byte GetFBit()
        {
            int shift = selectorInternal == BitSelectorEnum.High ? 60 : 0;
            byte value = (byte)((initVector >> shift) & 0x01);
            RotateInitVector(initVector);
            return value;
        }
    }


    /// This class provides a randomness generator simulation
    /// It represents the T310 psuedo random generator (Pseudozufallsgenerator)
    /// 
    /// 
    /// Note that in the original machine in version T310/50 a real noise generator would be used
    /// to provide the randomness. In the version /51 the randomness comes from pulling out the punched cards
    /// contianing the keys. This source of randomness is of course not as good as a noise generator.
    public class RandomnessGenerator
    {
        /// <summary>
        /// Provide 61 random bits. The high bits 62-64 of the ulong are always zero
        /// </summary>
        /// <returns>A ulong containing 61 bits starting from the least significant bit</returns>
        public ulong GetRandomBits()
        {
           Random rand = new Random();

            ulong r;
            byte[] bytes = new byte[8];

            while (true)
            {
                rand.NextBytes(bytes);
                r = BitConverter.ToUInt64(bytes, 0) & 0x1fffffffffffffff;    // mask the high bits 0
                if (r != 0ul) return r;
            }

        }

    }

   

}
