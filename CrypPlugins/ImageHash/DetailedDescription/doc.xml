<?xml version="1.0" encoding="utf-8"?>
<documentation>
  <language culture="en" />
  <language culture="zh-CN" />
  <language culture="ru" />
  <language culture="de-DE" />
  <introduction lang="en">
    This component enables the user to hash a selected image via a robust block hash.
    Those Block hashes are widely used image hash functions. Usually multiple images are compared via the hamming distance of their image hash values. That can be of interest for example to find similar images on the internet or to find doublicate frames in video streams.

    <section headline="History">
      This block hash was described in a presentation by Dr. Martin Steinebach of the Fraunhofer SIT in 2011.
    </section><section headline="Algorithm">
      The block hash is one in a series of image hash functions designed to map images to a value computers can use. This hash value is typically 256-bit long, but this algorithm allows the user to change the length.
      The block hash is calculated following these steps:
      <newline />
      The first step is gray scaling the original image. (This is realized with OpenCV through the wrapper EmguCV.) In the second step, the gray image is resized square to the input size. The third step is calculating the absolute brightness of each quarter of the picture. The image is flipped, so that the brightest quarter becomes the upper left corner. In the next step, the median is calculated for each quarter. That is the average brightness of the pixels. Each pixel is now set to white if its brightness is above the median of its quarter and black if not. This produces the resulting black and white hash image.
      These black and white pixels contain the information 0 and 1. These bits are put into an array. 8 bits are put into one byte. The first 8 bits yield the first byte. The first bit yields the lowest value of that byte (2^0), the last bit yields the highest value (2^7). The actual hash is the resulting byte array.
      <newline /><newline /><img src="ImageHash/DetailedDescription/steps.png" /></section></introduction>
  <introduction lang="zh-CN">该组件使用户能够通过鲁棒的块哈希来哈希选定的图像。这些块哈希是广泛使用的图像哈希函数。通常，通过图像散列值的汉明距离来比较多个图像。例如，在互联网上查找相似图像或在视频流中查找双重帧时，可能会对此感兴趣。 Fraunhofer SIT的Martin Steinebach博士在2011年的一次演讲中描述了该块哈希。该块哈希是一系列图像哈希函数中的一个，这些函数旨在将图像映射到计算机可以使用的值。该哈希值通常为256位长，但是该算法允许用户更改长度。块哈希是按照以下步骤计算的：第一步是对原始图像进行灰度缩放。 （这是通过包装程序EmguCV用OpenCV实现的。）在第二步中，将灰色图像的大小调整为输入大小的正方形。第三步是计算图片每四分之一的绝对亮度。图像被翻转，因此最亮的四分之一变为左上角。在下一步中，将计算每个季度的中位数。那就是像素的平均亮度。如果每个像素的亮度高于其四分之一的中值，则现在将其设置为白色，否则将其设置为黑色。这将产生最终的黑白哈希图像。这些黑白像素包含信息0和1。这些位放入数组中。 8位放入一个字节。前8位产生第一个字节。第一位产生该字节的最小值（2 ^ 0），最后一位产生最高值（2 ^ 7）。实际的哈希是结果字节数组。</introduction>
  <introduction lang="ru">Этот компонент позволяет пользователю хэшировать выбранное изображение с помощью надежного хеша блока. Эти хэши блока широко используются хэш-функции изображения. Обычно несколько изображений сравниваются по расстоянию хамминга их хэш-значений изображения. Это может представлять интерес, например, для поиска похожих изображений в Интернете или для поиска дублирующих кадров в видеопотоках. Этот хеш-блок был описан в презентации д-ра Мартина Штейнебаха из SIT Fraunhofer SIT в 2011 году. Хеш-блок является одним из целого ряда хэш-функций изображения, предназначенных для сопоставления изображений с ценными компьютерами. Это хеш-значение обычно составляет 256-битное, но этот алгоритм позволяет пользователю изменять длину. Хэш блока вычисляется следующим образом: Первый шаг - это серое масштабирование исходного изображения. (Это реализовано с помощью OpenCV через оболочку EmguCV.) На втором этапе серое изображение изменяется на квадрат до размера ввода. Третий шаг - вычисление абсолютной яркости каждой четверти изображения. Изображение перевернуто, так что самая яркая четверть становится верхним левым углом. На следующем этапе медиана рассчитывается для каждого квартала. Это средняя яркость пикселей. Каждый пиксель теперь установлен на белый, если его яркость выше медианы его квартала и черного цвета, если нет. Это приводит к появлению черно-белого хеш-изображения. Эти черно-белые пиксели содержат информацию 0 и 1. Эти биты помещаются в массив. 8 бит помещаются в один байт. Первые 8 бит дают первый байт. Первый бит дает наименьшее значение этого байта (2 ^ 0), последний бит дает наивысшее значение (2 ^ 7). Фактический хеш - это результирующий массив байтов.</introduction>
  <introduction lang="de-DE">
    Dieser Komponent ermöglicht es dem Nutzer ein ausgewähltes Bild zu hashen, mittels eines robusten Blockhashes. Diese Blockhashes sind häufig genutzte Bild-Hasherfahren. Meist werden mehrere Bilder mittels Hamming Distanz anhand ihrer Bild-Hashwerte verglichen. Das kann von Interesse sein, wenn man zum Beispiel gleiche Bilder im Internet finden möchte oder doppelte Einzelbilder in Videos.
    <section headline="Geschichte">
      Dieser Blockhash wurde in einer Präsentation von Dr. Martin Steinebach des Fraunhofer SIT in 2011 beschrieben.
    </section><section headline="Algorithmus">
      Der Blockhash ist einer aus einer Reihe von Bild-Hashfunktionen, die dazu genutzt werden Bilder einem von Computern nutzbaren Wert zuzuordnern. Solch ein Hashwert ist typischer Weise 256-Bit lang, aber dieser Algorithmus erlaubt dem Nutzer diese Länge zu verändern.
      <newline />
      Der Blockhash wird mittels der folgenden Schritte berechnet:
      <newline /><newline />
      Zuerst wird das Originalbild grau eingefärbt. (Realisiert mittels OpenCV durch den Wrapper EmguCV.) Im zweiten Schritt wird das graue Bild auf das Quadrat der eingegebenen Größe skaliert. Der dritte Schritt ist die Berechnung der Gesamthelligkeit jedes Viertels. Das Bild wird so oft gespiegelt, bis sich das hellste Viertel oben links befindet. Im nächsten Schritt wird der Mittelwert jedes Viertels berechnet. Dies ist die durchschnittliche Helligkeit der Pixel. Jeder Pixel wird jetzt auf Weiß gesetzt, falls seine Helligkeit über dem Mittelwert seines Viertels ist und Schwarz falls nicht. Dadurch entsteht das resultierende Schwarz-Weißbild.
      Diese schwarzen und weißen Pixel enthalten die Informationen 0 und 1. Diese Bits werden in einem Array gespeichert. 8 Bits werden zu einem Byte. Die ersten 8 Bits ergeben das erste Byte. Das erste Bit ergibt den niedrigsten Wert dieses Bytes (2^0), das letzte Bit ergibt den höchsten Wert (2^7). Der eigentliche Hash ist das resultierende Byte Array.
      <newline /><newline /><img src="ImageHash/DetailedDescription/steps.png" /></section></introduction>
  <usage lang="en">
    The ImageHash component has only one input connector, where it expects an image as data stream as input. The output exists of two output connectors. One is the hashed image as a data stream. The user can use the image output component to view this resulting image. The other output is a byte array. This is the actual hash. It can be connected to the text output component or directly used in the hamming distance component.
    The interface of the ImageHash component allows the user to change some settings:
    <newline /><newline /><b>Size:</b><newline />
    The standard size of the resulting image is 16x16 pixels, which results in a hash size of 256-bit. The resulting image is always a square image. (More specific, the total amount of pixels of the resulting image has to be a power of two. That is necessary because otherwise one count index runs out of bounds.) The default side length of 16 pixels is shown in a textbox, which is editable by the user. This size is limited to the range of 4 to 128 pixels. Less then 4 pixels is simply to small to be very useful. The upper threshold is implemented due to the processing time. Calculating the accumulated brightness of the four quarters takes much time. Using pixel amounts above 128 pixels destroys the user experience.
    <newline /><newline /><b>Output format:</b><newline />
    The user may select Bmp, Png and Tiff as the output format. That changes the format of the output stream that is created. The standard is Bmp.
    <newline /><newline /><b>Show each step:</b><newline />
    This checkbox is unchecked by default. Therefore the only output stream that is created is the one of the resulting black and white image. If this box is checked, every step of the hashing process is directly put into an output stream and handed to the output connector. This may cause flickering, because most steps are processed very quick. This option gets more interesting, if the user chooses a very large size. Then he may watch where the processing takes the most time.
    <newline /><newline /><b>Slider:</b><newline />
    This slider makes the whole hashing process much more vibrant. By sliding it, the user may quickly switch through the steps of the hashing process. If the slider is set to step 3 before starting the calculation for example then step 4 is not shown. After the calculation (while still in running mode) the slider can be moved to watch the image of every step.
  </usage>
  <usage lang="zh-CN">ImageHash组件只有一个输入连接器，它希望将图像作为数据流作为输入。输出存在两个输出连接器。一种是散列图像作为数据流。用户可以使用图像输出组件查看此结果图像。另一个输出是字节数组。这是实际的哈希。它可以连接到文本输出组件，也可以直接在汉明距离组件中使用。 ImageHash组件的界面允许用户更改某些设置：大小：生成的图像的标准大小为16x16像素，这导致256位的哈希大小。结果图像始终是正方形图像。 （更具体地说，结果图像的像素总数必须为2的幂。这是必需的，因为否则一个计数索引就会超出范围。）文本框显示了默认的16像素边长，即用户可以编辑。此大小限制为4到128像素。少于4像素只是小到非常有用。由于处理时间的原因实现了上限。计算四个季度的累积亮度需要很多时间。使用超过128个像素的像素数量会破坏用户体验。输出格式：用户可以选择Bmp，Png和Tiff作为输出格式。这将更改所创建的输出流的格式。标准是Bmp。显示每个步骤：默认情况下未选中此复选框。因此，唯一创建的输出流是生成的黑白图像之一。如果选中此框，则哈希处理的每个步骤都将直接放入输出流中，并传递给输出连接器。这可能会导致闪烁，因为大多数步骤都处理得非常快。如果用户选择非常大的尺寸，则此选项将变得更加有趣。然后，他可能会看到处理时间最多的地方。滑块：此滑块使整个哈希过程更加活跃。通过滑动它，用户可以快速切换哈希过程的各个步骤。例如，如果在开始计算之前将滑块设置为步骤3，则不会显示步骤4。计算后（仍处于运行模式下），可以移动滑块以观看每个步骤的图像。</usage>
  <usage lang="ru">Компонент ImageHash имеет только один входной разъем, где он ожидает изображение как поток данных в качестве входного. Выход имеет два выходных разъема. Один из них - хешированное изображение как поток данных. Пользователь может использовать компонент вывода изображения для просмотра полученного результирующего изображения. Другой выход представляет собой массив байтов. Это фактический хеш. Он может быть подключен к компоненту вывода текста или напрямую использоваться в компоненте расстояния для помех. Интерфейс компонента ImageHash позволяет пользователю изменять некоторые параметры: Размер: стандартный размер результирующего изображения составляет 16x16 пикселей, что приводит к размеру хэша 256-битной. Полученное изображение всегда представляет собой квадратное изображение. (Более конкретно, общее количество пикселей результирующего изображения должно быть равным двум. Это необходимо, потому что в противном случае один индекс счетчика выходит за рамки.) Длина стороны по умолчанию 16 пикселей отображается в текстовом поле, которое равно редактируемый пользователем. Этот размер ограничен диапазоном от 4 до 128 пикселей. Меньше, чем 4 пикселя, это просто мало, чтобы быть очень полезным. Верхний порог реализуется за счет времени обработки. Вычисление накопленной яркости четырех четвертей занимает много времени. Использование пикселей выше 128 пикселей разрушает работу пользователя. Формат вывода: пользователь может выбрать Bmp, Png и Tiff в качестве выходного формата. Это изменяет формат создаваемого потока вывода. Стандартом является Bmp. Показывать каждый шаг: этот флажок по умолчанию не установлен. Поэтому единственный выходной поток, который создается, является одним из полученных черно-белых изображений. Если этот флажок установлен, каждый шаг процесса хэширования напрямую помещается в выходной поток и передается на выходной разъем. Это может вызвать мерцание, потому что большинство шагов обрабатываются очень быстро. Эта опция становится более интересной, если пользователь выбирает очень большой размер. Затем он может посмотреть, где обработка занимает больше всего времени. Ползунок: этот слайдер делает весь процесс хэширования более ярким. Сдвинув его, пользователь может быстро переключиться на шаги процесса хеширования. Если ползунок установлен на шаг 3 перед началом вычисления, то, например, шаг 4 не отображается. После вычисления (пока все еще в режиме работы) ползунок можно перемещать для просмотра изображения каждого шага.</usage>
  <usage lang="de-DE">
    Die BildHash Komponente hat nur einen Eingabe-Konnektor, an dem sie ein Bild als Datenstrom als Eingabe erwartet. Die Ausgabe besteht aus zwei Konnektoren. Einer ist das Hashbild als Datenstrom. Der Nutzer kann die Bildausgabe Komponente nutzen um dieses resultierende Bild anzuschauen. Der andere Ausgabe-Konnektor ist ein Byte Array. Dies ist der eigentliche Hash. Der Konnektor kann direkt mit der Textausgabe Komponente verbunden werden oder in der Hamming Distanz Komponente verwendet werden.
    Das Interface der BildHash Komponente erlaubt dem Nutzer einige Einstellungen vorzunehmen:
    <newline /><newline /><b>Größe:</b><newline />
    Die Standardgröße des resultierenden Bildes ist 16x16 Pixel, welche in einen Hash der Größe 256-Bit resultiert. Das resultierende Bild ist immer quadratisch. (Genauer gesagt ist die Gesamtanzahl der Pixel des resultierenden Bildes immer eine Zweierpotenz. Das ist notwendig, da sonst ein Zählerindex aus den Grenzen läuft.) Die Standard-Seitenlänge von 16 Pixeln wird in einer Textbox angezeigt, die vom Nutzer verändert werden kann. Diese Größe ist begrenzt von 4 bis 128 Pixeln. Weniger als 4 Pixel ist schlichtweg nicht mehr nützlich. Die obere Grenze ist implementiert wegen der Verarbeitungszeit. Die Berechnung der Gesamthelligkeit der vier Viertel kostet viel Zeit. Werden mehr als 128 Pixel verwendet beeinträchtigt das die Nutzererfahrung.
    <newline /><newline /><b>Ausgabedateiformat:</b><newline />
    Der Nutzer darf zwischen Bmp, Png und Tiff als Ausgabeformat wählen. Dadurch ändert sich das Format des Ausgabe-Datenstroms der erzeugt wird. Der Standard ist Bmp.
    <newline /><newline /><b>Jeden Schritt anzeigen:</b><newline />
    Dieses Kontrollkästchen ist standardmäßig nicht markiert. Dadurch wird ist der einzige Ausgabe-Datenstrom der erzeugt wird der des resultierenden Schwarz-Weißbildes. Wenn dieses Kästchen markiert ist wird jeder Schritt des Hashverfahrens direkt zu einem Ausgabe-Datenstrom verarbeitet und an den Ausgabe-Konektor weiter gegeben. Dadurch kann ein Flackern entstehen, denn die meisten Schritte werden sehr schnell verarbeitet. Diese Einstellung ist eher dann interessant, wenn der Nutzer sehr große Größen auswählt. Dann kann er beobachten, wo die Verarbeitung am längsten dauert.
    <newline /><newline /><b>Schieberegler:</b><newline />
    Dieser Schieberegler macht das gesamte Hashverfahren sehr viel lebendiger. Durch schieben kann der Nutzer sehr schnell die einzelnen Schritte des Hashverfahrens durchwechseln. Wenn der Schieberegler vor der Berechnung zum Beispiel auf Schritt 3 geschoben wird, so wird Schritt 4 gar nicht erst angezeigt. Nach der Berechnung (während die Komponente noch läuft) kann der Schieberegler beliebig verschoben werden um die einzelnen Schritte zu sehen.
  </usage>
  <references>
    <linkReference id="wikipedia">
      <link url="http://www.anwendertag-forensik.de/content/dam/anwendertag-forensik/de/documents/2011/Vortrag_Steinebach.pdf" lang="en" />
      <caption lang="en">Robust Hashs for forensic image recognition</caption>
      <link url="http://www.anwendertag-forensik.de/content/dam/anwendertag-forensik/de/documents/2011/Vortrag_Steinebach.pdf" lang="de-DE" />
      <caption lang="de-DE">Robuste Hashes zur forensischen Bilderkennung</caption>
    </linkReference>
  </references>
</documentation>