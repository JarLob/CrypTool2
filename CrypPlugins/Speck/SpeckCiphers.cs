using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Speck
{
    public static class SpeckCiphers
    {
        #region Speck32/xx

        /// <summary>
        /// Speck32/64 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck32_64_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck32/64 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck32_64_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Speck48/xx

        /// <summary>
        /// Speck48/72 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck48_72_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck48/72 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck48_72_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck48/96 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck48_96_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck48/96 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck48_96_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Speck64/xx

        /// <summary>
        /// Speck64/96 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck64_96_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck64/96 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck64_96_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck64/128 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck64_128_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck64/128 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck64_128_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Speck96/xx

        /// <summary>
        /// Speck96/96 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck96_96_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck96/96 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck96_96_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck96/144 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck96_144_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck96/144 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck96_144_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Speck128/xx

        /// <summary>
        /// Speck128/128 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck128_128_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck128/128 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck128_128_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck128/192 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck128_192_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck128/192 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck128_192_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck128/256 with encryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck128_256_Encryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Speck128/256 with decryption mode
        /// </summary>
        /// <param name="text"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public static byte[] Speck128_256_Decryption(byte[] text, byte[] key)
        {
            throw new NotImplementedException();
        }

        #endregion



        #region BytesToWordsRegion

        /// <summary>
        /// Converts bytes to wordCount input words
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="wordCount"></param>
        /// <returns></returns>
        private static UInt16[] BytesToWords16(byte[] bytes, int wordCount)
        {
            UInt16[] words = new UInt16[wordCount];

            int i, j = 0;
            for (i = 0; i < bytes.Length / 2; i++)
            {
                words[i] = (UInt16)(bytes[j] | (bytes[j + 1] << 8));
                j += 2;
            }

            return words;
        }

        /// <summary>
        /// Converts bytes to wordCount input words
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="wordCount"></param>
        /// <returns></returns>
        private static UInt32[] BytesToWords24(byte[] bytes, int wordCount)
        {
            UInt32[] words = new UInt32[wordCount];

            int i, j = 0;
            for (i = 0; i < bytes.Length / 3; i++)
            {
                words[i] = bytes[j] | ((uint)bytes[j + 1] << 8) | ((uint)bytes[j + 2] << 16);
                j += 3;
            }

            return words;
        }

        /// <summary>
        /// Converts bytes to wordCount input words
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="wordCount"></param>
        /// <returns></returns>
        private static UInt32[] BytesToWords32(byte[] bytes, int wordCount)
        {
            UInt32[] words = new UInt32[wordCount];

            int i, j = 0;
            for (i = 0; i < bytes.Length / 4; i++)
            {
                words[i] = bytes[j] | ((UInt32)bytes[j + 1] << 8) | ((UInt32)bytes[j + 2] << 16) |
                           ((UInt32)bytes[j + 3] << 24);
                j += 4;
            }

            return words;
        }

        /// <summary>
        /// Converts bytes to wordCount input words
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="wordCount"></param>
        /// <returns></returns>
        private static UInt64[] BytesToWords48(byte[] bytes, int wordCount)
        {
            UInt64[] words = new UInt64[wordCount];

            int i, j = 0;
            for (i = 0; i < (bytes.Length / 6); i++)
            {
                words[i] = bytes[j] | ((UInt64)bytes[j + 1] << 8) | ((UInt64)bytes[j + 2] << 16) |
                           ((UInt64)bytes[j + 3] << 24) | ((UInt64)bytes[j + 4] << 32) |
                           ((UInt64)bytes[j + 5] << 40);
                j += 6;
            }

            return words;
        }

        /// <summary>
        /// Converts bytes to wordCount input words
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="wordCount"></param>
        /// <returns></returns>
        private static UInt64[] BytesToWords64(byte[] bytes, int wordCount)
        {
            UInt64[] words = new UInt64[wordCount];

            int i, j = 0;
            for (i = 0; i < (bytes.Length / 8); i++)
            {
                words[i] = bytes[j] | ((UInt64)bytes[j + 1] << 8) | ((UInt64)bytes[j + 2] << 16) |
                           ((UInt64)bytes[j + 3] << 24) | ((UInt64)bytes[j + 4] << 32) |
                           ((UInt64)bytes[j + 5] << 40) | ((UInt64)bytes[j + 6] << 48) |
                           ((UInt64)bytes[j + 7] << 56);
                j += 8;
            }

            return words;
        }

        #endregion

        #region WordsToBytesRegion

        /// <summary>
        /// Converts numWords words to a byte array
        /// </summary>
        /// <param name="words"></param>
        /// <param name="numWords"></param>
        /// <returns></returns>
        private static byte[] Words16ToBytes(UInt16[] words, int numWords)
        {
            byte[] result = new byte[numWords * sizeof(UInt16)];

            int i, j = 0;
            for (i = 0; i < numWords; i++)
            {
                result[j] = (byte)words[i];
                result[j + 1] = (byte)(words[i] >> 8);
                j += 2;
            }

            return result;
        }

        /// <summary>
        /// Converts numWords words to a byte array
        /// </summary>
        /// <param name="words"></param>
        /// <param name="numWords"></param>
        /// <returns></returns>
        private static byte[] Words24ToBytes(UInt32[] words, int numWords)
        {
            byte[] result = new byte[numWords * 3];

            int i, j = 0;
            for (i = 0; i < numWords; i++)
            {
                result[j] = (byte)words[i];
                result[j + 1] = (byte)(words[i] >> 8);
                result[j + 2] = (byte)(words[i] >> 16);
                j += 3;
            }

            return result;
        }

        /// <summary>
        /// Converts numWords words to a byte array
        /// </summary>
        /// <param name="words"></param>
        /// <param name="numWords"></param>
        /// <returns></returns>
        private static byte[] Words32ToBytes(UInt32[] words, int numWords)
        {
            byte[] result = new byte[numWords * sizeof(UInt32)];

            int i, j = 0;
            for (i = 0; i < numWords; i++)
            {
                result[j] = (byte)words[i];
                result[j + 1] = (byte)(words[i] >> 8);
                result[j + 2] = (byte)(words[i] >> 16);
                result[j + 3] = (byte)(words[i] >> 24);
                j += 4;
            }

            return result;
        }

        /// <summary>
        /// Converts numWords words to a byte array
        /// </summary>
        /// <param name="words"></param>
        /// <param name="numWords"></param>
        /// <returns></returns>
        private static byte[] Words48ToBytes(UInt64[] words, int numWords)
        {
            byte[] result = new byte[numWords * 6];

            int i, j = 0;
            for (i = 0; i < numWords; i++)
            {
                result[j] = (byte)words[i];
                result[j + 1] = (byte)(words[i] >> 8);
                result[j + 2] = (byte)(words[i] >> 16);
                result[j + 3] = (byte)(words[i] >> 24);
                result[j + 4] = (byte)(words[i] >> 32);
                result[j + 5] = (byte)(words[i] >> 40);
                j += 6;
            }

            return result;
        }

        /// <summary>
        /// Converts numWords words to a byte array
        /// </summary>
        /// <param name="words"></param>
        /// <param name="numWords"></param>
        /// <returns></returns>
        private static byte[] Words64ToBytes(UInt64[] words, int numWords)
        {
            byte[] result = new byte[numWords * sizeof(UInt64)];

            int i, j = 0;
            for (i = 0; i < numWords; i++)
            {
                result[j] = (byte)words[i];
                result[j + 1] = (byte)(words[i] >> 8);
                result[j + 2] = (byte)(words[i] >> 16);
                result[j + 3] = (byte)(words[i] >> 24);
                result[j + 4] = (byte)(words[i] >> 32);
                result[j + 5] = (byte)(words[i] >> 40);
                result[j + 6] = (byte)(words[i] >> 48);
                result[j + 7] = (byte)(words[i] >> 56);
                j += 8;
            }

            return result;
        }

        #endregion
    }
}
