//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LatticeCrypto.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class HelpLanguages {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal HelpLanguages() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("LatticeCrypto.Properties.HelpLanguages", typeof(HelpLanguages).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Angle between to vectors&lt;/h2&gt;
        ///&lt;p&gt;
        ///    The angle &amp;theta; between two vectors is given by:&lt;/p&gt;
        ///&lt;p&gt;
        ///    &lt;img src=&quot;ImgAngleVectors&quot; /&gt;
        ///&lt;/p&gt;
        ///
        ///&lt;p&gt;Compare the angle between the non-reduced and the reduced vectors. The reduced vectors approach to the 90 ° angle.&lt;/p&gt;
        ///
        /// ähnelt.
        /// </summary>
        public static string AngleVectors {
            get {
                return ResourceManager.GetString("AngleVectors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Back  ähnelt.
        /// </summary>
        public static string btnBack {
            get {
                return ResourceManager.GetString("btnBack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Close ähnelt.
        /// </summary>
        public static string btnClose {
            get {
                return ResourceManager.GetString("btnClose", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Forward ähnelt.
        /// </summary>
        public static string btnForward {
            get {
                return ResourceManager.GetString("btnForward", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Codomain&lt;/h2&gt;
        ///&lt;p&gt;
        ///    &lt;span id=&quot;result_box&quot; class=&quot;&quot; lang=&quot;en&quot;&gt;&lt;span class=&quot;hps&quot;&gt;At this point please 
        ///    enter&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;a valid&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;codomain.&lt;/span&gt;
        ///    &lt;span class=&quot;hps alt-edited&quot;&gt;Please note&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;that only&lt;/span&gt;
        ///    &lt;span class=&quot;hps&quot;&gt;integers&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;are allowed.&lt;/span&gt;
        ///    &lt;span class=&quot;hps alt-edited&quot;&gt;In addition&lt;/span&gt;&lt;span class=&quot;&quot;&gt;, the value of 
        ///    &amp;quot;From&amp;quot; must be less than the value of &amp;quot;To&amp;quot;.&lt; [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string Codomain {
            get {
                return ResourceManager.GetString("Codomain", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Codomain&lt;/h2&gt;
        ///&lt;p&gt;
        ///    &lt;span id=&quot;result_box&quot; class=&quot;&quot; lang=&quot;en&quot;&gt;&lt;span class=&quot;hps&quot;&gt;At this point please 
        ///    enter&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;a valid&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;codomain.&lt;/span&gt;
        ///    &lt;span class=&quot;hps alt-edited&quot;&gt;Please note&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;that only&lt;/span&gt;
        ///    &lt;span class=&quot;hps&quot;&gt;integers&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;are allowed.&lt;/span&gt;
        ///    &lt;span class=&quot;hps alt-edited&quot;&gt;In addition&lt;/span&gt;&lt;span class=&quot;&quot;&gt;, the value of 
        ///    &amp;quot;From&amp;quot; must be less than the value of &amp;quot;To&amp;quot;.&lt; [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string CodomainLLL {
            get {
                return ResourceManager.GetString("CodomainLLL", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Closest Vector Problem (CVP)&lt;/h2&gt;
        ///&lt;p&gt;
        ///    
        ///The closest vector problem is beside the
        ///    &lt;a href=&quot;help://SVP&quot;&gt;Shortest Vector Problem&lt;/a&gt; an&amp;nbsp;interesting problem 
        ///    associated with lattices. &lt;span id=&quot;result_box&quot; class=&quot;&quot; lang=&quot;en&quot;&gt;
        ///    &lt;span class=&quot;hps&quot;&gt;A &lt;a href=&quot;help://TargetPoint&quot;&gt;target point&lt;/a&gt;&lt;/span&gt;
        ///    &lt;span class=&quot;hps alt-edited&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;&quot;&gt;, which is located&lt;/span&gt;
        ///    &lt;span class=&quot;hps&quot;&gt;within the&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;vector space&lt;/span&gt;&lt;span&gt;, 
        ///    but&lt;/spa [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string CVP {
            get {
                return ResourceManager.GetString("CVP", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Lattice determinant&lt;/h2&gt;
        ///&lt;p&gt;
        ///    The vectors of the basis create a parallelepiped P (a parallelogram in two-dimensional space). This is the fundamental domain of the lattice and is defined as follows:&lt;/p&gt;
        ///    
        ///&lt;img src=&quot;ImgDeterminantLattice&quot; /&gt;
        ///
        ///&lt;p&gt;The lattice determinant is the volume of the parallelepiped and can also be understood as the absolute value of the determinant of the basis matrix.:&lt;/p&gt;
        ///&lt;img src=&quot;ImgDeterminantLattice2&quot; /&gt;
        ///
        ///&lt;p&gt;The lattice determinat is independent of the choice of [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string DeterminantLattice {
            get {
                return ResourceManager.GetString("DeterminantLattice", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Dimension&lt;/h2&gt;
        ///&lt;p&gt;
        ///    &lt;span id=&quot;result_box&quot; class=&quot;&quot; lang=&quot;en&quot;&gt;&lt;span class=&quot;hps&quot;&gt;At this point please 
        ///    enter&lt;/span&gt; the d&lt;/span&gt;imension of the matrix w&lt;span id=&quot;result_box0&quot; 
        ///        class=&quot;&quot; lang=&quot;en&quot;&gt;&lt;span class=&quot;hps&quot;&gt;hich&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;
        ///    represents the basis&lt;/span&gt;&lt;/span&gt;. &lt;span id=&quot;result_box1&quot; class=&quot;&quot; lang=&quot;en&quot;&gt;
        ///    &lt;span class=&quot;hps&quot;&gt;The matrix&lt;/span&gt; &lt;span class=&quot;hps&quot;&gt;is&lt;/span&gt;
        ///    &lt;span class=&quot;hps&quot;&gt;square&lt;/span&gt;&lt;/span&gt;. &lt;span id=&quot;result_box2&quot; class=&quot;&quot; 
        ///        lang=&quot;e [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string DimensionLLL {
            get {
                return ResourceManager.GetString("DimensionLLL", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Gauss algorithm&lt;/h2&gt;
        ///&lt;p&gt;
        ///    In a lattice in two-dimensional space the Gaussian algorithm finds reliably a 
        ///    shortest vector. It works similar to the Euclidean algorithm for the greatest 
        ///    common divisor gcd of two integers, because after each step, the basis improves 
        ///    by a shorter vector. In this case the longer vector b2 is iteratively subtracted 
        ///    by an integer multiple of the shorter vector b1. The subtrahend is the component 
        ///    of b2 which points in the direction of b1 (see fi [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string Gauss {
            get {
                return ResourceManager.GetString("Gauss", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;GGH Crypto System&lt;/h2&gt;
        ///
        ///&lt;p&gt;
        ///The GGH cryptosystem is based on the hypothesis, that it is very easy to construct a vector from a basis B and a small error vector e, that lies in the vector space V and is close to a lattice point in the lattice L.
        ///On the other hand, it is very hard to reconstruct the original lattice point lying close to the vector if only the vector is known.
        ///If one could find a very small basis, the search for the original lattice point would be much easier.
        ///This problem correspond [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string GGH {
            get {
                return ResourceManager.GetString("GGH", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap ImgSuccessiveMinimaEng {
            get {
                object obj = ResourceManager.GetObject("ImgSuccessiveMinimaEng", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Length of a vector&lt;/h2&gt;
        ///&lt;p&gt;
        ///    The length of a vector v can be computed with:&lt;/p&gt;
        ///    
        ///&lt;img src=&quot;ImgLengthVector&quot; /&gt;
        ///
        ///&lt;p&gt;Compare the lengths of the basis vectors with the 
        ///    &lt;a href=&quot;help://SuccessiveMinima&quot;&gt;successive minima&lt;/a&gt; after reduction.&lt;/p&gt; ähnelt.
        /// </summary>
        public static string LengthVector {
            get {
                return ResourceManager.GetString("LengthVector", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;LLL algorithm&lt;/h2&gt;
        ///&lt;p&gt;
        ///    Unlike the Gaussian algorithm, which operates in the 2-dimensional case, the LLL 
        ///    algorithm outputs a &lt;a href=&quot;help://SVP&quot;&gt;shortest vector&lt;/a&gt; in n-dimensional space. However, the 
        ///    shortest vector is not always the shortest actually, but often a very short 
        ///    vector. This restriction has the advantage that the algorithm works in 
        ///    polynomial time, so a good solution can be found quickly.&lt;/p&gt;
        ///&lt;p&gt;
        ///    
        ///    Two important components of the algorithm are on th [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string LLL {
            get {
                return ResourceManager.GetString("LLL", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;LWE Crypto System&lt;/h2&gt;
        ///
        ///&lt;p&gt;
        ///&lt;i&gt;Learning With Errors&lt;/i&gt; (LWE) is a problem that was introduced by Oded Regev in 2005 [Reg05].
        ///It can be defined as follows:
        ///&lt;/p&gt;
        ///
        ///&lt;p&gt;
        ///Let m, n and q be integers and X a (normal) random distribution over Zq.
        ///Given is the pair (A, b), with a random quadratic matrix A over Zq^(m x n) and a vector b = As + e, where s is a random vector over Zq^n and e is an error vector over Zq^m, whose elements are selected according to the distribution X.
        ///Then the LWE problem is t [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string LWE {
            get {
                return ResourceManager.GetString("LWE", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Merkle-Hellman-Cryptosystem&lt;/h2&gt;
        ///&lt;p&gt;
        ///    The Merkle-Hellman-Cryptosystem (named after Ralph Merkle and Martin Hellman) 
        ///    was created in 1987 next to the RSA cryptosystem as one of the first asymmetric 
        ///    cryptosystems at all. It was characterized by the fact that it is relatively 
        ///    easy to understand. Of these two, however, only RSA prevailed since 
        ///    Merkle-Hellman soon was impressively broken using lattices.&lt;/p&gt;
        ///&lt;p&gt;The Merkle-Hellman cryptosystem is based on the knapsack problem, more [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string MerkleHellman {
            get {
                return ResourceManager.GetString("MerkleHellman", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;RSA-Cryptosystem&lt;/h2&gt;
        ///&lt;p&gt;
        ///    The RSA method, see [RSA78], is based on the problem of prime factorization. On 
        ///    one side it is easy to multiply two large prime numbers with each other, thereby 
        ///    obtaining an RSA modulus. On the other hand it is difficult to break down any 
        ///    large biprime number into its two unknown large prime factors. It is therefore 
        ///    believed that this is a trap door function. The RSA method makes use of this 
        ///    problem and sets the difficulty in the factorizatio [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string RSA {
            get {
                return ResourceManager.GetString("RSA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;
        ///&lt;html&gt;
        ///
        ///   &lt;head&gt;
        ///      &lt;title&gt;&lt;/title&gt;
        ///      &lt;style type=&quot;text/css&quot;&gt;
        ///			body
        ///			{
        ///	   		font-family:Arial,Verdana,Georgia;
        ///	   		font-size:smaller;
        ///			}
        ///      &lt;/style&gt;
        ///   &lt;/head&gt;
        ///
        ///&lt;body&gt;
        ///   &lt;h2&gt;Lattice-based cryptography&lt;/h2&gt;
        ///
        ///   &lt;p align=&quot;justify&quot;&gt;
        ///		In this crypto tutorial you will learn about lattices and their use in cryptography 
        ///		especially cryptanalysis. This introduction is intended to provide the basics, 
        ///		to better understand the fo [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string Start {
            get {
                return ResourceManager.GetString("Start", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Lattice-based cryptography - Help&lt;/h2&gt;
        ///
        ///Welcome to the online help of the crypto tutorial &quot;Lattice-based 
        ///cryptography&quot;.
        ///Here you can find detailed information about lattices and &lt;span id=&quot;result_box&quot; 
        ///    class=&quot;short_text&quot; lang=&quot;en&quot;&gt;&lt;span class=&quot;hps&quot;&gt;their use&lt;/span&gt;
        ///&lt;span class=&quot;hps&quot;&gt;in cryptography, especially in cryptanalysis&lt;/span&gt;&lt;/span&gt;.
        ///You can reach the different pages of this crypto tutorial via the navigation tab on the left side.
        ///More information about a topic is provided when you c [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string StartControl {
            get {
                return ResourceManager.GetString("StartControl", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Successive Minima&lt;/h2&gt;
        ///&lt;p&gt;
        ///    The successive minima are the lengths of the reduced vectors. They are designated with &amp;lambda; and ordered. 
        ///    The first minimum &amp;lambda;1 thus refers to the &lt;a href=&quot;help://SVP&quot;&gt;shortest vector&lt;/a&gt; v1. Let the minima be defined as follows:&lt;/p&gt;
        ///&lt;p&gt;
        ///    &lt;img src=&quot;ImgSuccessiveMinimaEng&quot; /&gt;
        ///&lt;/p&gt;
        ///
        ///&lt;p&gt;The definition can be understood as a sphere of radius r which &quot;inflates&quot; until it contains all n 
        ///successive minima sorted by length.&lt;/p&gt;
        ///    
        ///&lt;p&gt;The Hermite const [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string SuccessiveMinima {
            get {
                return ResourceManager.GetString("SuccessiveMinima", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Shortest Vector Problem (SVP)&lt;/h2&gt;
        ///&lt;p&gt;
        ///    
        ///The shortest vector problem is beside the 
        ///    &lt;a href=&quot;help://CVP&quot;&gt;Closest Vector Problem&lt;/a&gt; an&amp;nbsp; interesting problem associated with lattices. One searches for a vector that belongs to a 
        ///    lattice and has minimum length. That means there may not be another vector (except the zero vector), which is shorter.&lt;/p&gt;
        ///    
        ///&lt;p&gt;
        ///    
        ///    &lt;span id=&quot;result_box&quot; class=&quot;&quot; lang=&quot;en&quot;&gt;&lt;span class=&quot;hps alt-edited&quot;&gt;To get
        ///    &lt;/span&gt;&lt;span class=&quot;hps&quot;&gt;this&lt;/sp [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        public static string SVP {
            get {
                return ResourceManager.GetString("SVP", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;h2&gt;Target point&lt;/h2&gt;
        ///&lt;p&gt;
        ///    Please enter an arbitrary point in the vector space. This point may not 
        ///    necessarily be a lattice point. Then press the button &amp;quot;Find closest vector&amp;quot;, to 
        ///    find the nearest lattice point to this point. The problem to be solved in this 
        ///    case is known as the &lt;a href=&quot;help://CVP&quot;&gt;Closest Vector Problem&lt;/a&gt;.&lt;/p&gt;
        /// ähnelt.
        /// </summary>
        public static string TargetPoint {
            get {
                return ResourceManager.GetString("TargetPoint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;
        ///&lt;html&gt;
        ///	&lt;head&gt;
        ///	&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
        ///		&lt;title&gt;&lt;/title&gt;
        ///		&lt;style type=&quot;text/css&quot;&gt;
        ///		  body
        ///		  {
        ///		  	font-family:Arial,Verdana,Georgia;
        ///		  	font-size:smaller;
        ///		  }
        ///		&lt;/style&gt;
        ///	&lt;/head&gt;
        ///	&lt;body&gt;
        ///  #content#	
        ///	&lt;br /&gt;
        ///	&lt;br /&gt;
        ///  &lt;a href=&quot;javascript:window.print()&quot;&gt;Print this topic.&lt;/a&gt;
        ///	&lt;/body&gt;
        ///&lt;/html&gt;
        /// ähnelt.
        /// </summary>
        public static string template {
            get {
                return ResourceManager.GetString("template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Online Help Lattice-based cryptography ähnelt.
        /// </summary>
        public static string title {
            get {
                return ResourceManager.GetString("title", resourceCulture);
            }
        }
    }
}
