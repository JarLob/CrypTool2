\chapter{Plugin Implementation}
\label{sec:PluginImplementation}
In this chapter we provide step-by-step instructions for implementing your own CrypTool 2 plugin. The given instructions refer primarily to the usage of \textbf{Microsoft Visual Studio Professional 2008}, so before starting you should have a copy of the program installed on your computer. 

\section{Downloading the example and template}
\label{sec:DownloadingTheExampleAndTemplate}

We will use the \textbf{Caesar cipher} (also known as the \textbf{shift cipher}) as an example throughout this chapter. If you did not to download the entire CrypTool 2 source code as described in Section \ref{CheckingOutTheSources}, you can still get a copy of the source code for the Caesar algorithm referenced throughout this guide from the following location:\\\\
\textit{username: anonymous\\
password:} (not required)\\
\url{https://www.cryptool.org/svn/CrypTool2/trunk/CrypPlugins/Caesar/}\\\\
We have also created a Visual Studio plugin \textbf{template} to help with the development of new plugins. Using this template is strongly recommended over copying and pasting code from this document! The template and a short readme can be found here:\\\\
\url{http://cryptool2.vs.uni-due.de/index.php?page=33&lm=3}
\clearpage

\section{Creating a new project}
\label{sec:CreatingANewProject}

To begin, open Visual Studio, go to the menu bar and select \textit{File~$\rightarrow$ New $\rightarrow$ Project\ldots }. The following window will appear:

\begin{figure}[h!]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/vs_create_new_project.jpg}
	\caption{Creating a new Visual Studio project.}
	\label{fig:vs_create_new_project}
\end{figure}
\clearpage

Select \textbf{\textit{.NET-Framework 3.5}} as the target framework. Then choose \textit{Class Library} as the default template, as this will build the project for your plugin as a DLL file. Give the project a unique and meaningful name (such as \textit{Caesar} in our case), and choose a location to save it to. Select the subdirectory \textit{CrypPlugins} from your SVN trunk as the location. Finally, confirm by pressing the \textit{OK} button. Note that creating a new project in this manner also creates a new solution into which the project is placed. At this point, your Visual Studio solution should look like this:

\begin{figure}[h!]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/solution_start_up.jpg}
	\caption{A newly created solution and project.}
	\label{fig:solution_start_up}
\end{figure}
\clearpage

\section{Interface selection}
\label{sec:InterfaceSelection}

To include our new plugin in the CrypTool 2 application, we must first add a reference to the CrypTool 2 library \textbf{\textit{CrypPluginBase.dll}}, where all the necessary CrypTool 2 plugin interfaces are declared.

\begin{figure}[h!]
	\includegraphics{figures/add_reference.jpg}
	\caption{Adding a new reference.}
	\label{fig:add_reference}
\end{figure}

\noindent Right-click in the Solution Explorer on the \textit{Reference} item and choose \textit{Add Reference}. A window like the following should appear:

\begin{figure}[h!]
	\centering
		\includegraphics{figures/add_pluginbase_source.jpg}
	\caption{Adding a reference to the CrypPluginBase source code.}
	\label{fig:add_pluginbase_source}
\end{figure}
\clearpage

Unless you have created your new project in the same CrypTool 2 solution, you probably will not be able to select the library directly as seen above in Figure \ref{fig:add_pluginbase_source}; instead you can browse for the binary DLL as seen below in Figure \ref{fig:browse_reference}. Click on the \textit{Browse} tab and navigate to the folder in which you downloaded the CrypTool 2 project. Within that folder, go to \textit{\textbackslash CrypPluginBase\textbackslash bin\textbackslash Debug} and select the file \textit{CrypPluginBase.dll}. The library reference can then be added by double clicking the file or pressing the \textit{OK} button.

\begin{figure}[h!]
	\centering
		\includegraphics{figures/browse_reference.jpg}
	\caption{Browsing for a reference.}
	\label{fig:browse_reference}
\end{figure}

Besides CrypPluginBase you will need to add three Windows assembly references to provide the necessary namespaces for the user control functions \textit{Presentation} and \textit{QuickWatchPresentation}. This can be done in a similar manner as before with the \textit{CrypPluginBase} reference, but by selecting the \textit{.NET} tab and searching for the references there. Select the following .NET components:

\textit{
\begin{itemize}
    \item PresentationCore
    \item PresentationFramework
    \item WindowsBase
\end{itemize}}
\clearpage

\noindent After these additions, your reference tree view should look like this:

\begin{figure}[h!]
		\includegraphics{figures/reference_tree.jpg}
	\caption{A reference tree with the essential components.}
	\label{fig:reference_tree}
\end{figure}

\noindent If your plugin will require other additional libraries, you can add them in the same way.

\section{Modifing the project properties}
\label{sec:ModifyTheProjectProperties}

It is important to make two small changes to your plugin's assembly data to make sure that it will be imported correctly into CrypTool 2. Go to the Solution Explorer and open \textit{AssemblyInfo.cs}, which can be found in the \textit{Properties} folder. Make the following two changes:

\begin{itemize}
	\item Change the attribute \textit{AssemblyVersion} to have the value "2.0.*", and
	\item Comment out the attribute \textit{AssemblyFileVersion}.
\end{itemize}

\noindent This section of your assembly file should now look something like this:

\begin{lstlisting}
[assembly: AssemblyVersion("2.0.*")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
\end{lstlisting}

\section{Creating classes for the algorithm and its settings}
\label{sec:CreatingClassesForTheAlgorithmAndItsSettings}

In the next step we will create two classes. The first class will be the main driver; we will call ours \textit{Caesar} since that is the name of the cipher that it will implement. In our case, this class has to inherit from \textit{IEncryption} because it will be an encryption plugin. If it was instead a hash plugin, this class should inherit from \textit{IHash}. The second class will be used to store setting information for the plugin, and thus we will name ours \textit{CaesarSettings}. It will need to inherit from \textit{ISettings}.
\clearpage

\subsection{Creating a class for the algorithm}
\label{sec:CreatingAClassForTheAlgorithm}

When starting a new project, Visual Studio automatically creates a class named \textit{Class1.cs}. Since this is a rather non-descriptive name, we will change it. In our example, it will be \textit{Caesar.cs}. There are two ways to change the name:

\begin{itemize}
	\item Rename the existing class, or
	\item Delete the existing class and create a new one.
\end{itemize}
%\clearpage

\noindent Both options will achieve the same results. We will guide you through the second method. First, delete \textit{Class1.cs}.

\begin{figure}[h!]
	\centering
		\includegraphics{figures/new_class.jpg}
	\caption{Deleting a class.}
	\label{fig:new_class}
\end{figure}
\clearpage

\noindent Then right-click on the project item (in our case, \textit{Caesar}) and select \textit{Add $\rightarrow$ Class\ldots }:

\begin{figure}[h]
	\centering
		\includegraphics{figures/add_new_class.jpg}
	\caption{Adding a new class.}
	\label{fig:add_new_class}
\end{figure}
\clearpage

\noindent Finally, give your class a unique name. We will call our class \textit{Caesar.cs} and define it as public so that it will be available to other classes.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/name_new_class.jpg}
	\caption{Naming the new class.}
	\label{fig:name_new_class}
\end{figure}

Note that Visual Studio will automatically generate a very basic code outline for the new class. In our example, we will not use the all the namespaces that are automatically imported, so you can delete the line \texttt{using System.Linq;}.

\subsection{Creating a settings class}
\label{sec:CreatingASettingsClass}

Add a second public class in the same way. We will call the class \textit{CaesarSettings}. The settings class will store the necessary information about controls, captions, descriptions and default parameters (e.g.\ for key settings, alphabets, key length and type of action) to build the \textbf{TaskPane} in the CrypTool application.
\clearpage

\noindent Below is an example of what a completed TaskPane for the existing Caesar plugin in CrypTool 2 looks like:

\begin{figure}[h!]
	\centering
		\includegraphics{figures/task_pane.jpg}
	\caption{The completed TaskPane for the existing Caesar plugin.}
	\label{fig:task_pane}
\end{figure}
\clearpage

\subsection{Adding the namespaces and inheritance sources for the Caesar class}
\label{sec:AddingTheNamespacesAndInheritanceSourcesForTheCaesarClass}

Open the \textit{Caesar.cs} file by double clicking on it in the Solution Explorer. To include the necessary namespaces in the class header, use the \texttt{using} statement followed by the name of the desired namespace. The CrypTool 2 API provides the following namespaces:

\begin{itemize}
	\item \textit{Cryptool.PluginBase} --- contains interfaces such as \textit{IPlugin}, \textit{IHash}, and \textit{ISettings}, as well as attributes, enumerations, delegates and extensions.
	\item \textit{Cryptool.PluginBase.Analysis} --- contains interfaces for cryptanalysis plugins (such as \textit{Stream Comparator}).
	\item \textit{Cryptool.PluginBase.Control} --- contains global interfaces for the \textit{IControl} feature for defining custom controls.
	\item \textit{Cryptool.PluginBase.Cryptography} --- contains interfaces for encryption and hash algorithms such as AES, DES and MD5.
	\item \textit{Cryptool.PluginBase.Editor} --- contains interfaces for editors that can be implemented in CrypTool 2, such as the default editor.
	\item \textit{Cryptool.PluginBase.Generator} --- contains interfaces for generators, including the random input generator.
	\item \textit{Cryptool.PluginBase.IO} --- contains interfaces for input, output and the \textit{CryptoolStream}.
	\item \textit{Cryptool.PluginBase.Miscellaneous} --- contains assorted helper classes, including \textit{GuiLogMessage} and \textit{PropertyChanged}.
	\item \textit{Cryptool.PluginBase.Resources} --- used only by CrypWin and the editor; not necessary for plugin development.
	\item \textit{Cryptool.PluginBase.Tool} --- contains an interface for all external tools implemented by CrypTool~2 that do not entirely support the CrypTool 2 API.
	\item \textit{Cryptool.PluginBase.Validation} --- contains interfaces for validation methods, including regular expressions.
\end{itemize}

\noindent In our example, the Caesar algorithm necessitates the inclusion of the following namespaces:

\begin{itemize}
	\item \textit{Cryptool.PluginBase} --- to implement \textit{ISettings} in the CaesarSettings class.
	\item \textit{Cryptool.PluginBase.Cryptography} --- to implement \textit{IEncryption} in the Caesar class.
	\item \textit{Cryptool.PluginBase.IO} --- to use CryptoolStream for data input and output.
	\item \textit{Cryptool.PluginBase.Miscellaneous} --- to use the CrypTool event handler.
\end{itemize}

\noindent It is important to define a new default namespace for our public class (\textit{Caesar}). In CrypTool 2  the standard namespace convention is \textit{Cryptool.[name of class]}. Therefore our namespace will be defined as \textit{Cryptool.Caesar}.\clearpage

\noindent At this point, the source code should look like the following:

\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.Text;

//required CrypTool namespaces
using Cryptool.PluginBase;
using Cryptool.PluginBase.Cryptography;
using Cryptool.PluginBase.IO;
using Cryptool.PluginBase.Miscellaneous;

namespace Cryptool.Caesar
{
	public class Caesar
	{
	}
}
\end{lstlisting}

\ \\ % ugly but functional
\noindent Next we should let the \textit{Caesar} class inherit from \textit{IEncryption} by making the following alteration:

\begin{lstlisting}
namespace Cryptool.Caesar
{
	public class Caesar : IEncryption
	{
	}
}
\end{lstlisting}

\subsection{Adding interface functions to the Caesar class}
\label{sec:AddingInterfaceFunctionsToTheCaesarClass}

You may notice an underscore underneath the \textit{I} in \textit{IEncryption}. Move your mouse over it, or place the cursor on it and press \textit{Shift+Alt+F10} and the following submenu should appear:

\begin{figure}[h!]
	\centering
		\includegraphics{figures/inherit_submenu.jpg}
	\caption{An inheritance submenu.}
	\label{fig:inherit_submenu}
\end{figure}

Select the item \textit{Implement interface `IEncryption'}. Visual Studio will automatically generate all the interface members necessary for interaction with the CrypTool 2 core. (This step will save you a lot of typing!)
\clearpage

\noindent Your code should now look like this:

\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.Text;

using Cryptool.PluginBase;
using Cryptool.PluginBase.Cryptography;
using Cryptool.PluginBase.IO;
using Cryptool.PluginBase.Miscellaneous;

namespace Cryptool.Caesar
{
    public class Caesar : IEncryption
    {
        #region IPlugin Members

        public void Dispose()
        {
            throw new NotImplementedException();
        }

        public void Execute()
        {
            throw new NotImplementedException();
        }

        public void Initialize()
        {
            throw new NotImplementedException();
        }

        public event GuiLogNotificationEventHandler OnGuiLogNotificationOccured;

        public event PluginProgressChangedEventHandler OnPluginProgressChanged;

        public event StatusChangedEventHandler OnPluginStatusChanged;

        public void Pause()
        {
            throw new NotImplementedException();
        }

        public void PostExecution()
        {
            throw new NotImplementedException();
        }

        public void PreExecution()
        {
            throw new NotImplementedException();
        }

        public System.Windows.Controls.UserControl Presentation
        {
            get { throw new NotImplementedException(); }
        }

        public System.Windows.Controls.UserControl QuickWatchPresentation
        {
            get { throw new NotImplementedException(); }
        }

        public ISettings Settings
        {
            get { throw new NotImplementedException(); }
        }

        public void Stop()
        {
            throw new NotImplementedException();
        }

        #endregion

        #region INotifyPropertyChanged Members

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        #endregion
    }
}
\end{lstlisting}

\subsection{Adding the namespace and interfaces to the CaesarSettings class}
\label{sec:AddingTheNamespaceAndInterfacesToTheCaesarSettingsClass}

Let's now take a look at the second class in our example, \textit{CaesarSettings}, by double-clicking on the \textit{CaesarSettings.cs} file in the Solution Explorer. First, we need to again include the \textit{Cryptool.PluginBase} namespace to the class header. Then we must let the settings class inherit from \textit{ISettings} in the same manner as was done with the Caesar class. Visual Studio will again automatically generate code from the CrypTool interface as seen below. (In this case, we can remove the using \texttt{System.Collections.Generic;}, \texttt{using System.Linq;}, and \texttt{using System.Text;} lines, as we will not use those references.)
\clearpage

\begin{lstlisting}
using System;

using Cryptool.PluginBase;

namespace Cryptool.Caesar
{
    public class CaesarSettings : ISettings
    {
        #region ISettings Members

        public bool HasChanges
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        #endregion

        #region INotifyPropertyChanged Members

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        #endregion
    }
}
\end{lstlisting}

\subsection{Adding controls to the CaesarSettings class}
\label{sec:AddingControlsToTheCaesarSettingsClass}

The settings class is used to populate the TaskPane in the CrypTool 2 application so that the user can modify the plugin settings at will. Thus we will need to implement some controls, such as buttons and text boxes, to allow for the necessary interaction. If you will be implementing an algorithm that does not have any user-defined settings (i.e.\ a hash function), then this class can be left mostly empty; you will, however, still have to modify the \textit{HasChanges} property to avoid a \textit{NotImplementedException}. The following code demonstrates the modifications necessary to create the backend for the TaskPane for our Caesar algorithm. You can also look at the source code of other CrypTool 2 plugins for examples of how to create the TaskPane backend.\\

\begin{lstlisting}
using System;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;

using Cryptool.PluginBase;

namespace Cryptool.Caesar
{
    public class CaesarSettings : ISettings
    {
        #region Public Caesar specific interface

        /// <summary>
        /// This delegate is ued to send log messages from
        /// the settings class to the Caesar plugin.
        /// </summary>
        public delegate void CaesarLogMessage(string msg, NotificationLevel loglevel);

        /// <summary>
        /// An enumeration for the different modes of handling
        /// unknown characters.
        /// </summary>
        public enum UnknownSymbolHandlingMode { Ignore = 0, Remove = 1, Replace = 2 };

        /// <summary>
        /// Fires when a new status message was sent.
        /// </summary>
        public event CaesarLogMessage LogMessage;

        public delegate void CaesarReExecute();

        public event CaesarReExecute ReExecute;

        /// <summary>
        /// Retrieves or sets the current shift value (i.e. the key).
        /// </summary>
        [PropertySaveOrder(0)]
        public int ShiftKey
        {
            get { return shiftValue; }
            set
            {
                setKeyByValue(value);
            }
        }

        /// <summary>
        /// Retrieves the current setting of whether or not the
        /// alphabet should be treated as case-sensitive.
        /// </summary>
        [PropertySaveOrder(1)]
        public bool CaseSensitiveAlphabet
        {
            get
            {
                if (caseSensitiveAlphabet == 0)
                {   return false;   }
                else
                {   return true;    }
            }
            set {} // this setting is readonly, but we must include
                   // some form of set method to prevent problems.
        }

        /// <summary>
        /// Returns true if any settings have been changed.
        /// This value should be set externally to false, i.e.
        /// when a project is saved.
        /// </summary>
        [PropertySaveOrder(3)]
        public bool HasChanges
        {
            get { return hasChanges; }
            set { hasChanges = value; }
        }

        #endregion

        #region Private variables
        private bool hasChanges;
        private int selectedAction = 0;
        private string upperAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        private string lowerAlphabet = "abcdefghijklmnopqrstuvwxyz";
        private string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        private char shiftChar = 'C';
        private int shiftValue = 2;
        private UnknownSymbolHandlingMode unknownSymbolHandling = UnknownSymbolHandlingMode.Ignore;
        private int caseSensitiveAlphabet = 0; // 0 = case-insensitve, 1 = case-sensitive
        private bool sensitivityEnabled = true;
        #endregion

        #region Private methods

        private string removeEqualChars(string value)
        {
            int length = value.Length;

            for (int i = 0; i < length; i++)
            {
                for (int j = i + 1; j < length; j++)
                {
                    if ((value[i] == value[j]) || (!CaseSensitiveAlphabet & (char.ToUpper(value[i]) == char.ToUpper(value[j]))))
                    {
                        LogMessage("Removing duplicate letter: \'" + value[j] + "\' from alphabet!", NotificationLevel.Warning);
                        value = value.Remove(j,1);
                        j--;
                        length--;
                    }
                }
            }

            return value;
        }

        /// <summary>
        /// Set the new shiftValue and the new shiftCharacter
        /// to offset % alphabet.Length.
        /// </summary>
        private void setKeyByValue(int offset)
        {
            HasChanges = true;

            // Make sure the shift value lies within the alphabet range.
            offset = offset % alphabet.Length;

            // Set the new shiftChar.
            shiftChar = alphabet[offset];

            // Set the new shiftValue.
            shiftValue = offset;

            // Announce this to the settings pane.
            OnPropertyChanged("ShiftValue");
            OnPropertyChanged("ShiftChar");

            // Print some info in the log.
            LogMessage("Accepted new shift value " + offset + "! (Adjusted shift character to \'" + shiftChar + "\')", NotificationLevel.Info);
        }

        private void setKeyByCharacter(string value)
        {
            try
            {
                int offset;
                if (this.CaseSensitiveAlphabet)
                {
                    offset = alphabet.IndexOf(value[0]);
                }
                else
                {
                    offset = alphabet.ToUpper().IndexOf(char.ToUpper(value[0]));
                }

                if (offset >= 0)
                {
                    HasChanges = true;
                    shiftValue = offset;
                    shiftChar = alphabet[shiftValue];
                    LogMessage("Accepted new shift character \'" + shiftChar + "\'! (Adjusted shift value to " + shiftValue + ")", NotificationLevel.Info);
                    OnPropertyChanged("ShiftValue");
                    OnPropertyChanged("ShiftChar");
                }
                else
                {
                    LogMessage("Bad input \"" + value + "\"! (Character not in alphabet!) Reverting to " + shiftChar.ToString() + "!", NotificationLevel.Error);
                }
            }
            catch (Exception e)
            {
                LogMessage("Bad input \"" + value + "\"! (" + e.Message + ") Reverting to " + shiftChar.ToString() + "!", NotificationLevel.Error);
            }
        }

        #endregion

        #region Algorithm settings properties (visible in the Settings pane)

        [PropertySaveOrder(4)]
        [ContextMenu("Action", "Select the algorithm action", 1, DisplayLevel.Beginner, ContextMenuControlType.ComboBox, new int[] { 1, 2 }, "Encrypt", "Decrypt")]
        [TaskPane("Action", "setAlgorithmActionDescription", null, 1, true, DisplayLevel.Beginner, ControlType.ComboBox, new string[] { "Encrypt", "Decrypt" })]
        public int Action
        {
            get
            {
                return this.selectedAction;
            }
            set
            {
                if(value != selectedAction)
                {
                	HasChanges = true;
	                this.selectedAction = value;
    	            OnPropertyChanged("Action");
    	        }
                if(ReExecute != null)
                {	ReExecute();	}
            }
        }

        [PropertySaveOrder(5)]
        [TaskPane("Key as integer", "Enter the number of letters to shift. For example, a value of 1 means that the plaintext character 'a' gets mapped to the ciphertext character 'B', 'b' to 'C', and so on.", null, 2, true, DisplayLevel.Beginner, ControlType.NumericUpDown, ValidationType.RangeInteger, 0, 100)]
        public int ShiftValue
        {
            get { return shiftValue; }
            set
            {
                setKeyByValue(value);
                if (ReExecute != null)
                {	ReExecute();	}
            }
        }

        [PropertySaveOrder(6)]
        [TaskPaneAttribute("Key as single letter", "Enter a single letter as the key. This letter is mapped to an integer stating the position in the alphabet. The values for 'Key as integer' and 'Key as single letter' are always synchronized.", null, 3, true, DisplayLevel.Beginner, ControlType.TextBox, ValidationType.RegEx, "^([A-Z]|[a-z]){1,1}")]
        public string ShiftChar
        {
            get { return this.shiftChar.ToString(); }
            set
            {
                setKeyByCharacter(value);
                if (ReExecute != null)
	                {   ReExecute();    }
            }
        }

        [PropertySaveOrder(7)]
        [ContextMenu("Unknown symbol handling", "What should be done with characters encountered in the input which are not in the alphabet?", 4, DisplayLevel.Expert, ContextMenuControlType.ComboBox, null, new string[] { "Ignore (leave unmodified)", "Remove", "Replace with \'?\'" })]
        [TaskPane("Unknown symbol handling", "What should be done with characters encountered in the input which are not in the alphabet?", null, 4, true, DisplayLevel.Expert, ControlType.ComboBox, new string[] { "Ignore (leave unmodified)", "Remove", "Replace with \'?\'" })]
        public int UnknownSymbolHandling
        {
            get { return (int)this.unknownSymbolHandling; }
            set
            {
                if((UnknownSymbolHandlingMode)value != unknownSymbolHandling)
                {
                	HasChanges = true;
	                this.unknownSymbolHandling = (UnknownSymbolHandlingMode)value;
    	            OnPropertyChanged("UnknownSymbolHandling");
				}
                if (ReExecute != null) 
                {	ReExecute();	}
            }
        }

        [SettingsFormat(0, "Normal", "Normal", "Black", "White", Orientation.Vertical)]
        [PropertySaveOrder(9)]
        [TaskPane("Alphabet", "This is the alphabet currently in use.", null, 6, true, DisplayLevel.Expert, ControlType.TextBox, "")]
        public string AlphabetSymbols
        {
          get { return this.alphabet; }
          set
          {
            string a = removeEqualChars(value);
            if (a.Length == 0) // cannot accept empty alphabets
            {
              LogMessage("Ignoring empty alphabet from user! Using previous alphabet instead: \" + alphabet + "\" (" + alphabet.Length.ToString() + " Symbols)", NotificationLevel.Info);
            }
            else if (!alphabet.Equals(a))
            {
              HasChanges = true;
              this.alphabet = a;
              setKeyByValue(shiftValue); // reevaluate if the shiftvalue is still within the range
              LogMessage("Accepted new alphabet from user: \"" + alphabet + "\" (" + alphabet.Length.ToString() + " Symbols)", NotificationLevel.Info);
              OnPropertyChanged("AlphabetSymbols");

              if (ReExecute != null)
              {	ReExecute();	}
            }
          }
        }

        /// <summary>
        /// Visible setting how to deal with alphabet case.
        /// 0 = case-insentive, 1 = case-sensitive
        /// </summary>
        [PropertySaveOrder(8)]
        [ContextMenu("Alphabet case sensitivity", "Should upper and lower case be treated as the same (so that 'a' = 'A')?", 7, DisplayLevel.Expert, ContextMenuControlType.ComboBox, null, new string[] { "Case insensitive", "Case sensitive" })]
        [TaskPane("Alphabet case sensitivity", "Should upper and lower case be treated as the same (so that 'a' = 'A')?", null, 7, true, DisplayLevel.Expert, ControlType.ComboBox, new string[] { "Case insensitive", "Case sensitive" })]
        public int AlphabetCase
        {
            get { return this.caseSensitiveAlphabet; }
            set
            {
                if (value != caseSensitiveAlphabet)
                {	HasChanges = true;	}
                this.caseSensitiveAlphabet = value;
                if (value == 0)
                {
                    if (alphabet == (upperAlphabet + lowerAlphabet))
                    {
                        alphabet = upperAlphabet;
                        LogMessage("Changing alphabet to: \"" + alphabet + "\" (" + alphabet.Length.ToString() + " Symbols)", NotificationLevel.Info);
                        OnPropertyChanged("AlphabetSymbols");
                        // reset the key (shiftvalue/shiftChar)
                        // to be in the range of the new alphabet.
                        setKeyByValue(shiftValue);
                    }
                }
                else
                {
                    if (alphabet == upperAlphabet)
                    {
                        alphabet = upperAlphabet + lowerAlphabet;
                        LogMessage("Changing alphabet to: \"" + alphabet + "\" (" + alphabet.Length.ToString() + " Symbols)", NotificationLevel.Info);
                        OnPropertyChanged("AlphabetSymbols");
                    }
                }

                // Remove equal characters from the current alphabet.
                string a = alphabet;
                alphabet = removeEqualChars(alphabet);
                if (a != alphabet)
                {
                    OnPropertyChanged("AlphabetSymbols");
                    LogMessage("Changing alphabet to: \"" + alphabet + "\" (" + alphabet.Length.ToString() + " Symbols)", NotificationLevel.Info);
                }
                OnPropertyChanged("AlphabetCase");
                if (ReExecute != null)
                {	ReExecute();	}
            }
        }

        #endregion

        #region INotifyPropertyChanged Members

        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged(string name)
        {
          if (PropertyChanged != null)
          {
            PropertyChanged(this, new PropertyChangedEventArgs(name));
          }
        }

        #endregion

        #region TaskPaneAttributeChanged (Sample)
        /// <summary>
        /// This event is here merely as a sample.
        /// </summary>
        public event TaskPaneAttributeChangedHandler TaskPaneAttributeChanged;

        [TaskPane("Enable/Disable sensitivity", "This setting is just a sample and shows how to enable / disable a setting.", "AttributeChangedSample", 8, false, DisplayLevel.Beginner, ControlType.Button)]
        public void EnableDisableSesitivity()
        {
          if (TaskPaneAttributeChanged!= null)
          {
            sensitivityEnabled = !sensitivityEnabled;
            if (sensitivityEnabled)
            {
              TaskPaneAttributeChanged(this, new TaskPaneAttributeChangedEventArgs(new TaskPaneAttribteContainer("AlphabetCase", Visibility.Visible)));
            }
            else
            {
              TaskPaneAttributeChanged(this, new TaskPaneAttributeChangedEventArgs(new TaskPaneAttribteContainer("AlphabetCase", Visibility.Collapsed)));
            }
          }
        }
        #endregion TaskPaneAttributeChanged (Sample)
    }
}
\end{lstlisting}
\clearpage

\section{Adding an icon to the Caesar class}
\label{sec:AddingAnIconToTheCaesarClass}

Before we go back to the code of the Caesar class, we have to add an icon to our project, which will be shown in the CrypTool 2 \textbf{ribbon bar} and \textbf{navigation pane}. As there is currently no default, it is mandatory to add an icon. (It is planned to include a default icon in future versions.)

For testing purposes you can just create a simple black and white PNG image with any graphics editing program, such as MS Paint or Paint.NET. The proper image size is 40x40 pixels, but since the image will be rescaled if necessary, any size is technically acceptable.

Once you have saved your icon, you should add it directly to the project or to a subdirectory with it. In the project solution, we created a new folder named \textit{Images}. This can be done by right-clicking on the project item (\textit{Caesar} in our example) and selecting \textit{Add $\rightarrow$ New Folder}. The icon can be added to this folder (or to the project directly, or to any other subdirectory) by right-clicking on the folder and selecting \textit{Add $\rightarrow$ Existing Item}.

\begin{figure}[h!]
	\centering
		\includegraphics{figures/add_existing_item.jpg}
	\caption{Adding an existing item.}
	\label{fig:add_existing_item}
\end{figure}
\clearpage

A new window will then appear. Select \textit{Image Files} as the file type and select your newly-created icon for your plugin.

\begin{figure}[h!]
	\centering
		\includegraphics{figures/choose_icon.jpg}
	\caption{Selecting the image file.}
	\label{fig:choose_icon}
\end{figure}
\clearpage

Finally, we must set the icon as a \textit{Resource} to avoid including the icon as a separate file. Right-click on the icon and select \textit{Properties} as seen below.

\begin{figure}[h!]
	\centering
		\includegraphics{figures/icon_properties.jpg}
	\caption{Selecting the image properties.}
	\label{fig:icon_properties}
\end{figure}

In the \textit{Properties} panel, set the \textit{Build Action} to \textit{Resource}.

\begin{figure}[h!]
	\centering
		\includegraphics{figures/icon_build_action.jpg}
	\caption{Selecting the icon's build action.}
	\label{fig:icon_build_action}
\end{figure}
\clearpage

\section{Defining the attributes of the Caesar class}
\label{sec:DefiningTheAttributesOfTheCaesarClass}

Now let's go back to the code of the Caesar class (the \textit{Caesar.cs} file in our example). The first thing we will do is define the attributes of our class. These attributes are used to provide additional information for the CrypTool 2 environment. If they are not properly defined, your plugin won't show up in the application user interface, even if everything else is implemented correctly.

Attributes are used for declarative programming and provide metadata that can be added to the existing .NET metadata. CrypTool 2 provides a set of custom attributes that are used to mark the different parts of your plugin.

These attributes can be defined anywhere within the \textit{Cryptool.Caesar} namespace, but customarily they are defined right before the class declaration.

\subsection{The \protect\textit{[Author]} attribute}
\label{sec:TheAuthorAttribute}

The \textit{[Author]} attribute is optional, meaning that we are not required to define it. The attribute can be used to provide additional information about the plugin developer (or developers, as the case may be). This information will appear in the TaskPane, as for example in Figure \ref{fig:task_pane}. We will define the attribute to demonstrate how it should look in case you want to use it in your plugin.

\begin{figure}[h!]
	\centering
		\includegraphics[width=.90\textwidth]{figures/attribute_author.jpg}
	\caption{The defintion for the \textit{[Author]} attribute.}
	\label{fig:attribute_author}
\end{figure}

As can be seen above, the author attribute takes four elements of type string. These elements are:

\begin{itemize}
	\item \textit{Author} --- the name of the plugin developer.
	\item \textit{Email} --- the email address of the plugin developer, should he or she wish to be available for contact.
	\item \textit{Institute} --- the organization, company or university with which the developer is affiliated.
	\item \textit{URL} --- the website of the developer or of his or her institution.
\end{itemize}

All of these elements are optional; the developer can choose what information will be published. Unused elements should be set to \texttt{null} or an empty string.
\clearpage

\subsection{The \protect\textit{[PluginInfo]} attribute}
\label{sec:ThePluginInfoAttribute}

The second attribute, \textit{[PluginInfo]}, provides necessary information about the plugin, and is therefore mandatory. The information defined in this attribute appears in the caption and tool tip window. The attribute is defined as follows:

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/attribute_plugininfo.jpg}
	\caption{The defintion for the \textit{[PluginInfo]} attribute.}
	\label{fig:attribute_plugininfo}
\end{figure}

\noindent This attribute has the following parameters:

\begin{itemize}
	\item \textit{Resource File} --- the relative path of the associated resource file (if the plugin makes use of one). These files are used primarily to provide multilingual support for the plugin, although this is currently a work in progress. This element is optional.
	\item \textit{Startable} --- a flag that should be set to \texttt{true} only if the plugin is an input generator (i.e.\ if your plugin only has outputs and no inputs). In all other cases this should be set to \texttt{false}. This flag is important --- setting it incorrectly will result in unpredictable results. This element is mandatory.
	\item \textit{Caption} --- the name of the plugin, or, if using a resource file, the name of the field in the file with the caption data. This element is mandatory.
	\item \textit{ToolTip} --- a description of the plugin, or, if using a resource file, the name of the field in the resource file with the toolTip data. This element is optional.
	\item \textit{DescriptionURL} --- the local path of the description file (e.g.\ XAML file). This element is optional.
	\item \textit{Icons} --- an array of strings to define all the paths of the icons used in the plugin (i.e.\ the plugin icon described in Section \ref{sec:AddingAnIconToTheCaesarClass}). This element is mandatory.
\end{itemize}

\noindent Unused elements should be set to \texttt{null} or an empty string.

There are a few limitations and bugs that still exist in the \textit{[PluginInfo]} attribute that will be resolved in a future version. First, it is possible to use the plugin without setting a caption, although this is not recommended, and future versions of the plugin will fail to load without a caption. Second, a zero-length toolTip string currently causes the toolTip to appear as an empty box in the application. Third, the toolTip and description do not currently support internationalization and localization. Since the precise formulation and functionality of this attribute is still being developed, it is recommended to view other plugins for examples.

In our example, the \textit{resourceFile} parameter should be set to \textit{Cryptool.Caesar.Resource.res}. This file will be used to store the label and caption text to support multilingualism.

The second parameter, \textit{startable}, should be set to \texttt{false}, because our encryption algorithm is not an input generator.

The next two parameters are necessary to define the plugin's name and description. Since we are using a resource file, we should place here the names of the resource fields that contain the caption and toolTip. (We could also just write simple text strings instead of using outsourced references.)

The \textit{DescriptionURL} element defines the location path of the description file. The parameter is composed in the format \textit{$<$assembly name$>$/$<$file name$>$} or, if you want to store your description files in a separate folder (as in our case), \textit{$<$assembly name$>$/$<$path$>$/$<$file name$>$}. The description file must be an XAML file. In our case, we shall create a folder named \textit{DetailedDescription} in which to store our XAML file with any necessary images. Our folder structure now looks as follows:

\begin{figure}[h!]
	\centering
		\includegraphics[width=.30\textwidth]{figures/detailed_description.jpg}
	\caption{The folder structure as seen in the Solution Explorer.}
	\label{fig:attribute_plugininfo_icon_path}
\end{figure}

Once a detailed description has been written in the XAML file, it can be accessed in the CrypTool~2 application by right-clicking on the plugin icon in the workspace and selecting \textit{Show description}.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/xaml_description.jpg}
	\caption{A detailed description provided through an XAML file.}
	\label{fig:xaml_description}
\end{figure}
\clearpage

The last parameter tells CrypTool 2 the names of the provided icons. This parameter is an array composed of strings in the format \textit{$<$assembly name$>$/$<$file name$>$} or \textit{$<$assembly name$>$/$<$path$>$/\linebreak $<$file~name$>$}.

The first and most important icon is the plugin icon, which will be shown in CrypTool 2 in the ribbon bar and navigation pane. Once the icon has been added to the project as described in Section~\ref{sec:AddingAnIconToTheCaesarClass}, we must accordingly tell CrypTool 2 where to find the icon. This can be seen above in Figure \ref{fig:attribute_plugininfo}.

If your plugin will use additional icons, you should define the paths to each of them by adding the path strings to the \textit{[PluginInfo]} attribute parameter list, each separated by a comma. We have added two further icons for the context menu in the CrypTool 2 workspace. (If you choose to add more icons, don't forget to add the icons to your solution.)

\subsection{The \protect\textit{[EncryptionType]} attribute}
\label{sec:TheEncryptionTypeAttribute}

The third and last attribute, \textit{[EncryptionType]}, is needed to tell CrypTool 2 what type of plugin we are creating. CrypTool 2 uses this information to place the plugin in the correct group in the navigation pane and ribbon bar. In our example, since Caesar is a classical algorithm, we will define the attribute as follows:

\begin{figure}[h]
	\centering
		\includegraphics[width=.90\textwidth]{figures/attribute_encryptiontype.jpg}
	\caption{A defined \textit{[EncryptionType]} attribute.}
	\label{fig:attribute_encryption_type}
\end{figure}

The possible values of the \textit{[EncryptionType]} attribute are as follows:

\begin{itemize}
	\item \textit{Asymmetric} --- for asymmetrical encryption algorithms, such as RSA.
	\item \textit{SymmetricBlock} --- for block cipher algorithms, such as DES, AES and Twofish.
	\item \textit{SymmetricStream} --- for stream cipher algorithms, such as RC4, Rabbit and SEAL.
	\item \textit{Hybrid} --- for algorithms which are actually a combination of several algorithms, such as algorithms in which the data is encrypted symmetrically and the encryption key asymmetrically.
	\item \textit{Classic} --- for classical encryption or hash algorithms, such as Caesar or MD5.
\end{itemize}

\section{Defining the private variables of the settings in the Caesar class}
\label{sec:DefiningThePrivateVariablesOfTheSettingsInTheCaesarClass}

The next step is to define some private variables that are needed for the settings, input, and output data. In our example, this will look like the following:

\begin{lstlisting}
public class Caesar : IEncryption
{
	#region Private variables
	private CaesarSettings settings;
	private string inputString;
	private string outputString;
	private enum CaesarMode { encrypt, decrypt };
	private List<CryptoolStream> listCryptoolStreamsOut = new List<CryptoolStream>();
	#endregion
\end{lstlisting}

\ \\ % ugly but functional
If your algorithm deals with long strings of code, it is recommended to use the \textit{CryptoolStream} data type. This was designed for input and output between plugins and to handle large amounts of data. To use the native CrypTool stream type, include the namespace \textit{Cryptool.PluginBase.IO} with a \texttt{using} statement as explained in Section \ref{sec:AddingTheNamespacesAndInheritanceSourcesForTheCaesarClass}.

Our example makes use of the following private variables:

\begin{itemize}
	\item \texttt{CaesarSettings settings} --- required to implement the IPlugin interface properly.
	\item \texttt{string inputString} --- string from which to read the input data.
	\item \texttt{string outputString} --- string to which to save the output data.
	\item \texttt{enum CaesarMode} --- used to select either encryption or decryption.
	\item \texttt{List$<$CryptoolStream$>$ listCryptoolStreamsOut} --- a list of all streams created by the plugin, which helps to perform a clean dispose.
\end{itemize}

\section{Implementing the interfaces in the Caesar class}
\label{sec:ImplementingTheInterfacesInTheCaesarClass}

\subsection{Connecting the settings class}
\label{sec:ConnectingTheSettingsClass}

The next major step is to write out our implementations of the interfaces. First we will add a constructor to our class. We will use this to create an instance of our settings class and a function to handle events:

\begin{lstlisting}
public Caesar()
{
	this.settings = new CaesarSettings();
	this.settings.LogMessage += GuiLogMessage;
}
\end{lstlisting}

\ \\
\indent Secondly, we must implement the \textit{Settings} property declared in the interface. An outline of this property should have been automatically generated by implementing the interface (see Section \ref{sec:AddingInterfaceFunctionsToTheCaesarClass}); just edit it appropriately to communicate with your settings class as we have done here:

\begin{lstlisting}
public ISettings Settings
{
	get { return (ISettings)this.settings; }
	set { this.settings = (CaesarSettings)value; }
}
\end{lstlisting}
\clearpage

\subsection{The input/output attributes}
\label{sec:TheInputOutputAttributes}

%\ \\
\indent Next we will define five properties, each with an appropriate attribute, to be used for input and output. Th attributes are necessary to tell CrypTool 2 whether the properties are used for input or output and to provide the plugin with external data.

The attribute that we will use for each proprerty is called \textit{[PropertyInfo]} and it consists of the following elements:

\begin{itemize}
	\item \textit{direction} --- defines whether this property is an input or output property, e.g.\ whether it reads input data or writes output data. The possible values are:
	\begin{itemize}
		\item \texttt{Direction.Input}
		\item \texttt{Direction.Output}
	\end{itemize}
	\item \textit{caption} --- the caption for the property displayed over the input or output arrow of the icon after it has been placed in the editor; ``Input stream'' in the example below:
	
\begin{figure}[h!]
	\centering
		\includegraphics[width=.55\textwidth]{figures/property_caption.jpg}
	\caption{A possible property caption and toolTip.}
	\label{fig:property_caption}
\end{figure}

	\item \textit{toolTip} --- the toolTip for the property displayed over the input or output arrow of the icon after it has been placed in the editor; ``Input data to be hashed'' in the example above.
	\item \textit{descriptionUrl} --- currently not used; fill it with \texttt{null} or an empty string.
	\item \textit{mandatory} --- this flag determines whether an input must be attached by the user to use the plugin. If set to \texttt{true}, an input connection will be required or else the plugin will not be executed in the workflow chain. If set to \texttt{false}, connecting an input is optional. As this only applies to input properties, if the direction has been set to \texttt{Direction.Output}, this flag will be ignored.
	\item \textit{hasDefaultValue} --- if this flag is set to \texttt{true}, CrypTool 2 will assume that the property has a default input value that does not require user input.
	\item \textit{displayLevel} --- determines in which display levels your property will be shown in CrypTool~2. These are used to hide more advanced item from less-experienced users; a beginner using the corresponding display level will not see the properties marked as any other level, but a professional using the appropriate display level will have access to everything. These levels are as follows:
	
	\begin{itemize}
		\item \texttt{DisplayLevel.Beginner}
		\item \texttt{DisplayLevel.Experienced}
		\item \texttt{DisplayLevel.Expert}
		\item \texttt{DisplayLevel.Professional}
	\end{itemize}
\clearpage
	
	\item \textit{quickWatchFormat} --- determines how the content of the property will be shown in the quickwatch perspective. CrypTool 2 accepts the following quickwatch formats:
	
	\begin{itemize}
		\item \texttt{QuickWatchFormat.Base64}
		\item \texttt{QuickWatchFormat.Hex}
		\item \texttt{QuickWatchFormat.None}
		\item \texttt{QuickWatchFormat.Text}
	\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figures/quick_watch.jpg}
	\caption{A quickwatch display in hexadecimal.}
	\label{fig:quick_watch}
\end{figure}
	
	\item \textit{quickWatchConversionMethod} --- this is used to indicate a conversion method; most plugins do not ned to convert their data and thus should use a \texttt{null} value here. The quickwatch function uses the default system encoding to display data, so if your data is in another format, such as UTF-16 or Windows-1250, you should provide here the name of a conversion method as string. The header for such a method should look something like the following:

\begin{lstlisting}
object YourMethodName(string PropertyNameToConvert)
\end{lstlisting}

\end{itemize}

\subsection{Defining the input/output properties}
\label{sec:DefiningTheInputOutputProperties}

The first of the five properties that we will define is \textit{InputString}. This is used to provide our plugin with the data to be encrypted or decrypted:

\begin{lstlisting}
[PropertyInfo(Direction.InputData, "Text input", "Input a string to be processed by the Caesar cipher", "", true, false, DisplayLevel.Beginner, QuickWatchFormat.Text, null)]
public string InputString
{
	get { return this.inputString; }
	set
  {
		if (value != inputString)
		{
			this.inputString = value;
			OnPropertyChanged("InputString");
		}
	}
}
\end{lstlisting}

\ \\
In the get method we simply return the value of the input data. The set method checks if the input value has changed, and, if so, sets the new input data and announces the change to the CrypTool 2 environment by calling the function \textit{OnPropertyChanged(\textit{$<$Property name$>$})}. This step is necessary for input properties to update the quickwatch view.
\clearpage

%\textit{\small Note 1: It is currently not possible to read directly from the input data stream without creating an intermediate CryptoolStream.\\\\
%\small Note 2: The naming may be confusing. The new CryptoolStream is not an output stream, but it is added to the list of output streams to enable a clean dispose afterwards. See chapter 9 below.\\\\}

The output data property (which handles the input data after it has been encrypted or decrypted) will in our example look as follows:

\begin{lstlisting}
[PropertyInfo(Direction.OutputData, "Text output", "The string after processing with the Caesar cipher", "", false, false, DisplayLevel.Beginner, QuickWatchFormat.Text, null)]
public string OutputString
{
	get { return this.outputString; }
	set
	{
		outputString = value;
		OnPropertyChanged("OutputString");
	}
}
\end{lstlisting}

\ \\
\indent CrypTool 2 does not require implementing set methods for output properties, as they will never be called from outside the plugin. Nevertheless, in our example the plugin itself accesses the property, and therefore we have chosen to implement the set method.

You can provide additional output data types if you so desire. In our example, we will also offer output data of type \textit{CryptoolStream}, input data for external alphabets, and input data for the shift value of our Caesar algorithm. Note that for the first of these, the set method is not implemented since it will never be called. We shall define these properties as follows:

\begin{lstlisting}
[PropertyInfo(Direction.OutputData, "CryptoolStream output", "The raw CryptoolStream data after processing with the Caesar cipher", "", false, false, DisplayLevel.Beginner, QuickWatchFormat.Text, null)]
public CryptoolStream OutputData
{
	get
	{
		if (outputString != null)
		{
			CryptoolStream cs = new CryptoolStream();
			listCryptoolStreamsOut.Add(cs);
			cs.OpenRead(Encoding.Default.GetBytes(outputString.ToCharArray()));
			return cs;
		}
		else
		{
			return null;
		}
	}
	set { }
}

[PropertyInfo(Direction.InputData, "External alphabet input", "Input a string containing the alphabet to be used by Caesar.\nIf no alphabet is provided for this input, the internal default alphabet will be used.", "", false, false, DisplayLevel.Expert, QuickWatchFormat.Text, null)]
public string InputAlphabet
{
	get { return ((CaesarSettings)this.settings).AlphabetSymbols; }
	set
	{
		if (value != null && value != settings.AlphabetSymbols)
		{
			((CaesarSettings)this.settings).AlphabetSymbols = value;
			OnPropertyChanged("InputAlphabet");
		}
	}
}

[PropertyInfo(Direction.InputData, "Shift value (integer)", "This is the same setting as the shift value in the Settings pane but as dynamic input.", "", false, false, DisplayLevel.Expert, QuickWatchFormat.Text, null)]
public int ShiftKey
{
	get { return settings.ShiftKey; }
	set
	{
		if (value != settings.ShiftKey)
		{
			settings.ShiftKey = value;
		}
	}
}
\end{lstlisting}


\subsection{Sending messages to the CrypTool 2 core}
\label{sec:SendingMessagesToTheCrypTool2Core}

The CrypTool 2 API provides two methods to send messages from the plugin to the CrypTool 2 core. \textit{GuiLogMessage} is used to send messages to the CrypTool 2 status bar. This method is a nice mechanism to inform the user as to what your plugin is currently doing. \textit{OnPropertyChanged} is used to inform the core application of changes to any plugin properties and data. This may not affect the user interface, but is important to keep the core appraised of the plugin's current state.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/status_bar.jpg}
	\caption{An example status bar.}
	\label{fig:status_bar}
\end{figure}
\clearpage

The \textit{GuiLogMessage} method takes two parameters:

\begin{itemize}
	\item \textit{Message} --- the text to be shown in the status bar.
	\item \textit{NotificationLevel} --- the type of message, that is, its alert level:
	\begin{itemize}
		\item \texttt{NotificationLevel.Error}
		\item \texttt{NotificationLevel.Warning}
		\item \texttt{NotificationLevel.Info}
		\item \texttt{NotificationLevel.Debug}
	\end{itemize}
\end{itemize}

Both of these notification methods also have associated events. Outlines of both related events will have been automatically generated by implementing the interface (see Section \ref{sec:AddingInterfaceFunctionsToTheCaesarClass}), but we must define the appropriate methods as follows:

\begin{lstlisting}
public event GuiLogNotificationEventHandler OnGuiLogNotificationOccured;

private void GuiLogMessage(string message, NotificationLevel logLevel)
{
	EventsHelper.GuiLogMessage(OnGuiLogNotificationOccured, this, new GuiLogEventArgs(message, this, logLevel));
}

public event PropertyChangedEventHandler PropertyChanged;

public void OnPropertyChanged(String name)
{
	EventsHelper.PropertyChanged(PropertyChanged, this, new PropertyChangedEventArgs(name));
}
\end{lstlisting}

\ \\
\indent Note that to use \textit{PropertyChangedEventHandler} you must include the namespace \textit{System.\linebreak ComponentModel}. Our collection of included namespaces should now look as follows:

\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;

using Cryptool.PluginBase;
using Cryptool.PluginBase.Cryptography;
using Cryptool.PluginBase.IO;
using Cryptool.PluginBase.Miscellaneous;
\end{lstlisting}
\clearpage

\section{Completing the algorithmic code of the Caesar class}
\label{sec:CompletingTheAlgorithmicCodeOfTheCaesarClass}

At this point, the plugin should be ready to be read by and shown correctly in the CrypTool 2 application. However, we haven't actually implemented the algorithm yet; we have just implemented interfaces and constructed a thorough set of properties. Algorithmic processing should be done in the \textit{Execute()} function, as this is what CrypTool 2 will always call first. The actual functionality of your algorithm, as well as the structure thereof, is up to you. Note that an outline of the \textit{Execute()} function will have been automatically generated by implementing the interface (see Section \ref{sec:AddingInterfaceFunctionsToTheCaesarClass}).

We have chosen to split our algorithm's encryption and decryption processes into two separate functions, which will both ultimately call the \textit{ProcessCaesar()} function. Below is our implementation of the Caesar algothmic processing and the \textit{Execute()} function:

\begin{lstlisting}
private void ProcessCaesar(CaesarMode mode)
{
	CaesarSettings cfg = (CaesarSettings)this.settings;
	StringBuilder output = new StringBuilder("");
	string alphabet = cfg.AlphabetSymbols;

	// If we are working in case-insensitive mode, we will use only
	// capital letters, hence we must transform the whole alphabet
	// to uppercase.
	if (!cfg.CaseSensitiveAlphabet)
	{
		alphabet = cfg.AlphabetSymbols.ToUpper();
	}

	if (inputString != null)
	{
		for (int i = 0; i < inputString.Length; i++)
		{
			// Get the plaintext char currently being processed.
			char currentchar = inputString[i];

			// Store whether it is upper case (otherwise lowercase is assumed).
			bool uppercase = char.IsUpper(currentchar);

			// Get the position of the plaintext character in the alphabet.
			int ppos = 0;
			if (cfg.CaseSensitiveAlphabet)
			{
				ppos = alphabet.IndexOf(currentchar);
			}
			else
			{
				ppos = alphabet.IndexOf(char.ToUpper(currentchar));
			}

			if (ppos >= 0)
			{
				// We found the plaintext character in the alphabet,
				// hence we will commence shifting.
				int cpos = 0;
				switch (mode)
				{
					case CaesarMode.encrypt:
						cpos = (ppos + cfg.ShiftKey) % alphabet.Length;
						break;
					case CaesarMode.decrypt:
						cpos = (ppos - cfg.ShiftKey + alphabet.Length) % alphabet.Length;
						break;
				}

				// We have the position of the ciphertext character,
				// hence just output it in the correct case.
				if (cfg.CaseSensitiveAlphabet)
				{
					output.Append(alphabet[cpos]);
				}
				else
				{
					if (uppercase)
					{
						output.Append(char.ToUpper(alphabet[cpos]));
					}
					else
					{
						output.Append(char.ToLower(alphabet[cpos]));
					}
				}
			}
			else
			{
				// The plaintext character was not found in the alphabet,
				// hence proceed with handling unknown characters.
				switch ((CaesarSettings.UnknownSymbolHandlingMode)cfg.UnknownSymbolHandling)
				{
					case CaesarSettings.UnknownSymbolHandlingMode.Ignore:
						output.Append(inputString[i]);
						break;
					case CaesarSettings.UnknownSymbolHandlingMode.Replace:
						output.Append('?');
						break;
				}
			}

			// Show the progress.
			if (OnPluginProgressChanged != null)
			{
				OnPluginProgressChanged(this, new PluginProgressEventArgs(i, inputString.Length - 1));
			}
		}
		outputString = output.ToString();
		OnPropertyChanged("OutputString");
		OnPropertyChanged("OutputData");
	}
}

public void Encrypt()
{
	ProcessCaesar(CaesarMode.encrypt);
}

public void Decrypt()
{
	ProcessCaesar(CaesarMode.decrypt);
}

public void Execute()
{
	switch (settings.Action)
	{
		case 0:
			GuiLogMessage("Encrypting", NotificationLevel.Debug);
			Encrypt();
			break;
		case 1:
			GuiLogMessage("Decrypting", NotificationLevel.Debug);
			Decrypt();
			break;
		default:
    	break;
	}
}
\end{lstlisting}

\ \\
It is important to make sure that all changes to the output properties will be announced to the CrypTool 2 environment. In our example this happens by calling the set method of \textit{OutputData}, which in turn calls \textit{OnPropertyChanged} to indicate that both output properties \textit{OutputData} and \textit{OutputDataStream} have changed. Instead of calling the property's set method you could instead call \textit{OnPropertyChanged} directly within the \textit{Execute()} method.
\clearpage

You may have noticed that the \textit{ProgressChanged} method is undefined. This method can be used to show the current algorithm process as a progress bar in the plugin icon. To use this method and compile successfully, you must declare this method, which we have done for our example below. Note that the \textit{OnPluginProgressChanged} event will have been automatically generated by implementing the interface (see Section \ref{sec:AddingInterfaceFunctionsToTheCaesarClass}).

\begin{lstlisting}
public event PluginProgressChangedEventHandler OnPluginProgressChanged;

private void ProgressChanged(double value, double max)
{
	EventsHelper.ProgressChanged(OnPluginProgressChanged, this, new PluginProgressEventArgs(value, max));
}
\end{lstlisting}

\section{Performing a clean dispose}
\label{sec:PerformingACleanDispose}

Be sure you have closed and cleaned all your streams after execution before CrypTool 2 decides to dispose the plugin instance. Though not required, we will run the disposal code before execution as well. We will expand the associated automatically generated methods (see Section \ref{sec:AddingInterfaceFunctionsToTheCaesarClass}) as follows:

\begin{lstlisting}
public void Dispose()
{
	foreach(CryptoolStream stream in listCryptoolStreamsOut)
	{
		stream.Close();
	}
	listCryptoolStreamsOut.Clear();
}

public void PostExecution()
{
	Dispose();
}

public void PreExecution()
{
	Dispose();
}
\end{lstlisting}
\clearpage

\section{Finishing the implementation}
\label{sec:FinishingTheImplementation}

When adding plugin instances to the CrypTool 2 workspace, the application core checks whether the plugin runs without any exceptions. If any method inherited from IPlugin throws an exception, CrypTool 2 will display an error message and prohibit use of the plugin. Therefore, we must remove the \textit{NotImplementedException} from the automatically generated methods \textit{Initialize()}, \textit{Pause()} and \textit{Stop()}. In our example it will be sufficient to provide empty implementations:

\begin{lstlisting}
public void Initialize()
{
}

public void Pause()
{
}

public void Stop()
{
}
\end{lstlisting}

\ \\
The methods \textit{Presentation()} and \textit{QuickWatchPresentation()} can be used to provide a specialized visualization of the plugin algorithm to be shown in CrypTool 2. Take a look at the \textit{PRESENT} plugin to see how a custom visualization can be realized. For our Caesar example, we have chosen not to implement a custom visualization. Therefore we will simply return \texttt{null}:

\begin{lstlisting}
public UserControl Presentation
{
	get { return null; }
}

public UserControl QuickWatchPresentation
{
	get { return null; }
}
\end{lstlisting}

\ \\
Your plugin should compile without errors at this point.
\clearpage

\section{Importing and testing the plugin}
\label{sec:ImportingAndTestingThePlugin}

After you have built the plugin, you need to move the newly created plugin DLL to a location where CrypTool 2 can find it. There are currently a couple different ways to accomplish this. First, though, you need to locate the DLL. Once you have successfully compiled the plugin, the DLL should be in \textit{\mbox{\textbackslash CrypPluginBase\textbackslash }bin\textbackslash Debug}.

% Global Storage does not currently function - but presumably will be brought back in at another time.

%\subsection{Global storage}
%\label{sec:GlobalStorage}

%The first option is to copy your plugin's DLL file to the \textit{CrypPlugins} folder in which the CrypTool 2 %executable (\textit{CrypWin.exe}) can be found.

%\begin{figure}[h]
%	\centering
%		\includegraphics{figures/copy_dll_global_storage.jpg}
%	\caption{Copying the plugin to the global storage folder}
%	\label{fig:copy_dll_global_storage}
%\end{figure}

%This folder is known as ``global storage'' in the CrypTool 2 architecture. Changes in this folder will affect %all users on a multi-user Windows platform. You should now restart CrypTool 2.
%\clearpage

%\begin{figure}[h]
%	\centering
%		\includegraphics{figures/global_storage.jpg}
%	\caption{Inside the CrypPlugins folder (the global storage).}
%	\label{fig:global_storage}
%\end{figure}

\subsection{Custom storage}
\label{sec:CustomStorage}

The first possibility is to copy your plugin's DLL file to the \textit{CrypPlugins} folder located in the \textit{Application Data} folder in your home folder. In Windows XP, the home folder path should be as follows: \textit{C:\textbackslash Documents and Settings\textbackslash $<$user name$>$\textbackslash Application Data\textbackslash CrypPlugins}, and in Vista and Windows 7 the path should look like: \textit{C:\textbackslash Users\textbackslash $<$user name$>$\textbackslash Application Data\textbackslash CrypPlugins}. This home folder path is called ``custom storage'' in the CrypTool architecture. Changes in this folder will only take effect for current user. After copying the file, you must restart CrypTool 2.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/custom_storage.jpg}
	\caption{The custom storage folder.}
	\label{fig:custom_storage}
\end{figure}
\clearpage

% Direct import is currently not supported - but presumably it will return again in some form.

%\subsection{Importing directly}
%\label{sec:ImportingDirectly}

%Another option is to import new plugins directly from the CrypTool 2 interface. Just run \mbox{CrypWin.exe} and select the \textit{Download Plugins} button. An \textit{Open File Dialog} window will open and ask where the new plugin is located. After selecting the new plugin, CrypTool 2 will automatically import the plugin to the custom storage folder. With this option you will not have to restart the program. All corresponding menu entries will be updated automatically. Note that this option is just a temporary solution: in the future this will be done online by a web service.
%\clearpage

\subsection{Using build settings}
\label{sec:UsingBuildSettings}

Alternatively, you can use the build settings in your plugin's project properties to copy the DLL automatically after building it in Visual Studio. To set this up, right-click on your plugin project and select \textit{Properties}:

\begin{figure}[h]
	\centering
		\includegraphics{figures/solution_properties.JPG}
	\caption{Selecting the solution properties.}
	\label{fig:solution_properties}
\end{figure}
\clearpage

\noindent Then select \textit{Build Events}:

\begin{figure}[h]
	\centering
		\includegraphics{figures/post_build.JPG}
	\caption{Setting the build events.}
	\label{fig:post_build}
\end{figure}

\noindent And finally, enter the following text into the \textit{Post-build event command line} field:\\\\
cd "\$(ProjectDir)" \\
cd ..\textbackslash ..\textbackslash CrypWin\textbackslash bin\textbackslash Debug\\
if not exist ".\textbackslash CrypPlugins" mkdir ".\textbackslash CrypPlugins"\\
%del /F /S /Q /s /q "\colorbox{yellow}{Caesar}*.*"\\
%copy "\$(TargetDir)\colorbox{yellow}{Caesar}*.*" ".\textbackslash CrypPlugins"\\\\
% Colorbox is ugly and creates spaces around the box. Highlighting via the Soul package is much better!
del /F /S /Q /s /q "\hl{Caesar}*.*"\\
copy "\$(TargetDir)\hl{Caesar}*.*" ".\textbackslash CrypPlugins"\\\\
You will need to change the highlighted fields to your particular plugin's name.
\clearpage

\section{Drawing the workflow of your plugin}
\label{DrawingTheWorkfloweOfYourPlugin}

Each plugin should have an associated workflow file to show the algorithm in action in CrypTool 2. These workflow files are saved with the special \textit{.cte} file extension. You can view the example files from other plugins by opening any of the files in the \textit{\textbackslash ProjectSamples} folder with CrypTool 2. Below is a sample workflow for our Caesar example:

\begin{figure}[h]
	\centering
		\includegraphics{figures/sample.jpg}
	\caption{A sample workflow diagram for the Caesar algorithm.}
	\label{fig:sample}
\end{figure}

As your last step of development, once your plugin runs smoothly, you should also create one of these sample workflow files for your plugin. Such a file can be automatically created by simply saving a CrypTool 2 workspace project featuring your plugin. You should store the workflow file in the \textit{\textbackslash ProjectSamples} folder and make sure to commit the file to the SVN repository (see Section \ref{CommitingYourChanges}).