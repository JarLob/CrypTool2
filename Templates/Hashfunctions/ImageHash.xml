<?xml version="1.0" encoding="utf-8"?>
<sample>

  <title lang="en">ImageHash</title>
  <summary lang="en">Generate a hash to a given image</summary>
  <description lang="en">This template generates a blockhash of the chosen image and visualizes each step of the process.</description>
  <keywords>hash, blockhash, image</keywords>

  <title lang="de">BildHash</title>
  <summary lang="de">Erzeugung eines Hashes zu einem gegebenen Bild</summary>
  <description lang="de">Mit dieser Vorlage können Sie einen Blockhash zu einem gewählten Bild erzeugen und sich jeden Schritt visualisieren lassen.</description>
  <keywords lang="de">hash, blockhash, image</keywords>

  <icon file="ImageHash.png" />
  <relevantPlugins>
    <plugin name="ImageHash" />
    <plugin name="HammingDistance" />
  </relevantPlugins>

  <replacements lang="de">
    <replacement key="$File Input$" value="Dateieingabe"/>
    <replacement key="$Hash Value$" value="Hashwert"/>
    <replacement key="$Image Hash$" value="Bild Hash"/>
    <replacement key="$Original Image$" value="Originalbild"/>
    <replacement key="$Hashed Image$" value="Gehashtes Bild"/>
	 <replacement key="$memo1$" value="{\b What does this template?}\line This template takes an input image and calculates a block hash of this image. Both the original image and the visualized hash are shown. The actual has is displayed as text.\line\line {\b How does this template work?}\line The chosen input image is scaled down to the square of the input of the textfield &quot;Size&quot;. The original image is always shown. Which step of the process is displayed is chosen through the slider. If &quot;Show each step&quot; is enabled, every step of the process is shown directly.\line The sizes of the processed image and the hash depend on the input size."/>
	 <replacement key="$memo2$" value="{\b How is the Block Hash calculated?}\line\line The first step is gray scaling the original image. In the second step, the gray image is resized square to the input size. The third step is calculating the absolute brightness of each quarter of the picture. The image is flipped, so that the brightest quarter becomes the upper left corner. In the next step, the median is calculated for each quarter. That is the average brightness of the pixels. Each pixel is now set to white if its brightness is above the median of its quarter and black if not. This gives us the shown black and white hash image. (see {\b\i http://www.anwendertag-forensik.de/content/dam/anwendertag-forensik/de/documents/2011/Vortrag_Steinebach.pdf} by Dr. Martin Steinebach of the Fraunhofer SIT)\line\line These black and white pixels contain the information 0 and 1. These bits are put into an array. 8 bit are put into one byte. The first 8 bit yield the first byte. The first bit yields the lowest value of that byte (2^0), the last bit yields the highest value (2^7). The actual hash is the resulting byte array."/>
  </replacements>
  <replacements lang="en">
    <replacement key="$File Input$" value="File Input"/>
    <replacement key="$Hash Value$" value="Hash Value"/>
    <replacement key="$Image Hash$" value="Image Hash"/>
    <replacement key="$Original Image$" value="Original Image"/>
    <replacement key="$Hashed Image$" value="Hashed Image"/>
	 <replacement key="$memo1$" value="{\b What does this template?}\line This template takes an input image and calculates a block hash of this image. Both the original image and the visualized hash are shown. The actual has is displayed as text.\line\line {\b How does this template work?}\line The chosen input image is scaled down to the square of the input of the textfield &quot;Size&quot;. The original image is always shown. Which step of the process is displayed is chosen through the slider. If &quot;Show each step&quot; is enabled, every step of the process is shown directly.\line The sizes of the processed image and the hash depend on the input size."/>
	 <replacement key="$memo2$" value="{\b How is the Block Hash calculated?}\line\line The first step is gray scaling the original image. In the second step, the gray image is resized square to the input size. The third step is calculating the absolute brightness of each quarter of the picture. The image is flipped, so that the brightest quarter becomes the upper left corner. In the next step, the median is calculated for each quarter. That is the average brightness of the pixels. Each pixel is now set to white if its brightness is above the median of its quarter and black if not. This gives us the shown black and white hash image. (see {\b\i http://www.anwendertag-forensik.de/content/dam/anwendertag-forensik/de/documents/2011/Vortrag_Steinebach.pdf} by Dr. Martin Steinebach of the Fraunhofer SIT)\line\line These black and white pixels contain the information 0 and 1. These bits are put into an array. 8 bit are put into one byte. The first 8 bit yield the first byte. The first bit yields the lowest value of that byte (2^0), the last bit yields the highest value (2^7). The actual hash is the resulting byte array."/>
  </replacements>

</sample>
