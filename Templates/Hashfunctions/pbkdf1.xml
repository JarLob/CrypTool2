<?xml version="1.0" encoding="utf-8"?>
<sample>

  <title lang="en">PBKDF-1 (PKCS#5 2.0)</title>
  <summary lang="en">Password Based Key Derivation Function 1</summary>
  <description lang="en">This template shows how to implement PBKDF-1 in CrypTool 2</description>
  <keywords>Hash, SHA-1, pkcs#5, PBKDF-1, key generation, iterations, RFC 2898 </keywords>

  <title lang="de">PBKDF-1 (PKCS#5 2.0)</title>
  <summary lang="de">Passwortbasierte Schlüsselgeneration mit PBKDF-1</summary>
  <description lang="de">Diese Vorlage zeigt, wie man mit CT2 PBKDF-1 implementieren kann.</description>
  <keywords lang="de">Hash, SHA-1, pkcs#5, PBKDF-1,Schlüsselerzeugung</keywords>

  <icon file="pbkdf1.png" />
  <relevantPlugins>
    <plugin name="SHA" />
  </relevantPlugins>
  <replacements lang="de">
    <replacement key="$Gate$" value="Gatter"/>
    <replacement key="$Comparator$" value="Vergleicher"/>
    <replacement key="$String Decoder$" value="String-Decodierer"/>
    <replacement key="$Concatenate$" value="Konkatenation"/>
    <replacement key="$Password$" value="Passwort"/>
    <replacement key="$Incrementer$" value="Inkrementierer"/>
    <replacement key="$Key$" value="Schlüssel"/>
    <replacement key="$Progress$" value="Fortschritt"/>
    <replacement key="$Stop at$" value="Stop bei"/>
	 <replacement key="$memo$" value="{\b PBKDF1 (Password based key derivation function 1):}\line Diese Vorlage demonstriert, wie ein Schlüssel von einem Passwort abgeleitet werden kann. Es implementiert das im RFC2898 [1] beschriebene PBKDF1.\line\line Das vom Benutzer gegebene Passwort wird mit dem ebenfalls vom Benutzer angegebenen Salt konkateniert:\line {\b T_0 = Salt || Passwort}, wobei || für die Konkatenation steht.\line Danach werden von den T_s nacheinander die Hashwerte berechnet:\line {\b T_1 = hash(T_0)\line T_2 = hash(T_1)\line ...\line T_i = hash(T_i-1)},\line wobei T_1 der SHA-1-Hashwert von T_0 ist, T_2 der SHA-1-Hashwert von T_1, usw.\line Der endgültige Schlüssel ist dann der Wert T_i und wird in der Schlüssel-Komponente ausgegeben. Während der Ausführung wird der momentane Fortschritt in der Fortschritt-Komponente angezeigt. Hinweis: Um neue Schlüssel zu berechnen, muss die Vorlage jedes Mal neu gestartet werden. Um die Zwischenwerte bei der Hashwert-Berechnung zu sehen, muss im Gatter 3 das Auslöseereignis auf &quot;Pforte immer offen&quot; gesetzt werden.\line\line [1] RFC2898: https://tools.ietf.org/html/rfc2898"/>
  </replacements>
  <replacements lang="en">
    <replacement key="$Gate$" value="Gate"/>
    <replacement key="$Comparator$" value="Comparator"/>
    <replacement key="$String Decoder$" value="String Decoder"/>
    <replacement key="$Concatenate$" value="Concatenate"/>
    <replacement key="$Password$" value="Password"/>
    <replacement key="$Incrementer$" value="Incrementer"/>
    <replacement key="$Key$" value="Key"/>
    <replacement key="$Progress$" value="Progress"/>
    <replacement key="$Stop at$" value="Stop at"/>
	 <replacement key="$memo$" value="{\b PBKDF1 (Password based key derivation function 1):}\line This template demonstrates how to compute a key that is derived from a password. It implements PBKDF1 as described in the RFC2898 [1].\line\line The user given password is concatenated with the user given salt:\line {\b T_0 = Salt || Password}, where || means string concatenation.\line After that, the T_s are hashed in a row:\line {\b T_1 = hash(T_0)\line T_2 = hash(T_1)\line ...\line T_i = hash(T_i-1)},\line where T_1 is the SHA-1 hash of T_0, T_2 is the SHA-1 hash of T_1, and so on.\line The final key is equal to T_i and will appear in the Key TextOutput component. During the execution, the current progress is visible at the Progress component. Hint: To compute a new key, you have to restart the workspace every time. If you want to see intermediate hash values, change the Gate 3 to &quot;no trigger (always open)&quot;.\line\line [1] RFC2898: https://tools.ietf.org/html/rfc2898"/>
  </replacements>

</sample>
