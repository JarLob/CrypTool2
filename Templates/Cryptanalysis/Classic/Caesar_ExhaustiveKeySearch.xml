<?xml version="1.0" encoding="utf-8"?>
<sample>

  <title lang="en">Caesar Brute-force Analysis</title>
  <summary lang="en">Cryptanalysis of the <i>Caesar</i> cipher using brute-force</summary>
  <description lang="en">Since there are only a limited number of possible shifts (26 in English) using the Caesar cipher, every single shift can be tested in turn in a brute-force attack. One way to do this is to write
out a snippet of the ciphertext in a table of all possible shifts — a technique sometimes known as "completing the plain component". The example given is for
the a ciphertext; the plaintext is instantly recognisable by eye. Another way of viewing this method is that, under each letter
of the ciphertext, the entire alphabet is written out in reverse starting at that letter. This attack can be accelerated using a set of strips prepared with the alphabet
written down them in reverse order. The strips are then aligned to form the ciphertext along one row, and the plaintext should appear in one of the other rows.<newline /><newline />
Source: <external ref="http://en.wikipedia.org/wiki/Caesar_cipher" /></description>
  <keywords>Caesar, Julius, Attack, Analysis, Substitution, monoalphabetic</keywords>

  <title lang="de">Caesar Brute-Force-Analyse</title>
  <summary lang="de">Kryptoanalyse der <i>Caesar</i>-Verschlüsselung mit Brute-Force</summary>
  <description lang="de">Wie alle monoalphabetischen Verschlüsselungsverfahren bietet auch die Verschiebechiffre keine hinreichende Sicherheit gegen unbefugte Entzifferung und
kann sehr leicht „geknackt“ werden. Die ungleiche Verteilung der Buchstaben in der natürlichen Sprache wird durch diese Art der Verschlüsselung nicht verborgen, so dass eine Häufigkeitsanalyse das Wirken einer einfachen monoalphabetischen Substitution enthüllt. Noch einfacher nutzt der Angreifer die sehr kleine Anzahl der
möglichen Schlüssel. Da die Größe des Schlüsselraums nur 25 beträgt, was einer „Schlüssellänge“ von nicht einmal 5 bit entspricht, liegt nach Ausprobieren spätestens
nach dem 25. Versuch der Klartext vor. Eine erschöpfende Schlüsselsuche (Exhaustion) ist bei der Caesar-Verschlüsselung trivial realisierbar. Da dies auch ohne
Computer oder Rechenmaschine mit geringem Aufwand möglich ist, bestand die Sicherheit der Caesar-Verschlüsselung schon zu ihren Anfängen nicht auf der
Geheimhaltung des Schlüssels, sondern im Wesentlichen auf der Geheimhaltung des Verfahrens, und entspricht damit nicht dem im 19. Jahrhundert postulierten
Prinzip von Auguste Kerckhoffs.<newline /><newline />
Quelle: <external ref="http://de.wikipedia.org/wiki/Caesar-Verschlüsselung" /></description>
  <keywords lang="de">Cäsar, Caesar, monoalphabetisch, exhaustive, Angriff</keywords>

  <icon file="Caesar_Analysis.png" />
  <relevantPlugins>
    <plugin name="Caesar" />
    <plugin name="Comparators" />
    <plugin name="Contains" />
    <plugin name="CryptoolDictionary" />
    <plugin name="Gate" />
    <plugin name="IncDec" />
  </relevantPlugins>

  <replacements lang="de">
    <replacement key="$Ciphertext$" value="Geheimtext"/>
    <replacement key="$Decrypted Ciphertext$" value="Entschlüsselter Geheimtext"/>
    <replacement key="$Dictionary$" value="Wörterbuch"/>
    <replacement key="$Gate$" value="Gatter"/>
    <replacement key="$PlaintextGate$" value="Klartext-Gatter"/>
    <replacement key="$KeyGate$" value="Schlüssel-Gatter"/>
    <replacement key="$Contains$" value="Enthält"/>
    <replacement key="$Converter$" value="Konvertierer"/>
    <replacement key="$All possible plaintexts$" value="Alle möglichen Klartexte"/>
    <replacement key="$max shift key$" value="max. Verschiebung"/>
    <replacement key="$Found shift key$" value="Gefundene Verschiebung"/>
	 <replacement key="$memo$" value="{\b\fs21 Caesar - running down the alphabet\line\line}This sample performs a brute-force ciphertext-only attack on the Caesar cipher. The basic principle is that the ciphertext is decrypted with all possible shift values and for each resulting plaintext it is checked if it contains words from a dictionary. If several words are found it can be assumed with high probability that this is the correct decryption.\line\line {\fs20\b\ul How it works:}\line The encrypted text is forwarded to the Caesar component. The shift key for the Caesar cipher is incremented from 1 to the value given in &quot;max shift key&quot; in a loop. The loop is realized with the incrementer (i++) and the Gate. As long as the Gate is provided with a TRUE value from the Comparator (i &lt;= max shift key) component, the loop is running. For each shift key the Caesar cipher is therefore performing a trial decryption which are collected in the textoutput component &quot;All possible plaintexts&quot;. Additionally, the &quot;Contains&quot; component checks for each trial decryption if words from it can be found in the dictionary. If this is the case, the Contains component assigns TRUE to the PlaintextGate, and therefore the current decryption is assigned to the &quot;Decrypted ciphertext&quot; component.\line\line {\fs20\b\ul Hint:}\line If no plaintext is shown in the component &quot;Decrypted ciphertext&quot;, the ciphertext may either have been encrypted with another cipher, or the assumed plaintext language is wrong. So you may stop the workflow, select the dictionary, select another language and run the workfklow again."/> 
 </replacements>
 <replacements lang="en">
    <replacement key="$Ciphertext$" value="Ciphertext"/>
    <replacement key="$Decrypted Ciphertext$" value="Decrypted Ciphertext"/>
    <replacement key="$Dictionary$" value="Dictionary"/>
    <replacement key="$Gate$" value="Gate"/>
    <replacement key="$PlaintextGate$" value="PlaintextGate"/>
    <replacement key="$KeyGate$" value="KeyGate"/>
    <replacement key="$Contains$" value="Contains"/>
    <replacement key="$Converter$" value="Converter"/>
    <replacement key="$max shift key$" value="max shift key"/>
    <replacement key="$All possible plaintexts$" value="All possible plaintexts"/>
    <replacement key="$max shift key$" value="max shift key"/>
    <replacement key="$Found shift key$" value="Found shift key"/>
	 <replacement key="$memo$" value="{\b Caesar - running down the alphabet}\line\line This sample performs a brute-force ciphertext-only attack on the Caesar cipher. The basic principle is that the ciphertext is decrypted with all possible shift values and for each resulting plaintext it is checked if it contains words from a dictionary. If several words are found it can be assumed with high probability that this is the correct decryption.\line\line {\b\ul How it works:}\line The encrypted text is forwarded to the Caesar component. The shift key for the Caesar cipher is incremented from 1 to the value given in &quot;max shift key&quot; in a loop. The loop is realized with the incrementer (i++) and the Gate. As long as the Gate is provided with a TRUE value from the Comparator (i &lt;= max shift key) component, the loop is running. For each shift key the Caesar cipher is therefore performing a trial decryption which are collected in the textoutput component &quot;All possible plaintexts&quot;. Additionally, the &quot;Contains&quot; component checks for each trial decryption if words from it can be found in the dictionary. If this is the case, the Contains component assigns TRUE to the PlaintextGate, and therefore the current decryption is assigned to the &quot;Decrypted ciphertext&quot; component.\line\line {\b Hint:}\line If no plaintext is shown in the component &quot;Decrypted ciphertext&quot;, the ciphertext may either have been encrypted with another cipher, or the assumed plaintext language is wrong. So you may stop the workflow, select the dictionary, select another language and run the workfklow again."/> 
 </replacements>

</sample>
